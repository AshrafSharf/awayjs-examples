(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var LoaderEvent = require("awayjs-core/lib/events/LoaderEvent");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var AssetLibrary = require("awayjs-core/lib/library/AssetLibrary");
var AssetType = require("awayjs-core/lib/library/AssetType");
var URLRequest = require("awayjs-core/lib/net/URLRequest");
var Debug = require("awayjs-core/lib/utils/Debug");
var RequestAnimationFrame = require("awayjs-core/lib/utils/RequestAnimationFrame");
var DisplayObjectContainer = require("awayjs-display/lib/containers/DisplayObjectContainer");
var View = require("awayjs-display/lib/containers/View");
var DirectionalLight = require("awayjs-display/lib/entities/DirectionalLight");
var StaticLightPicker = require("awayjs-display/lib/materials/lightpickers/StaticLightPicker");
var TriangleMethodMaterial = require("awayjs-stagegl/lib/materials/TriangleMethodMaterial");
var DefaultRenderer = require("awayjs-stagegl/lib/render/DefaultRenderer");
var OBJParser = require("awayjs-renderergl/lib/parsers/OBJParser");
var ObjLoaderMasterChief = (function () {
    function ObjLoaderMasterChief() {
        var _this = this;
        this.meshes = new Array();
        this.spartan = new DisplayObjectContainer();
        this.spartanFlag = false;
        this.terrainObjFlag = false;
        Debug.LOG_PI_ERRORS = false;
        Debug.THROW_ERRORS = false;
        this.view = new View(new DefaultRenderer());
        this.view.camera.z = -50;
        this.view.camera.y = 20;
        this.view.camera.projection.near = 0.1;
        this.view.backgroundColor = 0xCEC8C6;
        this.raf = new RequestAnimationFrame(this.render, this);
        this.light = new DirectionalLight();
        this.light.color = 0xc1582d;
        this.light.direction = new Vector3D(1, 0, 0);
        this.light.ambient = 0.4;
        this.light.ambientColor = 0x85b2cd;
        this.light.diffuse = 2.8;
        this.light.specular = 1.8;
        this.spartan.transform.scale = new Vector3D(.25, .25, .25);
        this.spartan.y = 0;
        this.view.scene.addChild(this.light);
        AssetLibrary.enableParser(OBJParser);
        this.token = AssetLibrary.load(new URLRequest('assets/Halo_3_SPARTAN4.obj'));
        this.token.addEventListener(LoaderEvent.RESOURCE_COMPLETE, function (event) { return _this.onResourceComplete(event); });
        this.token = AssetLibrary.load(new URLRequest('assets/terrain.obj'));
        this.token.addEventListener(LoaderEvent.RESOURCE_COMPLETE, function (event) { return _this.onResourceComplete(event); });
        this.token = AssetLibrary.load(new URLRequest('assets/masterchief_base.png'));
        this.token.addEventListener(LoaderEvent.RESOURCE_COMPLETE, function (event) { return _this.onResourceComplete(event); });
        this.token = AssetLibrary.load(new URLRequest('assets/stone_tx.jpg'));
        this.token.addEventListener(LoaderEvent.RESOURCE_COMPLETE, function (event) { return _this.onResourceComplete(event); });
        window.onresize = function (event) { return _this.onResize(); };
        this.raf.start();
    }
    ObjLoaderMasterChief.prototype.render = function () {
        if (this.terrain)
            this.terrain.rotationY += 0.4;
        this.spartan.rotationY += 0.4;
        this.view.render();
    };
    ObjLoaderMasterChief.prototype.onResourceComplete = function (event) {
        var loader = event.target;
        var l = loader.baseDependency.assets.length;
        console.log('------------------------------------------------------------------------------');
        console.log('away.events.LoaderEvent.RESOURCE_COMPLETE', event, l, loader);
        console.log('------------------------------------------------------------------------------');
        var loader = event.target;
        var l = loader.baseDependency.assets.length;
        for (var c = 0; c < l; c++) {
            var d = loader.baseDependency.assets[c];
            console.log(d.name, event.url);
            switch (d.assetType) {
                case AssetType.MESH:
                    if (event.url == 'assets/Halo_3_SPARTAN4.obj') {
                        var mesh = d;
                        this.spartan.addChild(mesh);
                        this.spartanFlag = true;
                        this.meshes.push(mesh);
                    }
                    else if (event.url == 'assets/terrain.obj') {
                        this.terrainObjFlag = true;
                        this.terrain = d;
                        this.terrain.y = 98;
                        this.view.scene.addChild(this.terrain);
                    }
                    break;
                case AssetType.TEXTURE:
                    if (event.url == 'assets/masterchief_base.png') {
                        this.mat = new TriangleMethodMaterial(d, true, true, false);
                        this.mat.lightPicker = new StaticLightPicker([this.light]);
                    }
                    else if (event.url == 'assets/stone_tx.jpg') {
                        this.terrainMaterial = new TriangleMethodMaterial(d, true, true, false);
                        this.terrainMaterial.lightPicker = new StaticLightPicker([this.light]);
                    }
                    break;
            }
        }
        if (this.terrainObjFlag && this.terrainMaterial) {
            this.terrain.material = this.terrainMaterial;
            this.terrain.geometry.scaleUV(20, 20);
        }
        if (this.mat && this.spartanFlag)
            for (var c = 0; c < this.meshes.length; c++)
                this.meshes[c].material = this.mat;
        this.view.scene.addChild(this.spartan);
        this.onResize();
    };
    ObjLoaderMasterChief.prototype.onResize = function (event) {
        if (event === void 0) { event = null; }
        this.view.y = 0;
        this.view.x = 0;
        this.view.width = window.innerWidth;
        this.view.height = window.innerHeight;
    };
    return ObjLoaderMasterChief;
})();
window.onload = function () {
    new ObjLoaderMasterChief(); // Start the demo
};


},{"awayjs-core/lib/events/LoaderEvent":12,"awayjs-core/lib/geom/Vector3D":19,"awayjs-core/lib/library/AssetLibrary":20,"awayjs-core/lib/library/AssetType":25,"awayjs-core/lib/net/URLRequest":35,"awayjs-core/lib/utils/Debug":52,"awayjs-core/lib/utils/RequestAnimationFrame":53,"awayjs-display/lib/containers/DisplayObjectContainer":62,"awayjs-display/lib/containers/View":64,"awayjs-display/lib/entities/DirectionalLight":66,"awayjs-display/lib/materials/lightpickers/StaticLightPicker":77,"awayjs-renderergl/lib/parsers/OBJParser":134,"awayjs-stagegl/lib/materials/TriangleMethodMaterial":388,"awayjs-stagegl/lib/render/DefaultRenderer":432}],2:[function(require,module,exports){
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
var ColorUtils = require("awayjs-core/lib/utils/ColorUtils");
/**
 *
 */
var BitmapData = (function () {
    /**
     *
     * @param width
     * @param height
     * @param transparent
     * @param fillColor
     */
    function BitmapData(width, height, transparent, fillColor) {
        if (transparent === void 0) { transparent = true; }
        if (fillColor === void 0) { fillColor = null; }
        this._alpha = 0;
        this._locked = false;
        this._transparent = transparent;
        this._imageCanvas = document.createElement("canvas");
        this._imageCanvas.width = width;
        this._imageCanvas.height = height;
        this._context = this._imageCanvas.getContext("2d");
        this._rect = new Rectangle(0, 0, width, height);
        if (fillColor != null) {
            if (this._transparent) {
                this._alpha = ColorUtils.float32ColorToARGB(fillColor)[0] / 255;
            }
            else {
                this._alpha = 1;
            }
            this.fillRect(this._rect, fillColor);
        }
    }
    /**
     *
     */
    BitmapData.prototype.dispose = function () {
        this._context = null;
        this._imageCanvas = null;
        this._imageData = null;
        this._rect = null;
        this._transparent = null;
        this._locked = null;
    };
    /**
     *
     */
    BitmapData.prototype.lock = function () {
        this._locked = true;
        this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
    };
    /**
     *
     */
    BitmapData.prototype.unlock = function () {
        this._locked = false;
        if (this._imageData) {
            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
            this._imageData = null;
        }
    };
    /**
     *
     * @param x
     * @param y
     * @param color
     */
    BitmapData.prototype.getPixel = function (x, y) {
        var r;
        var g;
        var b;
        var a;
        if (!this._locked) {
            var pixelData = this._context.getImageData(x, y, 1, 1);
            r = pixelData.data[0];
            g = pixelData.data[1];
            b = pixelData.data[2];
            a = pixelData.data[3];
        }
        else {
            var index = (x + y * this._imageCanvas.width) * 4;
            if (!this._imageData)
                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
            r = this._imageData.data[index + 0];
            g = this._imageData.data[index + 1];
            b = this._imageData.data[index + 2];
            a = this._imageData.data[index + 3];
        }
        if (!this._locked) {
            this._imageData = null;
        }
        return (a << 24) | (r << 16) | (g << 8) | b;
    };
    /**
     *
     * @param x
     * @param y
     * @param color
     */
    BitmapData.prototype.setPixel = function (x, y, color) {
        var argb = ColorUtils.float32ColorToARGB(color);
        if (!this._locked)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        if (this._imageData) {
            var index = (x + y * this._imageCanvas.width) * 4;
            this._imageData.data[index + 0] = argb[1];
            this._imageData.data[index + 1] = argb[2];
            this._imageData.data[index + 2] = argb[3];
            this._imageData.data[index + 3] = 255;
        }
        if (!this._locked) {
            this._context.putImageData(this._imageData, 0, 0);
            this._imageData = null;
        }
    };
    /**
     *
     * @param rect
     * @param inputByteArray
     */
    BitmapData.prototype.setPixels = function (rect, inputByteArray) {
        if (!this._locked)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        if (this._imageData) {
            inputByteArray.position = 0;
            var i /*uint*/, j /*uint*/, index /*uint*/;
            for (i = 0; i < rect.width; ++i) {
                for (j = 0; j < rect.height; ++j) {
                    index = (i + rect.x + (j + rect.y) * this._imageCanvas.width) * 4;
                    this._imageData.data[index + 0] = inputByteArray.readUnsignedInt();
                    this._imageData.data[index + 1] = inputByteArray.readUnsignedInt();
                    this._imageData.data[index + 2] = inputByteArray.readUnsignedInt();
                    this._imageData.data[index + 3] = inputByteArray.readUnsignedInt();
                }
            }
        }
        if (!this._locked) {
            this._context.putImageData(this._imageData, 0, 0);
            this._imageData = null;
        }
    };
    /**
     *
     * @param x
     * @param y
     * @param color
     */
    BitmapData.prototype.setPixel32 = function (x, y, color) {
        var argb = ColorUtils.float32ColorToARGB(color);
        if (!this._locked)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        if (this._imageData) {
            var index = (x + y * this._imageCanvas.width) * 4;
            this._imageData.data[index + 0] = argb[1];
            this._imageData.data[index + 1] = argb[2];
            this._imageData.data[index + 2] = argb[3];
            this._imageData.data[index + 3] = argb[0];
        }
        if (!this._locked) {
            this._context.putImageData(this._imageData, 0, 0);
            this._imageData = null;
        }
    };
    BitmapData.prototype.setVector = function (rect, inputVector) {
        if (!this._locked)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        if (this._imageData) {
            var i /*uint*/, j /*uint*/, index /*uint*/, argb /*uint*/;
            for (i = 0; i < rect.width; ++i) {
                for (j = 0; j < rect.height; ++j) {
                    argb = ColorUtils.float32ColorToARGB(inputVector[i + j * rect.width]);
                    index = (i + rect.x + (j + rect.y) * this._imageCanvas.width) * 4;
                    this._imageData.data[index + 0] = argb[1];
                    this._imageData.data[index + 1] = argb[2];
                    this._imageData.data[index + 2] = argb[3];
                    this._imageData.data[index + 3] = argb[0];
                }
            }
        }
        if (!this._locked) {
            this._context.putImageData(this._imageData, 0, 0);
            this._imageData = null;
        }
    };
    BitmapData.prototype.drawImage = function (img, sourceRect, destRect) {
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) draw object
            //      3) read _imageData back out
            if (this._imageData) {
                this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
            }
            this._drawImage(img, sourceRect, destRect);
            if (this._imageData) {
                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
            }
        }
        else {
            this._drawImage(img, sourceRect, destRect);
        }
    };
    BitmapData.prototype._drawImage = function (img, sourceRect, destRect) {
        if (img instanceof BitmapData)
            this._context.drawImage(img.canvas, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
        else if (img instanceof HTMLImageElement)
            this._context.drawImage(img, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
    };
    BitmapData.prototype.copyPixels = function (bmpd, sourceRect, destRect) {
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) draw object
            //      3) read _imageData back out
            if (this._imageData) {
                this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
            }
            this._copyPixels(bmpd, sourceRect, destRect);
            if (this._imageData) {
                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
            }
        }
        else {
            this._copyPixels(bmpd, sourceRect, destRect);
        }
    };
    BitmapData.prototype._copyPixels = function (bmpd, sourceRect, destRect) {
        if (bmpd instanceof BitmapData) {
            this._context.drawImage(bmpd.canvas, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
        }
        else if (bmpd instanceof HTMLImageElement) {
            this._context.drawImage(bmpd, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
        }
    };
    /**
     *
     * @param rect
     * @param color
     */
    BitmapData.prototype.fillRect = function (rect, color) {
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) apply fill
            //      3) read _imageData back out
            if (this._imageData)
                this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
            this._context.fillStyle = this.hexToRGBACSS(color);
            this._context.fillRect(rect.x, rect.y, rect.width, rect.height);
            if (this._imageData)
                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        }
        else {
            this._context.fillStyle = this.hexToRGBACSS(color);
            this._context.fillRect(rect.x, rect.y, rect.width, rect.height);
        }
    };
    BitmapData.prototype.draw = function (source, matrix) {
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) draw object
            //      3) read _imageData back out
            if (this._imageData)
                this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
            this._draw(source, matrix);
            if (this._imageData)
                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        }
        else {
            this._draw(source, matrix);
        }
    };
    BitmapData.prototype._draw = function (source, matrix) {
        if (source instanceof BitmapData) {
            this._context.save();
            if (matrix != null)
                this._context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
            this._context.drawImage(source.canvas, 0, 0);
            this._context.restore();
        }
        else if (source instanceof HTMLImageElement) {
            this._context.save();
            if (matrix != null)
                this._context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
            this._context.drawImage(source, 0, 0);
            this._context.restore();
        }
    };
    BitmapData.prototype.copyChannel = function (sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
        var imageData = sourceBitmap.imageData;
        if (!this._locked)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        if (this._imageData) {
            var sourceData = sourceBitmap.imageData.data;
            var destData = this._imageData.data;
            var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
            var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
            var i /*uint*/, j /*uint*/, sourceIndex /*uint*/, destIndex /*uint*/;
            for (i = 0; i < sourceRect.width; ++i) {
                for (j = 0; j < sourceRect.height; ++j) {
                    sourceIndex = (i + sourceRect.x + (j + sourceRect.y) * sourceBitmap.width) * 4;
                    destIndex = (i + destPoint.x + (j + destPoint.y) * this.width) * 4;
                    destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
                }
            }
        }
        if (!this._locked) {
            this._context.putImageData(this._imageData, 0, 0);
            this._imageData = null;
        }
    };
    BitmapData.prototype.colorTransform = function (rect, colorTransform) {
        if (!this._locked)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        if (this._imageData) {
            var data = this._imageData.data;
            var i /*uint*/, j /*uint*/, index /*uint*/;
            for (i = 0; i < rect.width; ++i) {
                for (j = 0; j < rect.height; ++j) {
                    index = (i + rect.x + (j + rect.y) * this.width) * 4;
                    data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
                    data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
                    data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
                    data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
                }
            }
        }
        if (!this._locked) {
            this._context.putImageData(this._imageData, 0, 0);
            this._imageData = null;
        }
    };
    Object.defineProperty(BitmapData.prototype, "imageData", {
        /**
         *
         * @returns {ImageData}
         */
        get: function () {
            return this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        },
        /**
         *
         * @param {ImageData}
         */
        set: function (value) {
            this._context.putImageData(value, 0, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "width", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._imageCanvas.width;
        },
        /**
         *
         * @param {number}
         */
        set: function (value) {
            this._rect.width = value;
            this._imageCanvas.width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "height", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._imageCanvas.height;
        },
        /**
         *
         * @param {number}
         */
        set: function (value) {
            this._rect.height = value;
            this._imageCanvas.height = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "rect", {
        /**
         *
         * @param {Rectangle}
         */
        get: function () {
            return this._rect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "canvas", {
        /**
         *
         * @returns {HTMLCanvasElement}
         */
        get: function () {
            return this._imageCanvas;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "context", {
        /**
         *
         * @returns {HTMLCanvasElement}
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    // Private
    /**
     * convert decimal value to Hex
     */
    BitmapData.prototype.hexToRGBACSS = function (d) {
        var argb = ColorUtils.float32ColorToARGB(d);
        if (this._transparent == false) {
            argb[0] = 1;
            return 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] + ')';
        }
        return 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] / 255 + ')';
    };
    return BitmapData;
})();
module.exports = BitmapData;


},{"awayjs-core/lib/geom/Rectangle":18,"awayjs-core/lib/utils/ColorUtils":51}],3:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
/**
 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
 * by a concrete subclass.
 */
var AbstractMethodError = (function (_super) {
    __extends(AbstractMethodError, _super);
    /**
     * Create a new AbstractMethodError.
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function AbstractMethodError(message, id) {
        if (message === void 0) { message = null; }
        if (id === void 0) { id = 0; }
        _super.call(this, message || "An abstract method was called! Either an instance of an abstract class was created, or an abstract method was not overridden by the subclass.", id);
    }
    return AbstractMethodError;
})(Error);
module.exports = AbstractMethodError;


},{"awayjs-core/lib/errors/Error":5}],4:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
/**
 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
 * by a concrete subclass.
 */
var ArgumentError = (function (_super) {
    __extends(ArgumentError, _super);
    /**
     * Create a new ArgumentError.
     *
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function ArgumentError(message, id) {
        if (message === void 0) { message = null; }
        if (id === void 0) { id = 0; }
        _super.call(this, message || "ArgumentError", id);
    }
    return ArgumentError;
})(Error);
module.exports = ArgumentError;


},{"awayjs-core/lib/errors/Error":5}],5:[function(require,module,exports){
var Error = (function () {
    function Error(message, id, _name) {
        if (message === void 0) { message = ''; }
        if (id === void 0) { id = 0; }
        if (_name === void 0) { _name = ''; }
        this._errorID = 0; //Contains the reference number associated with the specific error message.
        this._messsage = ''; //Contains the message associated with the Error object.
        this._name = ''; // Contains the name of the Error object.
        this._messsage = message;
        this._name = name;
        this._errorID = id;
    }
    Object.defineProperty(Error.prototype, "message", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._messsage;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            this._messsage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Error.prototype, "name", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._name;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            this._name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Error.prototype, "errorID", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._errorID;
        },
        enumerable: true,
        configurable: true
    });
    return Error;
})();
module.exports = Error;


},{}],6:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
/**
 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
 * by a concrete subclass.
 */
var PartialImplementationError = (function (_super) {
    __extends(PartialImplementationError, _super);
    /**
     * Create a new AbstractMethodError.
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function PartialImplementationError(dependency, id) {
        if (dependency === void 0) { dependency = ''; }
        if (id === void 0) { id = 0; }
        _super.call(this, "PartialImplementationError - this function is in development. Required Dependency: " + dependency, id);
    }
    return PartialImplementationError;
})(Error);
module.exports = PartialImplementationError;


},{"awayjs-core/lib/errors/Error":5}],7:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
/**
 * @class away.events.AssetEvent
 */
var AssetEvent = (function (_super) {
    __extends(AssetEvent, _super);
    /**
     *
     */
    function AssetEvent(type, asset, prevName) {
        if (asset === void 0) { asset = null; }
        if (prevName === void 0) { prevName = null; }
        _super.call(this, type);
        this._asset = asset;
        this._prevName = prevName || (this._asset ? this._asset.name : null);
    }
    Object.defineProperty(AssetEvent.prototype, "asset", {
        /**
         *
         */
        get: function () {
            return this._asset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetEvent.prototype, "assetPrevName", {
        /**
         *
         */
        get: function () {
            return this._prevName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    AssetEvent.prototype.clone = function () {
        return new AssetEvent(this.type, this.asset, this.assetPrevName);
    };
    /**
     *
     */
    AssetEvent.ASSET_COMPLETE = "assetComplete";
    /**
     *
     */
    AssetEvent.ASSET_RENAME = 'assetRename';
    /**
     *
     */
    AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';
    /**
     *
     */
    AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';
    return AssetEvent;
})(Event);
module.exports = AssetEvent;


},{"awayjs-core/lib/events/Event":8}],8:[function(require,module,exports){
var Event = (function () {
    function Event(type) {
        /**
         * Type of event
         * @property type
         * @type String
         */
        this.type = undefined;
        /**
         * Reference to target object
         * @property target
         * @type Object
         */
        this.target = undefined;
        this.type = type;
    }
    /**
     * Clones the current event.
     * @return An exact duplicate of the current event.
     */
    Event.prototype.clone = function () {
        return new Event(this.type);
    };
    Event.COMPLETE = 'complete';
    Event.OPEN = 'open';
    Event.ENTER_FRAME = 'enterFrame';
    Event.EXIT_FRAME = 'exitFrame';
    Event.RESIZE = "resize";
    Event.ERROR = "error";
    Event.CHANGE = "change";
    return Event;
})();
module.exports = Event;


},{}],9:[function(require,module,exports){
/**
 * Base class for dispatching events
*
* @class away.events.EventDispatcher
*
*/
var EventDispatcher = (function () {
    function EventDispatcher(target) {
        if (target === void 0) { target = null; }
        this.listeners = new Array();
        this.target = target || this;
    }
    /**
     * Add an event listener
     * @method addEventListener
     * @param {String} Name of event to add a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.addEventListener = function (type, listener) {
        if (this.listeners[type] === undefined)
            this.listeners[type] = new Array();
        if (this.getEventListenerIndex(type, listener) === -1)
            this.listeners[type].push(listener);
    };
    /**
     * Remove an event listener
     * @method removeEventListener
     * @param {String} Name of event to remove a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.removeEventListener = function (type, listener) {
        var index = this.getEventListenerIndex(type, listener);
        if (index !== -1)
            this.listeners[type].splice(index, 1);
    };
    /**
     * Dispatch an event
     * @method dispatchEvent
     * @param {Event} Event to dispatch
     */
    EventDispatcher.prototype.dispatchEvent = function (event) {
        var listenerArray = this.listeners[event.type];
        if (listenerArray !== undefined) {
            var l = listenerArray.length;
            event.target = this.target;
            for (var i = 0; i < l; i++)
                listenerArray[i](event);
        }
    };
    /**
     * get Event Listener Index in array. Returns -1 if no listener is added
     * @method getEventListenerIndex
     * @param {String} Name of event to remove a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.getEventListenerIndex = function (type, listener) {
        if (this.listeners[type] !== undefined) {
            var a = this.listeners[type];
            var l = a.length;
            for (var i = 0; i < l; i++)
                if (listener == a[i])
                    return i;
        }
        return -1;
    };
    /**
     * check if an object has an event listener assigned to it
     * @method hasListener
     * @param {String} Name of event to remove a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.hasEventListener = function (type, listener) {
        if (listener != null) {
            return (this.getEventListenerIndex(type, listener) !== -1);
        }
        else {
            if (this.listeners[type] !== undefined)
                return (this.listeners[type].length > 0);
            return false;
        }
        return false;
    };
    return EventDispatcher;
})();
module.exports = EventDispatcher;


},{}],10:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
/**
 * @class away.events.HTTPStatusEvent
 */
var HTTPStatusEvent = (function (_super) {
    __extends(HTTPStatusEvent, _super);
    function HTTPStatusEvent(type, status) {
        if (status === void 0) { status = null; }
        _super.call(this, type);
        this.status = status;
    }
    HTTPStatusEvent.HTTP_STATUS = "httpStatus";
    return HTTPStatusEvent;
})(Event);
module.exports = HTTPStatusEvent;


},{"awayjs-core/lib/events/Event":8}],11:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var IOErrorEvent = (function (_super) {
    __extends(IOErrorEvent, _super);
    function IOErrorEvent(type) {
        _super.call(this, type);
    }
    IOErrorEvent.IO_ERROR = "ioError";
    return IOErrorEvent;
})(Event);
module.exports = IOErrorEvent;


},{"awayjs-core/lib/events/Event":8}],12:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var LoaderEvent = (function (_super) {
    __extends(LoaderEvent, _super);
    /**
     * Create a new LoaderEvent object.
     *
     * @param type The event type.
     * @param url The url of the loaded resource.
     * @param assets The assets of the loaded resource.
     */
    function LoaderEvent(type, url, content, assets) {
        if (url === void 0) { url = null; }
        if (content === void 0) { content = null; }
        if (assets === void 0) { assets = null; }
        _super.call(this, type);
        this._url = url;
        this._content = content;
        this._assets = assets;
    }
    Object.defineProperty(LoaderEvent.prototype, "content", {
        /**
         * The content returned if the resource has been loaded inside a <code>Loader</code> object.
         */
        get: function () {
            return this._content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderEvent.prototype, "url", {
        /**
         * The url of the loaded resource.
         */
        get: function () {
            return this._url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderEvent.prototype, "assets", {
        /**
         * The error string on loadError.
         */
        get: function () {
            return this._assets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the current event.
     * @return An exact duplicate of the current event.
     */
    LoaderEvent.prototype.clone = function () {
        return new LoaderEvent(this.type, this._url, this._content, this._assets);
    };
    /**
     * Dispatched when a resource and all of its dependencies is retrieved.
     */
    LoaderEvent.RESOURCE_COMPLETE = "resourceComplete";
    return LoaderEvent;
})(Event);
module.exports = LoaderEvent;


},{"awayjs-core/lib/events/Event":8}],13:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var ParserEvent = (function (_super) {
    __extends(ParserEvent, _super);
    function ParserEvent(type, message) {
        if (message === void 0) { message = ''; }
        _super.call(this, type);
        this._message = message;
    }
    Object.defineProperty(ParserEvent.prototype, "message", {
        /**
         * Additional human-readable message. Usually supplied for ParserEvent.PARSE_ERROR events.
         */
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    ParserEvent.prototype.clone = function () {
        return new ParserEvent(this.type, this.message);
    };
    /**
     * Dispatched when parsing of an asset completed.
     */
    ParserEvent.PARSE_COMPLETE = 'parseComplete';
    /**
     * Dispatched when an error occurs while parsing the data (e.g. because it's
     * incorrectly formatted.)
     */
    ParserEvent.PARSE_ERROR = 'parseError';
    /**
     * Dispatched when a parser is ready to have dependencies retrieved and resolved.
     * This is an internal event that should rarely (if ever) be listened for by
     * external classes.
     */
    ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';
    return ParserEvent;
})(Event);
module.exports = ParserEvent;


},{"awayjs-core/lib/events/Event":8}],14:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var ProgressEvent = (function (_super) {
    __extends(ProgressEvent, _super);
    function ProgressEvent(type) {
        _super.call(this, type);
    }
    ProgressEvent.PROGRESS = "progress";
    return ProgressEvent;
})(Event);
module.exports = ProgressEvent;


},{"awayjs-core/lib/events/Event":8}],15:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var TimerEvent = (function (_super) {
    __extends(TimerEvent, _super);
    function TimerEvent(type) {
        _super.call(this, type);
    }
    TimerEvent.TIMER = "timer";
    TimerEvent.TIMER_COMPLETE = "timerComplete";
    return TimerEvent;
})(Event);
module.exports = TimerEvent;


},{"awayjs-core/lib/events/Event":8}],16:[function(require,module,exports){
var Point = require("awayjs-core/lib/geom/Point");
var ArgumentError = require("awayjs-core/lib/errors/ArgumentError");
/**
 * The Matrix class represents a transformation matrix that determines how to
 * map points from one coordinate space to another. You can perform various
 * graphical transformations on a display object by setting the properties of
 * a Matrix object, applying that Matrix object to the <code>matrix</code>
 * property of a Transform object, and then applying that Transform object as
 * the <code>transform</code> property of the display object. These
 * transformation functions include translation(<i>x</i> and <i>y</i>
 * repositioning), rotation, scaling, and skewing.
 *
 * <p>Together these types of transformations are known as <i>affine
 * transformations</i>. Affine transformations preserve the straightness of
 * lines while transforming, so that parallel lines stay parallel.</p>
 *
 * <p>To apply a transformation matrix to a display object, you create a
 * Transform object, set its <code>matrix</code> property to the
 * transformation matrix, and then set the <code>transform</code> property of
 * the display object to the Transform object. Matrix objects are also used as
 * parameters of some methods, such as the following:</p>
 *
 * <ul>
 *   <li>The <code>draw()</code> method of a BitmapData object</li>
 *   <li>The <code>beginBitmapFill()</code> method,
 * <code>beginGradientFill()</code> method, or
 * <code>lineGradientStyle()</code> method of a Graphics object</li>
 * </ul>
 *
 * <p>A transformation matrix object is a 3 x 3 matrix with the following
 * contents:</p>
 *
 * <p>In traditional transformation matrixes, the <code>u</code>,
 * <code>v</code>, and <code>w</code> properties provide extra capabilities.
 * The Matrix class can only operate in two-dimensional space, so it always
 * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
 * and that the property value <code>w</code> is 1.0. The effective values of
 * the matrix are as follows:</p>
 *
 * <p>You can get and set the values of all six of the other properties in a
 * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
 * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
 *
 * <p>The Matrix class supports the four major types of transformations:
 * translation, scaling, rotation, and skewing. You can set three of these
 * transformations by using specialized methods, as described in the following
 * table: </p>
 *
 * <p>Each transformation function alters the current matrix properties so
 * that you can effectively combine multiple transformations. To do this, you
 * call more than one transformation function before applying the matrix to
 * its display object target(by using the <code>transform</code> property of
 * that display object).</p>
 *
 * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
 * before you can call the methods of the Matrix object.</p>
 */
var Matrix = (function () {
    /**
     * Creates a new Matrix object with the specified parameters. In matrix
     * notation, the properties are organized like this:
     *
     * <p>If you do not provide any parameters to the <code>new Matrix()</code>
     * constructor, it creates an <i>identity matrix</i> with the following
     * values:</p>
     *
     * <p>In matrix notation, the identity matrix looks like this:</p>
     *
     * @param a  The value that affects the positioning of pixels along the
     *           <i>x</i> axis when scaling or rotating an image.
     * @param b  The value that affects the positioning of pixels along the
     *           <i>y</i> axis when rotating or skewing an image.
     * @param c  The value that affects the positioning of pixels along the
     *           <i>x</i> axis when rotating or skewing an image.
     * @param d  The value that affects the positioning of pixels along the
     *           <i>y</i> axis when scaling or rotating an image..
     * @param tx The distance by which to translate each point along the <i>x</i>
     *           axis.
     * @param ty The distance by which to translate each point along the <i>y</i>
     *           axis.
     */
    function Matrix(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 1; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    /**
     * Returns a new Matrix object that is a clone of this matrix, with an exact
     * copy of the contained object.
     *
     * @return A Matrix object.
     */
    Matrix.prototype.clone = function () {
        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
    };
    /**
     * Concatenates a matrix with the current matrix, effectively combining the
     * geometric effects of the two. In mathematical terms, concatenating two
     * matrixes is the same as combining them using matrix multiplication.
     *
     * <p>For example, if matrix <code>m1</code> scales an object by a factor of
     * four, and matrix <code>m2</code> rotates an object by 1.5707963267949
     * radians(<code>Math.PI/2</code>), then <code>m1.concat(m2)</code>
     * transforms <code>m1</code> into a matrix that scales an object by a factor
     * of four and rotates the object by <code>Math.PI/2</code> radians. </p>
     *
     * <p>This method replaces the source matrix with the concatenated matrix. If
     * you want to concatenate two matrixes without altering either of the two
     * source matrixes, first copy the source matrix by using the
     * <code>clone()</code> method, as shown in the Class Examples section.</p>
     *
     * @param matrix The matrix to be concatenated to the source matrix.
     */
    Matrix.prototype.concat = function (matrix) {
        var a1 = this.a * matrix.a + this.b * matrix.c;
        this.b = this.a * matrix.b + this.b * matrix.d;
        this.a = a1;
        var c1 = this.c * matrix.a + this.d * matrix.c;
        this.d = this.c * matrix.b + this.d * matrix.d;
        this.c = c1;
        var tx1 = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
        this.tx = tx1;
    };
    /**
     * Copies a Vector3D object into specific column of the calling Matrix3D
     * object.
     *
     * @param column   The column from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyColumnFrom = function (column, vector3D) {
        if (column > 2) {
            throw "Column " + column + " out of bounds (2)";
        }
        else if (column == 0) {
            this.a = vector3D.x;
            this.c = vector3D.y;
        }
        else if (column == 1) {
            this.b = vector3D.x;
            this.d = vector3D.y;
        }
        else {
            this.tx = vector3D.x;
            this.ty = vector3D.y;
        }
    };
    /**
     * Copies specific column of the calling Matrix object into the Vector3D
     * object. The w element of the Vector3D object will not be changed.
     *
     * @param column   The column from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyColumnTo = function (column, vector3D) {
        if (column > 2) {
            throw new ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 2]");
        }
        else if (column == 0) {
            vector3D.x = this.a;
            vector3D.y = this.c;
            vector3D.z = 0;
        }
        else if (column == 1) {
            vector3D.x = this.b;
            vector3D.y = this.d;
            vector3D.z = 0;
        }
        else {
            vector3D.x = this.tx;
            vector3D.y = this.ty;
            vector3D.z = 1;
        }
    };
    /**
     * Copies all of the matrix data from the source Point object into the
     * calling Matrix object.
     *
     * @param sourceMatrix The Matrix object from which to copy the data.
     */
    Matrix.prototype.copyFrom = function (sourceMatrix) {
        this.a = sourceMatrix.a;
        this.b = sourceMatrix.b;
        this.c = sourceMatrix.c;
        this.d = sourceMatrix.d;
        this.tx = sourceMatrix.tx;
        this.ty = sourceMatrix.ty;
    };
    /**
     * Copies a Vector3D object into specific row of the calling Matrix object.
     *
     * @param row      The row from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyRowFrom = function (row, vector3D) {
        if (row > 2) {
            throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
        }
        else if (row == 0) {
            this.a = vector3D.x;
            this.c = vector3D.y;
        }
        else if (row == 1) {
            this.b = vector3D.x;
            this.d = vector3D.y;
        }
        else {
            this.tx = vector3D.x;
            this.ty = vector3D.y;
        }
    };
    /**
     * Copies specific row of the calling Matrix object into the Vector3D object.
     * The w element of the Vector3D object will not be changed.
     *
     * @param row      The row from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyRowTo = function (row, vector3D) {
        if (row > 2) {
            throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
        }
        else if (row == 0) {
            vector3D.x = this.a;
            vector3D.y = this.b;
            vector3D.z = this.tx;
        }
        else if (row == 1) {
            vector3D.x = this.c;
            vector3D.y = this.d;
            vector3D.z = this.ty;
        }
        else {
            vector3D.setTo(0, 0, 1);
        }
    };
    /**
     * Includes parameters for scaling, rotation, and translation. When applied
     * to a matrix it sets the matrix's values based on those parameters.
     *
     * <p>Using the <code>createBox()</code> method lets you obtain the same
     * matrix as you would if you applied the <code>identity()</code>,
     * <code>rotate()</code>, <code>scale()</code>, and <code>translate()</code>
     * methods in succession. For example, <code>mat1.createBox(2,2,Math.PI/4,
     * 100, 100)</code> has the same effect as the following:</p>
     *
     * @param scaleX   The factor by which to scale horizontally.
     * @param scaleY   The factor by which scale vertically.
     * @param rotation The amount to rotate, in radians.
     * @param tx       The number of pixels to translate(move) to the right
     *                 along the <i>x</i> axis.
     * @param ty       The number of pixels to translate(move) down along the
     *                 <i>y</i> axis.
     */
    Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = scaleX;
        this.d = scaleY;
        this.b = rotation;
        this.tx = tx;
        this.ty = ty;
    };
    /**
     * Creates the specific style of matrix expected by the
     * <code>beginGradientFill()</code> and <code>lineGradientStyle()</code>
     * methods of the Graphics class. Width and height are scaled to a
     * <code>scaleX</code>/<code>scaleY</code> pair and the
     * <code>tx</code>/<code>ty</code> values are offset by half the width and
     * height.
     *
     * <p>For example, consider a gradient with the following
     * characteristics:</p>
     *
     * <ul>
     *   <li><code>GradientType.LINEAR</code></li>
     *   <li>Two colors, green and blue, with the ratios array set to <code>[0,
     * 255]</code></li>
     *   <li><code>SpreadMethod.PAD</code></li>
     *   <li><code>InterpolationMethod.LINEAR_RGB</code></li>
     * </ul>
     *
     * <p>The following illustrations show gradients in which the matrix was
     * defined using the <code>createGradientBox()</code> method with different
     * parameter settings:</p>
     *
     * @param width    The width of the gradient box.
     * @param height   The height of the gradient box.
     * @param rotation The amount to rotate, in radians.
     * @param tx       The distance, in pixels, to translate to the right along
     *                 the <i>x</i> axis. This value is offset by half of the
     *                 <code>width</code> parameter.
     * @param ty       The distance, in pixels, to translate down along the
     *                 <i>y</i> axis. This value is offset by half of the
     *                 <code>height</code> parameter.
     */
    Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = width / 1638.4;
        this.d = height / 1638.4;
        if (rotation != 0.0) {
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);
            this.b = sin * this.d;
            this.c = -sin * this.a;
            this.a *= cos;
            this.d *= cos;
        }
        else {
            this.b = this.c = 0;
        }
        this.tx = tx + width / 2;
        this.ty = ty + height / 2;
    };
    /**
     * Given a point in the pretransform coordinate space, returns the
     * coordinates of that point after the transformation occurs. Unlike the
     * standard transformation applied using the <code>transformPoint()</code>
     * method, the <code>deltaTransformPoint()</code> method's transformation
     * does not consider the translation parameters <code>tx</code> and
     * <code>ty</code>.
     *
     * @param point The point for which you want to get the result of the matrix
     *              transformation.
     * @return The point resulting from applying the matrix transformation.
     */
    Matrix.prototype.deltaTransformPoint = function (point) {
        return new Point(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
    };
    /**
     * Sets each matrix property to a value that causes a null transformation. An
     * object transformed by applying an identity matrix will be identical to the
     * original.
     *
     * <p>After calling the <code>identity()</code> method, the resulting matrix
     * has the following properties: <code>a</code>=1, <code>b</code>=0,
     * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
     * <code>ty</code>=0.</p>
     *
     * <p>In matrix notation, the identity matrix looks like this:</p>
     *
     */
    Matrix.prototype.identity = function () {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
    };
    /**
     * Performs the opposite transformation of the original matrix. You can apply
     * an inverted matrix to an object to undo the transformation performed when
     * applying the original matrix.
     */
    Matrix.prototype.invert = function () {
        var norm = this.a * this.d - this.b * this.c;
        if (norm == 0) {
            this.a = this.b = this.c = this.d = 0;
            this.tx = -this.tx;
            this.ty = -this.ty;
        }
        else {
            norm = 1.0 / norm;
            var a1 = this.d * norm;
            this.d = this.a * norm;
            this.a = a1;
            this.b *= -norm;
            this.c *= -norm;
            var tx1 = -this.a * this.tx - this.c * this.ty;
            this.ty = -this.b * this.tx - this.d * this.ty;
            this.tx = tx1;
        }
    };
    /**
     * Returns a new Matrix object that is a clone of this matrix, with an exact
     * copy of the contained object.
     *
     * @param matrix The matrix for which you want to get the result of the matrix
     *               transformation.
     * @return A Matrix object.
     */
    Matrix.prototype.multiply = function (matrix) {
        var result = new Matrix();
        result.a = this.a * matrix.a + this.b * matrix.c;
        result.b = this.a * matrix.b + this.b * matrix.d;
        result.c = this.c * matrix.a + this.d * matrix.c;
        result.d = this.c * matrix.b + this.d * matrix.d;
        result.tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
        result.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
        return result;
    };
    /**
     * Applies a rotation transformation to the Matrix object.
     *
     * <p>The <code>rotate()</code> method alters the <code>a</code>,
     * <code>b</code>, <code>c</code>, and <code>d</code> properties of the
     * Matrix object. In matrix notation, this is the same as concatenating the
     * current matrix with the following:</p>
     *
     * @param angle The rotation angle in radians.
     */
    Matrix.prototype.rotate = function (angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a * cos - this.b * sin;
        this.b = this.a * sin + this.b * cos;
        this.a = a1;
        var c1 = this.c * cos - this.d * sin;
        this.d = this.c * sin + this.d * cos;
        this.c = c1;
        var tx1 = this.tx * cos - this.ty * sin;
        this.ty = this.tx * sin + this.ty * cos;
        this.tx = tx1;
    };
    /**
     * Applies a scaling transformation to the matrix. The <i>x</i> axis is
     * multiplied by <code>sx</code>, and the <i>y</i> axis it is multiplied by
     * <code>sy</code>.
     *
     * <p>The <code>scale()</code> method alters the <code>a</code> and
     * <code>d</code> properties of the Matrix object. In matrix notation, this
     * is the same as concatenating the current matrix with the following
     * matrix:</p>
     *
     * @param sx A multiplier used to scale the object along the <i>x</i> axis.
     * @param sy A multiplier used to scale the object along the <i>y</i> axis.
     */
    Matrix.prototype.scale = function (sx, sy) {
        this.a *= sx;
        this.b *= sy;
        this.c *= sx;
        this.d *= sy;
        this.tx *= sx;
        this.ty *= sy;
    };
    /**
     * Sets the members of Matrix to the specified values.
     *
     * @param a  The value that affects the positioning of pixels along the
     *           <i>x</i> axis when scaling or rotating an image.
     * @param b  The value that affects the positioning of pixels along the
     *           <i>y</i> axis when rotating or skewing an image.
     * @param c  The value that affects the positioning of pixels along the
     *           <i>x</i> axis when rotating or skewing an image.
     * @param d  The value that affects the positioning of pixels along the
     *           <i>y</i> axis when scaling or rotating an image..
     * @param tx The distance by which to translate each point along the <i>x</i>
     *           axis.
     * @param ty The distance by which to translate each point along the <i>y</i>
     *           axis.
     */
    Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    };
    /**
     * Returns a text value listing the properties of the Matrix object.
     *
     * @return A string containing the values of the properties of the Matrix
     *         object: <code>a</code>, <code>b</code>, <code>c</code>,
     *         <code>d</code>, <code>tx</code>, and <code>ty</code>.
     */
    Matrix.prototype.toString = function () {
        return "[Matrix] (a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
    };
    /**
     * Returns the result of applying the geometric transformation represented by
     * the Matrix object to the specified point.
     *
     * @param point The point for which you want to get the result of the Matrix
     *              transformation.
     * @return The point resulting from applying the Matrix transformation.
     */
    Matrix.prototype.transformPoint = function (point) {
        return new Point(point.x * this.a + point.y * this.c + this.tx, point.x * this.b + point.y * this.d + this.ty);
    };
    /**
     * Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified
     * by the <code>dx</code> and <code>dy</code> parameters.
     *
     * @param dx The amount of movement along the <i>x</i> axis to the right, in
     *           pixels.
     * @param dy The amount of movement down along the <i>y</i> axis, in pixels.
     */
    Matrix.prototype.translate = function (dx, dy) {
        this.tx += dx;
        this.ty += dy;
    };
    return Matrix;
})();
module.exports = Matrix;


},{"awayjs-core/lib/errors/ArgumentError":4,"awayjs-core/lib/geom/Point":17}],17:[function(require,module,exports){
/**
 * The Point object represents a location in a two-dimensional coordinate
 * system, where <i>x</i> represents the horizontal axis and <i>y</i>
 * represents the vertical axis.
 *
 * <p>The following code creates a point at(0,0):</p>
 *
 * <p>Methods and properties of the following classes use Point objects:</p>
 *
 * <ul>
 *   <li>BitmapData</li>
 *   <li>DisplayObject</li>
 *   <li>DisplayObjectContainer</li>
 *   <li>DisplacementMapFilter</li>
 *   <li>NativeWindow</li>
 *   <li>Matrix</li>
 *   <li>Rectangle</li>
 * </ul>
 *
 * <p>You can use the <code>new Point()</code> constructor to create a Point
 * object.</p>
 */
var Point = (function () {
    /**
     * Creates a new point. If you pass no parameters to this method, a point is
     * created at(0,0).
     *
     * @param x The horizontal coordinate.
     * @param y The vertical coordinate.
     */
    function Point(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x;
        this.y = y;
    }
    Object.defineProperty(Point.prototype, "length", {
        /**
         * The length of the line segment from(0,0) to this point.
         */
        get: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the coordinates of another point to the coordinates of this point to
     * create a new point.
     *
     * @param v The point to be added.
     * @return The new point.
     */
    Point.prototype.add = function (v) {
        return new Point(this.x + v.x, this.y + v.y);
    };
    /**
     * Creates a copy of this Point object.
     *
     * @return The new Point object.
     */
    Point.prototype.clone = function () {
        return new Point(this.x, this.y);
    };
    Point.prototype.copyFrom = function (sourcePoint) {
    };
    /**
     * Determines whether two points are equal. Two points are equal if they have
     * the same <i>x</i> and <i>y</i> values.
     *
     * @param toCompare The point to be compared.
     * @return A value of <code>true</code> if the object is equal to this Point
     *         object; <code>false</code> if it is not equal.
     */
    Point.prototype.equals = function (toCompare) {
        return (this.x == toCompare.x && this.y == toCompare.y);
    };
    /**
     * Scales the line segment between(0,0) and the current point to a set
     * length.
     *
     * @param thickness The scaling value. For example, if the current point is
     *                 (0,5), and you normalize it to 1, the point returned is
     *                  at(0,1).
     */
    Point.prototype.normalize = function (thickness) {
        if (thickness === void 0) { thickness = 1; }
        if (this.length != 0) {
            var invLength = thickness / this.length;
            this.x *= invLength;
            this.y *= invLength;
            return;
        }
        throw "Cannot divide by zero length.";
    };
    /**
     * Offsets the Point object by the specified amount. The value of
     * <code>dx</code> is added to the original value of <i>x</i> to create the
     * new <i>x</i> value. The value of <code>dy</code> is added to the original
     * value of <i>y</i> to create the new <i>y</i> value.
     *
     * @param dx The amount by which to offset the horizontal coordinate,
     *           <i>x</i>.
     * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
     */
    Point.prototype.offset = function (dx, dy) {
        this.x += dx;
        this.y += dy;
    };
    Point.prototype.setTo = function (xa, ya) {
    };
    /**
     * Subtracts the coordinates of another point from the coordinates of this
     * point to create a new point.
     *
     * @param v The point to be subtracted.
     * @return The new point.
     */
    Point.prototype.subtract = function (v) {
        return new Point(this.x - v.x, this.y - v.y);
    };
    /**
     * Returns a string that contains the values of the <i>x</i> and <i>y</i>
     * coordinates. The string has the form <code>"(x=<i>x</i>,
     * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
     * point at 23,17 would return <code>"(x=23, y=17)"</code>.
     *
     * @return The string representation of the coordinates.
     */
    Point.prototype.toString = function () {
        return "[Point] (x=" + this.x + ", y=" + this.y + ")";
    };
    /**
     * Returns the distance between <code>pt1</code> and <code>pt2</code>.
     *
     * @param pt1 The first point.
     * @param pt2 The second point.
     * @return The distance between the first and second points.
     */
    Point.distance = function (pt1, pt2) {
        var dx = pt2.x - pt1.x;
        var dy = pt2.y - pt1.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    /**
     * Determines a point between two specified points. The parameter
     * <code>f</code> determines where the new interpolated point is located
     * relative to the two end points specified by parameters <code>pt1</code>
     * and <code>pt2</code>. The closer the value of the parameter <code>f</code>
     * is to <code>1.0</code>, the closer the interpolated point is to the first
     * point(parameter <code>pt1</code>). The closer the value of the parameter
     * <code>f</code> is to 0, the closer the interpolated point is to the second
     * point(parameter <code>pt2</code>).
     *
     * @param pt1 The first point.
     * @param pt2 The second point.
     * @param f   The level of interpolation between the two points. Indicates
     *            where the new point will be, along the line between
     *            <code>pt1</code> and <code>pt2</code>. If <code>f</code>=1,
     *            <code>pt1</code> is returned; if <code>f</code>=0,
     *            <code>pt2</code> is returned.
     * @return The new, interpolated point.
     */
    Point.interpolate = function (pt1, pt2, f) {
        return new Point(pt2.x + (pt1.x - pt2.x) * f, pt2.y + (pt1.y - pt2.y) * f);
    };
    /**
     * Converts a pair of polar coordinates to a Cartesian point coordinate.
     *
     * @param len   The length coordinate of the polar pair.
     * @param angle The angle, in radians, of the polar pair.
     * @return The Cartesian point.
     */
    Point.polar = function (len, angle) {
        return new Point(len * Math.cos(angle), len * Math.sin(angle));
    };
    return Point;
})();
module.exports = Point;


},{}],18:[function(require,module,exports){
var Point = require("awayjs-core/lib/geom/Point");
/**
 * A Rectangle object is an area defined by its position, as indicated by its
 * top-left corner point(<i>x</i>, <i>y</i>) and by its width and its height.
 *
 *
 * <p>The <code>x</code>, <code>y</code>, <code>width</code>, and
 * <code>height</code> properties of the Rectangle class are independent of
 * each other; changing the value of one property has no effect on the others.
 * However, the <code>right</code> and <code>bottom</code> properties are
 * integrally related to those four properties. For example, if you change the
 * value of the <code>right</code> property, the value of the
 * <code>width</code> property changes; if you change the <code>bottom</code>
 * property, the value of the <code>height</code> property changes. </p>
 *
 * <p>The following methods and properties use Rectangle objects:</p>
 *
 * <ul>
 *   <li>The <code>applyFilter()</code>, <code>colorTransform()</code>,
 * <code>copyChannel()</code>, <code>copyPixels()</code>, <code>draw()</code>,
 * <code>fillRect()</code>, <code>generateFilterRect()</code>,
 * <code>getColorBoundsRect()</code>, <code>getPixels()</code>,
 * <code>merge()</code>, <code>paletteMap()</code>,
 * <code>pixelDisolve()</code>, <code>setPixels()</code>, and
 * <code>threshold()</code> methods, and the <code>rect</code> property of the
 * BitmapData class</li>
 *   <li>The <code>getBounds()</code> and <code>getRect()</code> methods, and
 * the <code>scrollRect</code> and <code>scale9Grid</code> properties of the
 * DisplayObject class</li>
 *   <li>The <code>getCharBoundaries()</code> method of the TextField
 * class</li>
 *   <li>The <code>pixelBounds</code> property of the Transform class</li>
 *   <li>The <code>bounds</code> parameter for the <code>startDrag()</code>
 * method of the Sprite class</li>
 *   <li>The <code>printArea</code> parameter of the <code>addPage()</code>
 * method of the PrintJob class</li>
 * </ul>
 *
 * <p>You can use the <code>new Rectangle()</code> constructor to create a
 * Rectangle object.</p>
 *
 * <p><b>Note:</b> The Rectangle class does not define a rectangular Shape
 * display object. To draw a rectangular Shape object onscreen, use the
 * <code>drawRect()</code> method of the Graphics class.</p>
 */
var Rectangle = (function () {
    /**
     * Creates a new Rectangle object with the top-left corner specified by the
     * <code>x</code> and <code>y</code> parameters and with the specified
     * <code>width</code> and <code>height</code> parameters. If you call this
     * public without parameters, a rectangle with <code>x</code>,
     * <code>y</code>, <code>width</code>, and <code>height</code> properties set
     * to 0 is created.
     *
     * @param x      The <i>x</i> coordinate of the top-left corner of the
     *               rectangle.
     * @param y      The <i>y</i> coordinate of the top-left corner of the
     *               rectangle.
     * @param width  The width of the rectangle, in pixels.
     * @param height The height of the rectangle, in pixels.
     */
    function Rectangle(x, y, width, height) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    Object.defineProperty(Rectangle.prototype, "bottom", {
        /**
         * The sum of the <code>y</code> and <code>height</code> properties.
         */
        get: function () {
            return this.y + this.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "bottomRight", {
        /**
         * The location of the Rectangle object's bottom-right corner, determined by
         * the values of the <code>right</code> and <code>bottom</code> properties.
         */
        get: function () {
            if (this._bottomRight == null)
                this._bottomRight = new Point();
            this._bottomRight.x = this.x + this.width;
            this._bottomRight.y = this.y + this.height;
            return this._bottomRight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "left", {
        /**
         * The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
         * the <code>left</code> property of a Rectangle object has no effect on the
         * <code>y</code> and <code>height</code> properties. However it does affect
         * the <code>width</code> property, whereas changing the <code>x</code> value
         * does <i>not</i> affect the <code>width</code> property.
         *
         * <p>The value of the <code>left</code> property is equal to the value of
         * the <code>x</code> property.</p>
         */
        get: function () {
            return this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "right", {
        /**
         * The sum of the <code>x</code> and <code>width</code> properties.
         */
        get: function () {
            return this.x + this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "size", {
        /**
         * The size of the Rectangle object, expressed as a Point object with the
         * values of the <code>width</code> and <code>height</code> properties.
         */
        get: function () {
            if (this._size == null)
                this._size = new Point();
            this._size.x = this.width;
            this._size.y = this.height;
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "top", {
        /**
         * The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
         * the <code>top</code> property of a Rectangle object has no effect on the
         * <code>x</code> and <code>width</code> properties. However it does affect
         * the <code>height</code> property, whereas changing the <code>y</code>
         * value does <i>not</i> affect the <code>height</code> property.
         *
         * <p>The value of the <code>top</code> property is equal to the value of the
         * <code>y</code> property.</p>
         */
        get: function () {
            return this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "topLeft", {
        /**
         * The location of the Rectangle object's top-left corner, determined by the
         * <i>x</i> and <i>y</i> coordinates of the point.
         */
        get: function () {
            if (this._topLeft == null)
                this._topLeft = new Point();
            this._topLeft.x = this.x;
            this._topLeft.y = this.y;
            return this._topLeft;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new Rectangle object with the same values for the
     * <code>x</code>, <code>y</code>, <code>width</code>, and
     * <code>height</code> properties as the original Rectangle object.
     *
     * @return A new Rectangle object with the same values for the
     *         <code>x</code>, <code>y</code>, <code>width</code>, and
     *         <code>height</code> properties as the original Rectangle object.
     */
    Rectangle.prototype.clone = function () {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };
    /**
     * Determines whether the specified point is contained within the rectangular
     * region defined by this Rectangle object.
     *
     * @param x The <i>x</i> coordinate(horizontal position) of the point.
     * @param y The <i>y</i> coordinate(vertical position) of the point.
     * @return A value of <code>true</code> if the Rectangle object contains the
     *         specified point; otherwise <code>false</code>.
     */
    Rectangle.prototype.contains = function (x, y) {
        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y);
    };
    /**
     * Determines whether the specified point is contained within the rectangular
     * region defined by this Rectangle object. This method is similar to the
     * <code>Rectangle.contains()</code> method, except that it takes a Point
     * object as a parameter.
     *
     * @param point The point, as represented by its <i>x</i> and <i>y</i>
     *              coordinates.
     * @return A value of <code>true</code> if the Rectangle object contains the
     *         specified point; otherwise <code>false</code>.
     */
    Rectangle.prototype.containsPoint = function (point) {
        return (this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y);
    };
    /**
     * Determines whether the Rectangle object specified by the <code>rect</code>
     * parameter is contained within this Rectangle object. A Rectangle object is
     * said to contain another if the second Rectangle object falls entirely
     * within the boundaries of the first.
     *
     * @param rect The Rectangle object being checked.
     * @return A value of <code>true</code> if the Rectangle object that you
     *         specify is contained by this Rectangle object; otherwise
     *         <code>false</code>.
     */
    Rectangle.prototype.containsRect = function (rect) {
        return (this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height);
    };
    /**
     * Copies all of rectangle data from the source Rectangle object into the
     * calling Rectangle object.
     *
     * @param sourceRect The Rectangle object from which to copy the data.
     */
    Rectangle.prototype.copyFrom = function (sourceRect) {
    };
    /**
     * Determines whether the object specified in the <code>toCompare</code>
     * parameter is equal to this Rectangle object. This method compares the
     * <code>x</code>, <code>y</code>, <code>width</code>, and
     * <code>height</code> properties of an object against the same properties of
     * this Rectangle object.
     *
     * @param toCompare The rectangle to compare to this Rectangle object.
     * @return A value of <code>true</code> if the object has exactly the same
     *         values for the <code>x</code>, <code>y</code>, <code>width</code>,
     *         and <code>height</code> properties as this Rectangle object;
     *         otherwise <code>false</code>.
     */
    Rectangle.prototype.equals = function (toCompare) {
        return (this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width && this.height == toCompare.height);
    };
    /**
     * Increases the size of the Rectangle object by the specified amounts, in
     * pixels. The center point of the Rectangle object stays the same, and its
     * size increases to the left and right by the <code>dx</code> value, and to
     * the top and the bottom by the <code>dy</code> value.
     *
     * @param dx The value to be added to the left and the right of the Rectangle
     *           object. The following equation is used to calculate the new
     *           width and position of the rectangle:
     * @param dy The value to be added to the top and the bottom of the
     *           Rectangle. The following equation is used to calculate the new
     *           height and position of the rectangle:
     */
    Rectangle.prototype.inflate = function (dx, dy) {
        this.x -= dx / 2;
        this.y -= dy / 2;
        this.width += dx / 2;
        this.height += dy / 2;
    };
    /**
     * Increases the size of the Rectangle object. This method is similar to the
     * <code>Rectangle.inflate()</code> method except it takes a Point object as
     * a parameter.
     *
     * <p>The following two code examples give the same result:</p>
     *
     * @param point The <code>x</code> property of this Point object is used to
     *              increase the horizontal dimension of the Rectangle object.
     *              The <code>y</code> property is used to increase the vertical
     *              dimension of the Rectangle object.
     */
    Rectangle.prototype.inflatePoint = function (point) {
        this.x -= point.x / 2;
        this.y -= point.y / 2;
        this.width += point.x / 2;
        this.height += point.y / 2;
    };
    /**
     * If the Rectangle object specified in the <code>toIntersect</code>
     * parameter intersects with this Rectangle object, returns the area of
     * intersection as a Rectangle object. If the rectangles do not intersect,
     * this method returns an empty Rectangle object with its properties set to
     * 0.
     *
     * @param toIntersect The Rectangle object to compare against to see if it
     *                    intersects with this Rectangle object.
     * @return A Rectangle object that equals the area of intersection. If the
     *         rectangles do not intersect, this method returns an empty
     *         Rectangle object; that is, a rectangle with its <code>x</code>,
     *         <code>y</code>, <code>width</code>, and <code>height</code>
     *         properties set to 0.
     */
    Rectangle.prototype.intersection = function (toIntersect) {
        if (this.intersects(toIntersect)) {
            var i = new Rectangle();
            if (this.x > toIntersect.x) {
                i.x = this.x;
                i.width = toIntersect.x - this.x + toIntersect.width;
                if (i.width > this.width)
                    i.width = this.width;
            }
            else {
                i.x = toIntersect.x;
                i.width = this.x - toIntersect.x + this.width;
                if (i.width > toIntersect.width)
                    i.width = toIntersect.width;
            }
            if (this.y > toIntersect.y) {
                i.y = this.y;
                i.height = toIntersect.y - this.y + toIntersect.height;
                if (i.height > this.height)
                    i.height = this.height;
            }
            else {
                i.y = toIntersect.y;
                i.height = this.y - toIntersect.y + this.height;
                if (i.height > toIntersect.height)
                    i.height = toIntersect.height;
            }
            return i;
        }
        return new Rectangle();
    };
    /**
     * Determines whether the object specified in the <code>toIntersect</code>
     * parameter intersects with this Rectangle object. This method checks the
     * <code>x</code>, <code>y</code>, <code>width</code>, and
     * <code>height</code> properties of the specified Rectangle object to see if
     * it intersects with this Rectangle object.
     *
     * @param toIntersect The Rectangle object to compare against this Rectangle
     *                    object.
     * @return A value of <code>true</code> if the specified object intersects
     *         with this Rectangle object; otherwise <code>false</code>.
     */
    Rectangle.prototype.intersects = function (toIntersect) {
        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height);
    };
    /**
     * Determines whether or not this Rectangle object is empty.
     *
     * @return A value of <code>true</code> if the Rectangle object's width or
     *         height is less than or equal to 0; otherwise <code>false</code>.
     */
    Rectangle.prototype.isEmpty = function () {
        return (this.x == 0 && this.y == 0 && this.width == 0 && this.height == 0);
    };
    /**
     * Adjusts the location of the Rectangle object, as determined by its
     * top-left corner, by the specified amounts.
     *
     * @param dx Moves the <i>x</i> value of the Rectangle object by this amount.
     * @param dy Moves the <i>y</i> value of the Rectangle object by this amount.
     */
    Rectangle.prototype.offset = function (dx, dy) {
        this.x += dx;
        this.y += dy;
    };
    /**
     * Adjusts the location of the Rectangle object using a Point object as a
     * parameter. This method is similar to the <code>Rectangle.offset()</code>
     * method, except that it takes a Point object as a parameter.
     *
     * @param point A Point object to use to offset this Rectangle object.
     */
    Rectangle.prototype.offsetPoint = function (point) {
        this.x += point.x;
        this.y += point.y;
    };
    /**
     * Sets all of the Rectangle object's properties to 0. A Rectangle object is
     * empty if its width or height is less than or equal to 0.
     *
     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
     * <code>width</code>, and <code>height</code> properties to 0.</p>
     *
     */
    Rectangle.prototype.setEmpty = function () {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    };
    /**
     * Sets the members of Rectangle to the specified values
     *
     * @param xa      The <i>x</i> coordinate of the top-left corner of the
     *                rectangle.
     * @param ya      The <i>y</i> coordinate of the top-left corner of the
     *                rectangle.
     * @param widtha  The width of the rectangle, in pixels.
     * @param heighta The height of the rectangle, in pixels.
     */
    Rectangle.prototype.setTo = function (xa, ya, widtha, heighta) {
        this.x = xa;
        this.y = ya;
        this.width = widtha;
        this.height = heighta;
    };
    /**
     * Builds and returns a string that lists the horizontal and vertical
     * positions and the width and height of the Rectangle object.
     *
     * @return A string listing the value of each of the following properties of
     *         the Rectangle object: <code>x</code>, <code>y</code>,
     *         <code>width</code>, and <code>height</code>.
     */
    Rectangle.prototype.toString = function () {
        return "[Rectangle] (x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
    };
    /**
     * Adds two rectangles together to create a new Rectangle object, by filling
     * in the horizontal and vertical space between the two rectangles.
     *
     * <p><b>Note:</b> The <code>union()</code> method ignores rectangles with
     * <code>0</code> as the height or width value, such as: <code>var
     * rect2:Rectangle = new Rectangle(300,300,50,0);</code></p>
     *
     * @param toUnion A Rectangle object to add to this Rectangle object.
     * @return A new Rectangle object that is the union of the two rectangles.
     */
    Rectangle.prototype.union = function (toUnion) {
        var u = new Rectangle();
        if (this.x < toUnion.x) {
            u.x = this.x;
            u.width = toUnion.x - this.x + toUnion.width;
            if (u.width < this.width)
                u.width = this.width;
        }
        else {
            u.x = toUnion.x;
            u.width = this.x - toUnion.x + this.width;
            if (u.width < toUnion.width)
                u.width = toUnion.width;
        }
        if (this.y < toUnion.y) {
            u.y = this.y;
            u.height = toUnion.y - this.y + toUnion.height;
            if (u.height < this.height)
                u.height = this.height;
        }
        else {
            u.y = toUnion.y;
            u.height = this.y - toUnion.y + this.height;
            if (u.height < toUnion.height)
                u.height = toUnion.height;
        }
        return u;
    };
    return Rectangle;
})();
module.exports = Rectangle;


},{"awayjs-core/lib/geom/Point":17}],19:[function(require,module,exports){
/**
 * The Vector3D class represents a point or a location in the three-dimensional
 * space using the Cartesian coordinates x, y, and z. As in a two-dimensional
 * space, the x property represents the horizontal axis and the y property
 * represents the vertical axis. In three-dimensional space, the z property
 * represents depth. The value of the x property increases as the object moves
 * to the right. The value of the y property increases as the object moves
 * down. The z property increases as the object moves farther from the point
 * of view. Using perspective projection and scaling, the object is seen to be
 * bigger when near and smaller when farther away from the screen. As in a
 * right-handed three-dimensional coordinate system, the positive z-axis points
 * away from the viewer and the value of the z property increases as the object
 * moves away from the viewer's eye. The origin point (0,0,0) of the global
 * space is the upper-left corner of the stage.
 *
 * <p>The Vector3D class can also represent a direction, an arrow pointing from
 * the origin of the coordinates, such as (0,0,0), to an endpoint; or a
 * floating-point component of an RGB (Red, Green, Blue) color model.</p>
 *
 * <p>Quaternion notation introduces a fourth element, the w property, which
 * provides additional orientation information. For example, the w property can
 * define an angle of rotation of a Vector3D object. The combination of the
 * angle of rotation and the coordinates x, y, and z can determine the display
 * object's orientation. Here is a representation of Vector3D elements in
 * matrix notation:</p>
 */
var Vector3D = (function () {
    /**
     * Creates an instance of a Vector3D object. If you do not specify a
     * parameter for the constructor, a Vector3D object is created with
     * the elements (0,0,0,0).
     *
     * @param x The first element, such as the x coordinate.
     * @param y The second element, such as the y coordinate.
     * @param z The third element, such as the z coordinate.
     * @param w An optional element for additional data such as the angle
     *          of rotation.
     */
    function Vector3D(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Object.defineProperty(Vector3D.prototype, "length", {
        /**
         * The length, magnitude, of the current Vector3D object from the
         * origin (0,0,0) to the object's x, y, and z coordinates. The w
         * property is ignored. A unit vector has a length or magnitude of
         * one.
         */
        get: function () {
            return Math.sqrt(this.lengthSquared);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector3D.prototype, "lengthSquared", {
        /**
         * The square of the length of the current Vector3D object, calculated
         * using the x, y, and z properties. The w property is ignored. Use the
         * <code>lengthSquared()</code> method whenever possible instead of the
         * slower <code>Math.sqrt()</code> method call of the
         * <code>Vector3D.length()</code> method.
         */
        get: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the value of the x, y, and z elements of the current Vector3D
     * object to the values of the x, y, and z elements of another Vector3D
     * object. The <code>add()</code> method does not change the current
     * Vector3D object. Instead, it returns a new Vector3D object with
     * the new values.
     *
     * <p>The result of adding two vectors together is a resultant vector.
     * One way to visualize the result is by drawing a vector from the
     * origin or tail of the first vector to the end or head of the second
     * vector. The resultant vector is the distance between the origin
     * point of the first vector and the end point of the second vector.
     * </p>
     */
    Vector3D.prototype.add = function (a) {
        return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
    };
    /**
     * Returns the angle in radians between two vectors. The returned angle
     * is the smallest radian the first Vector3D object rotates until it
     * aligns with the second Vector3D object.
     *
     * <p>The <code>angleBetween()</code> method is a static method. You
     * can use it directly as a method of the Vector3D class.</p>
     *
     * <p>To convert a degree to a radian, you can use the following
     * formula:</p>
     *
     * <p><code>radian = Math.PI/180 * degree</code></p>
     *
     * @param a The first Vector3D object.
     * @param b The second Vector3D object.
     * @returns The angle between two Vector3D objects.
     */
    Vector3D.angleBetween = function (a, b) {
        return Math.acos(a.dotProduct(b) / (a.length * b.length));
    };
    /**
     * Returns a new Vector3D object that is an exact copy of the current
     * Vector3D object.
     *
     * @returns A new Vector3D object that is a copy of the current
     * Vector3D object.
     */
    Vector3D.prototype.clone = function () {
        return new Vector3D(this.x, this.y, this.z, this.w);
    };
    /**
     * Copies all of vector data from the source Vector3D object into the
     * calling Vector3D object.
     *
     * @param src The Vector3D object from which to copy the data.
     */
    Vector3D.prototype.copyFrom = function (src) {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z;
        this.w = src.w;
    };
    /**
     * Returns a new Vector3D object that is perpendicular (at a right
     * angle) to the current Vector3D and another Vector3D object. If the
     * returned Vector3D object's coordinates are (0,0,0), then the two
     * Vector3D objects are parallel to each other.
     *
     * <p>You can use the normalized cross product of two vertices of a
     * polygon surface with the normalized vector of the camera or eye
     * viewpoint to get a dot product. The value of the dot product can
     * identify whether a surface of a three-dimensional object is hidden
     * from the viewpoint.</p>
     *
     * @param a A second Vector3D object.
     * @returns A new Vector3D object that is perpendicular to the current
     *          Vector3D object and the Vector3D object specified as the
     *          parameter.
     */
    Vector3D.prototype.crossProduct = function (a) {
        return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
    };
    /**
     * Decrements the value of the x, y, and z elements of the current
     * Vector3D object by the values of the x, y, and z elements of
     * specified Vector3D object. Unlike the
     * <code>Vector3D.subtract()</code> method, the
     * <code>decrementBy()</code> method changes the current Vector3D
     * object and does not return a new Vector3D object.
     *
     * @param a The Vector3D object containing the values to subtract from
     *          the current Vector3D object.
     */
    Vector3D.prototype.decrementBy = function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
    };
    /**
     * Returns the distance between two Vector3D objects. The
     * <code>distance()</code> method is a static method. You can use it
     * directly as a method of the Vector3D class to get the Euclidean
     * distance between two three-dimensional points.
     *
     * @param pt1 A Vector3D object as the first three-dimensional point.
     * @param pt2 A Vector3D object as the second three-dimensional point.
     * @returns The distance between two Vector3D objects.
     */
    Vector3D.distance = function (pt1, pt2) {
        var x = (pt1.x - pt2.x);
        var y = (pt1.y - pt2.y);
        var z = (pt1.z - pt2.z);
        return Math.sqrt(x * x + y * y + z * z);
    };
    /**
     * If the current Vector3D object and the one specified as the
     * parameter are unit vertices, this method returns the cosine of the
     * angle between the two vertices. Unit vertices are vertices that
     * point to the same direction but their length is one. They remove the
     * length of the vector as a factor in the result. You can use the
     * <code>normalize()</code> method to convert a vector to a unit
     * vector.
     *
     * <p>The <code>dotProduct()</code> method finds the angle between two
     * vertices. It is also used in backface culling or lighting
     * calculations. Backface culling is a procedure for determining which
     * surfaces are hidden from the viewpoint. You can use the normalized
     * vertices from the camera, or eye, viewpoint and the cross product of
     * the vertices of a polygon surface to get the dot product. If the dot
     * product is less than zero, then the surface is facing the camera or
     * the viewer. If the two unit vertices are perpendicular to each
     * other, they are orthogonal and the dot product is zero. If the two
     * vertices are parallel to each other, the dot product is one.</p>
     *
     * @param a The second Vector3D object.
     * @returns A scalar which is the dot product of the current Vector3D
     *          object and the specified Vector3D object.
     *
     * @see away.geom.Vector3D#crossProduct()
     * @see away.geom.Vector3D#normalize()
     */
    Vector3D.prototype.dotProduct = function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    };
    /**
     * Determines whether two Vector3D objects are equal by comparing the
     * x, y, and z elements of the current Vector3D object with a
     * specified Vector3D object. If the values of these elements are the
     * same, the two Vector3D objects are equal. If the second optional
     * parameter is set to true, all four elements of the Vector3D objects,
     * including the w property, are compared.
     */
    /**
     *
     * @param toCompare The Vector3D object to be compared with the current
     *                  Vector3D object.
     * @param allFour   An optional parameter that specifies whether the w
     *                  property of the Vector3D objects is used in the
     *                  comparison.
     * @returns A value of true if the specified Vector3D object is equal
     *          to the current Vector3D object; false if it is not equal.
     */
    Vector3D.prototype.equals = function (toCompare, allFour) {
        if (allFour === void 0) { allFour = false; }
        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
    };
    /**
     * Increments the value of the x, y, and z elements of the current
     * Vector3D object by the values of the x, y, and z elements of a
     * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
     * method, the <code>incrementBy()</code> method changes the current
     * Vector3D object and does not return a new Vector3D object.
     *
     * @param a The Vector3D object to be added to the current Vector3D
     *          object.
     */
    Vector3D.prototype.incrementBy = function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
    };
    /**
     * Compares the elements of the current Vector3D object with the
     * elements of a specified Vector3D object to determine whether they
     * are nearly equal. The two Vector3D objects are nearly equal if the
     * value of all the elements of the two vertices are equal, or the
     * result of the comparison is within the tolerance range. The
     * difference between two elements must be less than the number
     * specified as the tolerance parameter. If the third optional
     * parameter is set to <code>true</code>, all four elements of the
     * Vector3D objects, including the <code>w</code> property, are
     * compared. Otherwise, only the x, y, and z elements are included in
     * the comparison.
     */
    /**
     *
     * @param toCompare The Vector3D object to be compared with the current
     *                  Vector3D object.
     * @param tolerance A number determining the tolerance factor. If the
     *                  difference between the values of the Vector3D
     *                  element specified in the toCompare parameter and
     *                  the current Vector3D element is less than the
     *                  tolerance number, the two values are considered
     *                  nearly equal.
     * @param allFour   An optional parameter that specifies whether the w
     *                  property of the Vector3D objects is used in the
     *                  comparison.
     * @returns A value of true if the specified Vector3D object is nearly
     *          equal to the current Vector3D object; false if it is not
     *          equal.
     *
     * @see away.geom.Vector3D#equals()
     */
    Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
        if (allFour === void 0) { allFour = true; }
        return ((Math.abs(this.x - toCompare.x) < tolerance) && (Math.abs(this.y - toCompare.y) < tolerance) && (Math.abs(this.z - toCompare.z) < tolerance) && (!allFour || Math.abs(this.w - toCompare.w) < tolerance));
    };
    /**
     * Sets the current Vector3D object to its inverse. The inverse object
     * is also considered the opposite of the original object. The value of
     * the x, y, and z properties of the current Vector3D object is changed
     * to -x, -y, and -z.
     */
    Vector3D.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
    };
    /**
     * Converts a Vector3D object to a unit vector by dividing the first
     * three elements (x, y, z) by the length of the vector. Unit vertices
     * are vertices that have a direction but their length is one. They
     * simplify vector calculations by removing length as a factor.
     */
    /**
     * Scales the line segment between(0,0) and the current point to a set
     * length.
     *
     * @param thickness The scaling value. For example, if the current
     *                  Vector3D object is (0,3,4), and you normalize it to
     *                  1, the point returned is at(0,0.6,0.8).
     */
    Vector3D.prototype.normalize = function (thickness) {
        if (thickness === void 0) { thickness = 1; }
        if (this.length != 0) {
            var invLength = thickness / this.length;
            this.x *= invLength;
            this.y *= invLength;
            this.z *= invLength;
            return;
        }
    };
    /**
     * Divides the value of the <code>x</code>, <code>y</code>, and
     * <code>z</code> properties of the current Vector3D object by the
     * value of its <code>w</code> property.
     *
     * <p>If the current Vector3D object is the result of multiplying a
     * Vector3D object by a projection Matrix3D object, the w property can
     * hold the transform value. The <code>project()</code> method then can
     * complete the projection by dividing the elements by the
     * <code>w</code> property. Use the <code>Matrix3D.rawData</code>
     * property to create a projection Matrix3D object.</p>
     */
    Vector3D.prototype.project = function () {
        this.x /= this.w;
        this.y /= this.w;
        this.z /= this.w;
    };
    /**
     * Scales the current Vector3D object by a scalar, a magnitude. The
     * Vector3D object's x, y, and z elements are multiplied by the scalar
     * number specified in the parameter. For example, if the vector is
     * scaled by ten, the result is a vector that is ten times longer. The
     * scalar can also change the direction of the vector. Multiplying the
     * vector by a negative number reverses its direction.
     *
     * @param s A multiplier (scalar) used to scale a Vector3D object.

     */
    Vector3D.prototype.scaleBy = function (s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
    };
    /**
     * Sets the members of Vector3D to the specified values
     *
     * @param xa The first element, such as the x coordinate.
     * @param ya The second element, such as the y coordinate.
     * @param za The third element, such as the z coordinate.
     */
    Vector3D.prototype.setTo = function (xa, ya, za) {
        this.x = xa;
        this.y = ya;
        this.z = za;
    };
    /**
     * Subtracts the value of the x, y, and z elements of the current
     * Vector3D object from the values of the x, y, and z elements of
     * another Vector3D object. The <code>subtract()</code> method does not
     * change the current Vector3D object. Instead, this method returns a
     * new Vector3D object with the new values.
     *
     * @param a The Vector3D object to be subtracted from the current
     *          Vector3D object.
     * @returns A new Vector3D object that is the difference between the
     *          current Vector3D and the specified Vector3D object.
     *
     * @see away.geom.Vector3D#decrementBy()
     */
    Vector3D.prototype.subtract = function (a) {
        return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
    };
    /**
     * Returns a string representation of the current Vector3D object. The
     * string contains the values of the x, y, and z properties.
     */
    Vector3D.prototype.toString = function () {
        return "[Vector3D] (x:" + this.x + " ,y:" + this.y + ", z" + this.z + ", w:" + this.w + ")";
    };
    /**
     * The x axis defined as a Vector3D object with coordinates (1,0,0).
     */
    Vector3D.X_AXIS = new Vector3D(1, 0, 0);
    /**
     * The y axis defined as a Vector3D object with coordinates (0,1,0).
     */
    Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
    /**
     * The z axis defined as a Vector3D object with coordinates (0,0,1).
     */
    Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
    return Vector3D;
})();
module.exports = Vector3D;


},{}],20:[function(require,module,exports){
var AssetLibraryBundle = require("awayjs-core/lib/library/AssetLibraryBundle");
var AssetLoader = require("awayjs-core/lib/library/AssetLoader");
/**
 * AssetLibrary enforces a singleton pattern and is not intended to be instanced.
 * It's purpose is to allow access to the default library bundle through a set of static shortcut methods.
 * If you are interested in creating multiple library bundles, please use the <code>getBundle()</code> method.
 */
var AssetLibrary = (function () {
    /**
     * Creates a new <code>AssetLibrary</code> object.
     *
     */
    function AssetLibrary() {
    }
    //*/
    /**
     * Returns an AssetLibrary bundle instance. If no key is given, returns the default bundle (which is
     * similar to using the AssetLibraryBundle as a singleton). To keep several separated library bundles,
     * pass a string key to this method to define which bundle should be returned. This is
     * referred to as using the AssetLibraryBundle as a multiton.
     *
     * @param key Defines which multiton instance should be returned.
     * @return An instance of the asset library
     */
    AssetLibrary.getBundle = function (key) {
        if (key === void 0) { key = 'default'; }
        return AssetLibraryBundle.getInstance(key);
    };
    /**
     *
     */
    AssetLibrary.enableParser = function (parserClass) {
        AssetLoader.enableParser(parserClass);
    };
    /**
     *
     */
    AssetLibrary.enableParsers = function (parserClasses) {
        AssetLoader.enableParsers(parserClasses);
    };
    Object.defineProperty(AssetLibrary, "conflictStrategy", {
        /**
         * Short-hand for conflictStrategy property on default asset library bundle.
         *
         * @see AssetLibraryBundle.conflictStrategy
         */
        get: function () {
            return AssetLibrary.getBundle().conflictStrategy;
        },
        set: function (val) {
            AssetLibrary.getBundle().conflictStrategy = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetLibrary, "conflictPrecedence", {
        /**
         * Short-hand for conflictPrecedence property on default asset library bundle.
         *
         * @see AssetLibraryBundle.conflictPrecedence
         */
        get: function () {
            return AssetLibrary.getBundle().conflictPrecedence;
        },
        set: function (val) {
            AssetLibrary.getBundle().conflictPrecedence = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Short-hand for createIterator() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.createIterator()
     */
    AssetLibrary.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
        if (namespaceFilter === void 0) { namespaceFilter = null; }
        if (filterFunc === void 0) { filterFunc = null; }
        return AssetLibrary.getBundle().createIterator(assetTypeFilter, namespaceFilter, filterFunc);
    };
    /**
     * Short-hand for load() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.load()
     */
    AssetLibrary.load = function (req, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        return AssetLibrary.getBundle().load(req, context, ns, parser);
    };
    /**
     * Short-hand for loadData() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.loadData()
     */
    AssetLibrary.loadData = function (data, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        return AssetLibrary.getBundle().loadData(data, context, ns, parser);
    };
    AssetLibrary.stopLoad = function () {
        AssetLibrary.getBundle().stopAllLoadingSessions();
    };
    /**
     * Short-hand for getAsset() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.getAsset()
     */
    AssetLibrary.getAsset = function (name, ns) {
        if (ns === void 0) { ns = null; }
        return AssetLibrary.getBundle().getAsset(name, ns);
    };
    /**
     * Short-hand for addEventListener() method on default asset library bundle.
     */
    AssetLibrary.addEventListener = function (type, listener) {
        AssetLibrary.getBundle().addEventListener(type, listener);
    };
    /**
     * Short-hand for removeEventListener() method on default asset library bundle.
     */
    AssetLibrary.removeEventListener = function (type, listener) {
        AssetLibrary.getBundle().removeEventListener(type, listener);
    };
    /**
     * Short-hand for hasEventListener() method on default asset library bundle.

     public static hasEventListener(type:string):boolean
     {
        return AssetLibrary.getBundle().hasEventListener(type);
    }

     public static willTrigger(type:string):boolean
     {
        return getBundle().willTrigger(type);
    }
     */
    /**
     * Short-hand for addAsset() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.addAsset()
     */
    AssetLibrary.addAsset = function (asset) {
        AssetLibrary.getBundle().addAsset(asset);
    };
    /**
     * Short-hand for removeAsset() method on default asset library bundle.
     *
     * @param asset The asset which should be removed from the library.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see AssetLibraryBundle.removeAsset()
     */
    AssetLibrary.removeAsset = function (asset, dispose) {
        if (dispose === void 0) { dispose = true; }
        AssetLibrary.getBundle().removeAsset(asset, dispose);
    };
    /**
     * Short-hand for removeAssetByName() method on default asset library bundle.
     *
     * @param name The name of the asset to be removed.
     * @param ns The namespace to which the desired asset belongs.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see AssetLibraryBundle.removeAssetByName()
     */
    AssetLibrary.removeAssetByName = function (name, ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        return AssetLibrary.getBundle().removeAssetByName(name, ns, dispose);
    };
    /**
     * Short-hand for removeAllAssets() method on default asset library bundle.
     *
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see AssetLibraryBundle.removeAllAssets()
     */
    AssetLibrary.removeAllAssets = function (dispose) {
        if (dispose === void 0) { dispose = true; }
        AssetLibrary.getBundle().removeAllAssets(dispose);
    };
    /**
     * Short-hand for removeNamespaceAssets() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.removeNamespaceAssets()
     */
    AssetLibrary.removeNamespaceAssets = function (ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        AssetLibrary.getBundle().removeNamespaceAssets(ns, dispose);
    };
    return AssetLibrary;
})();
module.exports = AssetLibrary;


},{"awayjs-core/lib/library/AssetLibraryBundle":21,"awayjs-core/lib/library/AssetLoader":23}],21:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetLibraryIterator = require("awayjs-core/lib/library/AssetLibraryIterator");
var AssetLoader = require("awayjs-core/lib/library/AssetLoader");
var ConflictPrecedence = require("awayjs-core/lib/library/ConflictPrecedence");
var ConflictStrategy = require("awayjs-core/lib/library/ConflictStrategy");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var Error = require("awayjs-core/lib/errors/Error");
var AssetEvent = require("awayjs-core/lib/events/AssetEvent");
var IOErrorEvent = require("awayjs-core/lib/events/IOErrorEvent");
var LoaderEvent = require("awayjs-core/lib/events/LoaderEvent");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var ParserEvent = require("awayjs-core/lib/events/ParserEvent");
/**
 * AssetLibraryBundle enforces a multiton pattern and is not intended to be instanced directly.
 * Its purpose is to create a container for 3D data management, both before and after parsing.
 * If you are interested in creating multiple library bundles, please use the <code>getInstance()</code> method.
 */
var AssetLibraryBundle = (function (_super) {
    __extends(AssetLibraryBundle, _super);
    /**
     * Creates a new <code>AssetLibraryBundle</code> object.
     *
     * @param me A multiton enforcer for the AssetLibraryBundle ensuring it cannnot be instanced.
     */
    function AssetLibraryBundle() {
        var _this = this;
        _super.call(this);
        this._loadingSessionsGarbage = new Array();
        this._assets = new Array(); //new Vector.<IAsset>;
        this._assetDictionary = new Object();
        this._loadingSessions = new Array();
        this.conflictStrategy = ConflictStrategy.IGNORE.create();
        this.conflictPrecedence = ConflictPrecedence.FAVOR_NEW;
        this._onAssetRenameDelegate = function (event) { return _this.onAssetRename(event); };
        this._onAssetConflictResolvedDelegate = function (event) { return _this.onAssetConflictResolved(event); };
        this._onResourceCompleteDelegate = function (event) { return _this.onResourceComplete(event); };
        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
    }
    /**
     * Returns an AssetLibraryBundle instance. If no key is given, returns the default bundle instance (which is
     * similar to using the AssetLibraryBundle as a singleton.) To keep several separated library bundles,
     * pass a string key to this method to define which bundle should be returned. This is
     * referred to as using the AssetLibrary as a multiton.
     *
     * @param key Defines which multiton instance should be returned.
     * @return An instance of the asset library
     */
    AssetLibraryBundle.getInstance = function (key) {
        if (key === void 0) { key = 'default'; }
        if (!key)
            key = 'default';
        if (!AssetLibraryBundle._iInstances.hasOwnProperty(key))
            AssetLibraryBundle._iInstances[key] = new AssetLibraryBundle();
        return AssetLibraryBundle._iInstances[key];
    };
    /**
     *
     */
    AssetLibraryBundle.prototype.enableParser = function (parserClass) {
        AssetLoader.enableParser(parserClass);
    };
    /**
     *
     */
    AssetLibraryBundle.prototype.enableParsers = function (parserClasses) {
        AssetLoader.enableParsers(parserClasses);
    };
    Object.defineProperty(AssetLibraryBundle.prototype, "conflictStrategy", {
        /**
         * Defines which strategy should be used for resolving naming conflicts, when two library
         * assets are given the same name. By default, <code>ConflictStrategy.APPEND_NUM_SUFFIX</code>
         * is used which means that a numeric suffix is appended to one of the assets. The
         * <code>conflictPrecedence</code> property defines which of the two conflicting assets will
         * be renamed.
         *
         * @see naming.ConflictStrategy
         * @see AssetLibrary.conflictPrecedence
         */
        get: function () {
            return this._strategy;
        },
        set: function (val) {
            if (!val)
                throw new Error('namingStrategy must not be null. To ignore naming, use AssetLibrary.IGNORE');
            this._strategy = val.create();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetLibraryBundle.prototype, "conflictPrecedence", {
        /**
         * Defines which asset should have precedence when resolving a naming conflict between
         * two assets of which one has just been renamed by the user or by a parser. By default
         * <code>ConflictPrecedence.FAVOR_NEW</code> is used, meaning that the newly renamed
         * asset will keep it's new name while the older asset gets renamed to not conflict.
         *
         * This property is ignored for conflict strategies that do not actually rename an
         * asset automatically, such as ConflictStrategy.IGNORE and ConflictStrategy.THROW_ERROR.
         *
         * @see away.library.ConflictPrecedence
         * @see away.library.ConflictStrategy
         */
        get: function () {
            return this._strategyPreference;
        },
        set: function (val) {
            this._strategyPreference = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an AssetLibraryIterator instance that can be used to iterate over the assets
     * in this asset library instance. The iterator can filter assets on asset type and/or
     * namespace. A "null" filter value means no filter of that type is used.
     *
     * @param assetTypeFilter Asset type to filter on (from the AssetType enum class.) Use
     * null to not filter on asset type.
     * @param namespaceFilter Namespace to filter on. Use null to not filter on namespace.
     * @param filterFunc Callback function to use when deciding whether an asset should be
     * included in the iteration or not. This needs to be a function that takes a single
     * parameter of type IAsset and returns a boolean where true means it should be included.
     *
     * @see away.library.AssetType
     */
    AssetLibraryBundle.prototype.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
        if (namespaceFilter === void 0) { namespaceFilter = null; }
        if (filterFunc === void 0) { filterFunc = null; }
        return new AssetLibraryIterator(this._assets, assetTypeFilter, namespaceFilter, filterFunc);
    };
    /**
     * Loads a file and (optionally) all of its dependencies.
     *
     * @param req The URLRequest object containing the URL of the file to be loaded.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
     * @return A handle to the retrieved resource.
     */
    AssetLibraryBundle.prototype.load = function (req, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        var loader = new AssetLoader();
        if (!this._loadingSessions)
            this._loadingSessions = new Array();
        this._loadingSessions.push(loader);
        loader.addEventListener(LoaderEvent.RESOURCE_COMPLETE, this._onResourceCompleteDelegate);
        loader.addEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        loader.addEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        // Error are handled separately (see documentation for addErrorHandler)
        loader._iAddErrorHandler(this._onLoadErrorDelegate);
        loader._iAddParseErrorHandler(this._onParseErrorDelegate);
        return loader.load(req, context, ns, parser);
    };
    /**
     * Loads a resource from existing data in memory.
     *
     * @param data The data object containing all resource information.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
     * @return A handle to the retrieved resource.
     */
    AssetLibraryBundle.prototype.loadData = function (data, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        var loader = new AssetLoader();
        if (!this._loadingSessions)
            this._loadingSessions = new Array();
        this._loadingSessions.push(loader);
        loader.addEventListener(LoaderEvent.RESOURCE_COMPLETE, this._onResourceCompleteDelegate);
        loader.addEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        loader.addEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        // Error are handled separately (see documentation for addErrorHandler)
        loader._iAddErrorHandler(this._onLoadErrorDelegate);
        loader._iAddParseErrorHandler(this._onParseErrorDelegate);
        return loader.loadData(data, '', context, ns, parser);
    };
    /**
     *
     */
    AssetLibraryBundle.prototype.getAsset = function (name, ns) {
        //var asset : IAsset;
        if (ns === void 0) { ns = null; }
        if (this._assetDictDirty)
            this.rehashAssetDict();
        if (ns == null)
            ns = NamedAssetBase.DEFAULT_NAMESPACE;
        if (!this._assetDictionary.hasOwnProperty(ns))
            return null;
        return this._assetDictionary[ns][name];
    };
    /**
     * Adds an asset to the asset library, first making sure that it's name is unique
     * using the method defined by the <code>conflictStrategy</code> and
     * <code>conflictPrecedence</code> properties.
     */
    AssetLibraryBundle.prototype.addAsset = function (asset) {
        var ns;
        var old;
        // Bail if asset has already been added.
        if (this._assets.indexOf(asset) >= 0)
            return;
        old = this.getAsset(asset.name, asset.assetNamespace);
        ns = asset.assetNamespace || NamedAssetBase.DEFAULT_NAMESPACE;
        if (old != null)
            this._strategy.resolveConflict(asset, old, this._assetDictionary[ns], this._strategyPreference);
        //create unique-id (for now this is used in AwayBuilder only
        //asset.id = IDUtil.createUID();
        // Add it
        this._assets.push(asset);
        if (!this._assetDictionary.hasOwnProperty(ns))
            this._assetDictionary[ns] = new Object();
        this._assetDictionary[ns][asset.name] = asset;
        asset.addEventListener(AssetEvent.ASSET_RENAME, this._onAssetRenameDelegate);
        asset.addEventListener(AssetEvent.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
    };
    /**
     * Removes an asset from the library, and optionally disposes that asset by calling
     * it's disposeAsset() method (which for most assets is implemented as a default
     * version of that type's dispose() method.
     *
     * @param asset The asset which should be removed from this library.
     * @param dispose Defines whether the assets should also be disposed.
     */
    AssetLibraryBundle.prototype.removeAsset = function (asset, dispose) {
        if (dispose === void 0) { dispose = true; }
        var idx;
        this.removeAssetFromDict(asset);
        asset.removeEventListener(AssetEvent.ASSET_RENAME, this._onAssetRenameDelegate);
        asset.removeEventListener(AssetEvent.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
        idx = this._assets.indexOf(asset);
        if (idx >= 0)
            this._assets.splice(idx, 1);
        if (dispose)
            asset.dispose();
    };
    /**
     * Removes an asset which is specified using name and namespace.
     *
     * @param name The name of the asset to be removed.
     * @param ns The namespace to which the desired asset belongs.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see away.library.AssetLibrary.removeAsset()
     */
    AssetLibraryBundle.prototype.removeAssetByName = function (name, ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        var asset = this.getAsset(name, ns);
        if (asset)
            this.removeAsset(asset, dispose);
        return asset;
    };
    /**
     * Removes all assets from the asset library, optionally disposing them as they
     * are removed.
     *
     * @param dispose Defines whether the assets should also be disposed.
     */
    AssetLibraryBundle.prototype.removeAllAssets = function (dispose) {
        if (dispose === void 0) { dispose = true; }
        if (dispose) {
            var asset;
            for (var c = 0; c < this._assets.length; c++) {
                asset = this._assets[c];
                asset.dispose();
            }
        }
        this._assets.length = 0;
        this.rehashAssetDict();
    };
    /**
     * Removes all assets belonging to a particular namespace (null for default)
     * from the asset library, and optionall disposes them by calling their
     * disposeAsset() method.
     *
     * @param ns The namespace from which all assets should be removed.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see away.library.AssetLibrary.removeAsset()
     */
    AssetLibraryBundle.prototype.removeNamespaceAssets = function (ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        var idx = 0;
        var asset;
        var old_assets;
        // Empty the assets vector after having stored a copy of it.
        // The copy will be filled with all assets which weren't removed.
        old_assets = this._assets.concat();
        this._assets.length = 0;
        if (ns == null)
            ns = NamedAssetBase.DEFAULT_NAMESPACE;
        for (var d = 0; d < old_assets.length; d++) {
            asset = old_assets[d];
            // Remove from dict if in the supplied namespace. If not,
            // transfer over to the new vector.
            if (asset.assetNamespace == ns) {
                if (dispose)
                    asset.dispose();
                // Remove asset from dictionary, but don't try to auto-remove
                // the namespace, which will trigger an unnecessarily expensive
                // test that is not needed since we know that the namespace
                // will be empty when loop finishes.
                this.removeAssetFromDict(asset, false);
            }
            else {
                this._assets[idx++] = asset;
            }
        }
        /*
         for each (asset in old_assets) {
         // Remove from dict if in the supplied namespace. If not,
         // transfer over to the new vector.
         if (asset.assetNamespace == ns) {
         if (dispose)
         asset.dispose();

         // Remove asset from dictionary, but don't try to auto-remove
         // the namespace, which will trigger an unnecessarily expensive
         // test that is not needed since we know that the namespace
         // will be empty when loop finishes.
         removeAssetFromDict(asset, false);
         } else
         _assets[idx++] = asset;

         }
         */
        // Remove empty namespace
        if (this._assetDictionary.hasOwnProperty(ns))
            delete this._assetDictionary[ns];
    };
    AssetLibraryBundle.prototype.removeAssetFromDict = function (asset, autoRemoveEmptyNamespace) {
        if (autoRemoveEmptyNamespace === void 0) { autoRemoveEmptyNamespace = true; }
        if (this._assetDictDirty)
            this.rehashAssetDict();
        if (this._assetDictionary.hasOwnProperty(asset.assetNamespace)) {
            if (this._assetDictionary[asset.assetNamespace].hasOwnProperty(asset.name))
                delete this._assetDictionary[asset.assetNamespace][asset.name];
            if (autoRemoveEmptyNamespace) {
                var key;
                var empty = true;
                for (key in this._assetDictionary[asset.assetNamespace]) {
                    empty = false;
                    break;
                }
                if (empty)
                    delete this._assetDictionary[asset.assetNamespace];
            }
        }
    };
    AssetLibraryBundle.prototype.stopAllLoadingSessions = function () {
        var i;
        if (!this._loadingSessions)
            this._loadingSessions = new Array();
        var length = this._loadingSessions.length;
        for (i = 0; i < length; i++)
            this.killLoadingSession(this._loadingSessions[i]);
        this._loadingSessions = null;
    };
    AssetLibraryBundle.prototype.rehashAssetDict = function () {
        var asset;
        this._assetDictionary = {};
        var l = this._assets.length;
        for (var c = 0; c < l; c++) {
            asset = this._assets[c];
            if (!this._assetDictionary.hasOwnProperty(asset.assetNamespace))
                this._assetDictionary[asset.assetNamespace] = {};
            this._assetDictionary[asset.assetNamespace][asset.name] = asset;
        }
        this._assetDictDirty = false;
    };
    /**
     * Called when a an error occurs during loading.
     */
    AssetLibraryBundle.prototype.onLoadError = function (event) {
        if (this.hasEventListener(IOErrorEvent.IO_ERROR)) {
            this.dispatchEvent(event);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Called when a an error occurs during parsing.
     */
    AssetLibraryBundle.prototype.onParseError = function (event) {
        if (this.hasEventListener(ParserEvent.PARSE_ERROR)) {
            this.dispatchEvent(event);
            return true;
        }
        else {
            return false;
        }
    };
    AssetLibraryBundle.prototype.onAssetComplete = function (event) {
        // Only add asset to library the first time.
        if (event.type == AssetEvent.ASSET_COMPLETE)
            this.addAsset(event.asset);
        this.dispatchEvent(event);
    };
    AssetLibraryBundle.prototype.onTextureSizeError = function (event) {
        this.dispatchEvent(event);
    };
    /**
     * Called when the resource and all of its dependencies was retrieved.
     */
    AssetLibraryBundle.prototype.onResourceComplete = function (event) {
        var _this = this;
        var loader = event.target;
        this.dispatchEvent(event);
        var index = this._loadingSessions.indexOf(loader);
        this._loadingSessions.splice(index, 1);
        // Add loader to a garbage array - for a collection sweep and kill
        this._loadingSessionsGarbage.push(loader);
        this._gcTimeoutIID = setTimeout(function () {
            _this.loadingSessionGC();
        }, 100);
    };
    AssetLibraryBundle.prototype.loadingSessionGC = function () {
        var loader;
        while (this._loadingSessionsGarbage.length > 0) {
            loader = this._loadingSessionsGarbage.pop();
            this.killLoadingSession(loader);
        }
        clearTimeout(this._gcTimeoutIID);
        this._gcTimeoutIID = null;
    };
    AssetLibraryBundle.prototype.killLoadingSession = function (loader) {
        loader.removeEventListener(LoaderEvent.RESOURCE_COMPLETE, this._onResourceCompleteDelegate);
        loader.removeEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        loader.removeEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        loader.stop();
    };
    /**
     * Called when unespected error occurs
     */
    /*
     private onResourceError() : void
     {
     var msg:string = "Unexpected parser error";
     if(hasEventListener(LoaderEvent.DEPENDENCY_ERROR)){
     var re:LoaderEvent = new LoaderEvent(LoaderEvent.DEPENDENCY_ERROR, "");
     dispatchEvent(re);
     } else{
     throw new Error(msg);
     }
     }
     */
    AssetLibraryBundle.prototype.onAssetRename = function (event) {
        var asset = event.target; // TODO: was ev.currentTarget - watch this var
        var old = this.getAsset(asset.assetNamespace, asset.name);
        if (old != null) {
            this._strategy.resolveConflict(asset, old, this._assetDictionary[asset.assetNamespace], this._strategyPreference);
        }
        else {
            var dict = this._assetDictionary[event.asset.assetNamespace];
            if (dict == null)
                return;
            dict[event.assetPrevName] = null;
            dict[event.asset.name] = event.asset;
        }
    };
    AssetLibraryBundle.prototype.onAssetConflictResolved = function (event) {
        this.dispatchEvent(event.clone());
    };
    AssetLibraryBundle._iInstances = new Object();
    return AssetLibraryBundle;
})(EventDispatcher);
module.exports = AssetLibraryBundle;


},{"awayjs-core/lib/errors/Error":5,"awayjs-core/lib/events/AssetEvent":7,"awayjs-core/lib/events/EventDispatcher":9,"awayjs-core/lib/events/IOErrorEvent":11,"awayjs-core/lib/events/LoaderEvent":12,"awayjs-core/lib/events/ParserEvent":13,"awayjs-core/lib/library/AssetLibraryIterator":22,"awayjs-core/lib/library/AssetLoader":23,"awayjs-core/lib/library/ConflictPrecedence":26,"awayjs-core/lib/library/ConflictStrategy":27,"awayjs-core/lib/library/NamedAssetBase":31}],22:[function(require,module,exports){
var AssetLibraryIterator = (function () {
    function AssetLibraryIterator(assets, assetTypeFilter, namespaceFilter, filterFunc) {
        this._assets = assets;
        this.filter(assetTypeFilter, namespaceFilter, filterFunc);
    }
    Object.defineProperty(AssetLibraryIterator.prototype, "currentAsset", {
        get: function () {
            // Return current, or null if no current
            return (this._idx < this._filtered.length) ? this._filtered[this._idx] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetLibraryIterator.prototype, "numAssets", {
        get: function () {
            return this._filtered.length;
        },
        enumerable: true,
        configurable: true
    });
    AssetLibraryIterator.prototype.next = function () {
        var next = null;
        if (this._idx < this._filtered.length)
            next = this._filtered[this._idx];
        this._idx++;
        return next;
    };
    AssetLibraryIterator.prototype.reset = function () {
        this._idx = 0;
    };
    AssetLibraryIterator.prototype.setIndex = function (index) {
        this._idx = index;
    };
    AssetLibraryIterator.prototype.filter = function (assetTypeFilter, namespaceFilter, filterFunc) {
        if (assetTypeFilter || namespaceFilter) {
            var idx;
            var asset;
            idx = 0;
            this._filtered = new Array(); //new Vector.<IAsset>;
            var l = this._assets.length;
            for (var c = 0; c < l; c++) {
                asset = this._assets[c];
                // Skip this assets if filtering on type and this is wrong type
                if (assetTypeFilter && asset.assetType != assetTypeFilter)
                    continue;
                // Skip this asset if filtering on namespace and this is wrong namespace
                if (namespaceFilter && asset.assetNamespace != namespaceFilter)
                    continue;
                // Skip this asset if a filter func has been provided and it returns false
                if (filterFunc != null && !filterFunc(asset))
                    continue;
                this._filtered[idx++] = asset;
            }
        }
        else {
            this._filtered = this._assets;
        }
    };
    return AssetLibraryIterator;
})();
module.exports = AssetLibraryIterator;


},{}],23:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetLoaderToken = require("awayjs-core/lib/library/AssetLoaderToken");
var URLLoader = require("awayjs-core/lib/net/URLLoader");
var URLLoaderDataFormat = require("awayjs-core/lib/net/URLLoaderDataFormat");
var Error = require("awayjs-core/lib/errors/Error");
var AssetEvent = require("awayjs-core/lib/events/AssetEvent");
var Event = require("awayjs-core/lib/events/Event");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var IOErrorEvent = require("awayjs-core/lib/events/IOErrorEvent");
var LoaderEvent = require("awayjs-core/lib/events/LoaderEvent");
var ParserEvent = require("awayjs-core/lib/events/ParserEvent");
var CubeTextureParser = require("awayjs-core/lib/parsers/CubeTextureParser");
var ResourceDependency = require("awayjs-core/lib/parsers/ResourceDependency");
var Texture2DParser = require("awayjs-core/lib/parsers/Texture2DParser");
/**
 * Dispatched when any asset finishes parsing. Also see specific events for each
 * individual asset type (meshes, materials et c.)
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="assetComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a full resource (including dependencies) finishes loading.
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when a single dependency (which may be the main file of a resource)
 * finishes loading.
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when an error occurs during loading. I
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="loadError", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when an error occurs during parsing.
 *
 * @eventType away.events.ParserEvent
 */
//[Event(name="parseError", type="away3d.events.ParserEvent")]
/**
 * Dispatched when an image asset dimensions are not a power of 2
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
/**
 * AssetLoader can load any file format that away.supports (or for which a third-party parser
 * has been plugged in) and it's dependencies. Events are dispatched when assets are encountered
 * and for when the resource (or it's dependencies) have been loaded.
 *
 * The AssetLoader will not make assets available in any other way than through the dispatched
 * events. To store assets and make them available at any point from any module in an application,
 * use the AssetLibrary to load and manage assets.
 *
 * @see away.library.AssetLibrary
 */
var AssetLoader = (function (_super) {
    __extends(AssetLoader, _super);
    /**
     * Create a new ResourceLoadSession object.
     */
    function AssetLoader(materialMode) {
        var _this = this;
        if (materialMode === void 0) { materialMode = 0; }
        _super.call(this);
        this._materialMode = materialMode;
        this._stack = new Array();
        this._errorHandlers = new Array();
        this._parseErrorHandlers = new Array();
        this._onReadyForDependenciesDelegate = function (event) { return _this.onReadyForDependencies(event); };
        this._onParseCompleteDelegate = function (event) { return _this.onParseComplete(event); };
        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
        this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
    }
    /**
     * Enables a specific parser.
     * When no specific parser is set for a loading/parsing opperation,
     * loader3d can autoselect the correct parser to use.
     * A parser must have been enabled, to be considered when autoselecting the parser.
     *
     * @param parser The parser class to enable.
     *
     * @see away.parsers.Parsers
     */
    AssetLoader.enableParser = function (parser) {
        if (AssetLoader._parsers.indexOf(parser) < 0)
            AssetLoader._parsers.push(parser);
    };
    /**
     * Enables a list of parsers.
     * When no specific parser is set for a loading/parsing opperation,
     * AssetLoader can autoselect the correct parser to use.
     * A parser must have been enabled, to be considered when autoselecting the parser.
     *
     * @param parsers A Vector of parser classes to enable.
     * @see away.parsers.Parsers
     */
    AssetLoader.enableParsers = function (parsers) {
        for (var c = 0; c < parsers.length; c++)
            AssetLoader.enableParser(parsers[c]);
    };
    Object.defineProperty(AssetLoader.prototype, "baseDependency", {
        /**
         * Returns the base dependency of the loader
         */
        get: function () {
            return this._baseDependency;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads a file and (optionally) all of its dependencies.
     *
     * @param req The URLRequest object containing the URL of the file to be loaded.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
     */
    AssetLoader.prototype.load = function (req, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        if (!this._token) {
            this._token = new AssetLoaderToken(this);
            this._uri = req.url = req.url.replace(/\\/g, "/");
            this._context = context;
            this._namespace = ns;
            this._baseDependency = new ResourceDependency('', req, null, parser, null);
            this.retrieveDependency(this._baseDependency);
            return this._token;
        }
        // TODO: Throw error (already loading)
        return null;
    };
    /**
     * Loads a resource from already loaded data.
     *
     * @param data The data object containing all resource information.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
     */
    AssetLoader.prototype.loadData = function (data, id, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        if (!this._token) {
            this._token = new AssetLoaderToken(this);
            this._uri = id;
            this._context = context;
            this._namespace = ns;
            this._baseDependency = new ResourceDependency(id, null, data, parser, null);
            this.retrieveDependency(this._baseDependency);
            return this._token;
        }
        // TODO: Throw error (already loading)
        return null;
    };
    /**
     * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the
     * stack when complete and continues on the top set.
     * @param parser The parser that will translate the data into a usable resource.
     */
    AssetLoader.prototype.retrieveNext = function (parser) {
        if (parser === void 0) { parser = null; }
        if (this._currentDependency.dependencies.length) {
            var next = this._currentDependency.dependencies.pop();
            this._stack.push(this._currentDependency);
            this.retrieveDependency(next);
        }
        else if (this._currentDependency.parser && this._currentDependency.parser.parsingPaused) {
            this._currentDependency.parser._iResumeParsingAfterDependencies();
            this._stack.pop();
        }
        else if (this._stack.length) {
            var prev = this._currentDependency;
            this._currentDependency = this._stack.pop();
            if (prev._iSuccess)
                prev.resolve();
            this.retrieveNext(parser);
        }
        else {
            this.dispatchEvent(new LoaderEvent(LoaderEvent.RESOURCE_COMPLETE, this._uri, this._baseDependency.parser.content, this._baseDependency.assets));
        }
    };
    /**
     * Retrieves a single dependency.
     * @param parser The parser that will translate the data into a usable resource.
     */
    AssetLoader.prototype.retrieveDependency = function (dependency) {
        var data;
        if (this._context && this._context.materialMode != 0)
            this._materialMode = this._context.materialMode;
        this._currentDependency = dependency;
        dependency._iLoader = new URLLoader();
        this.addEventListeners(dependency._iLoader);
        // Get already loaded (or mapped) data if available
        data = dependency.data;
        if (this._context && dependency.request && this._context._iHasDataForUrl(dependency.request.url))
            data = this._context._iGetDataForUrl(dependency.request.url);
        if (data) {
            if (data.constructor === Function)
                data = new data();
            dependency._iSetData(data);
            if (dependency.retrieveAsRawData) {
                // No need to parse. The parent parser is expecting this
                // to be raw data so it can be passed directly.
                dependency.resolve();
                // Move on to next dependency
                this.retrieveNext();
            }
            else {
                this.parseDependency(dependency);
            }
        }
        else {
            // Resolve URL and start loading
            dependency.request.url = this.resolveDependencyUrl(dependency);
            if (dependency.retrieveAsRawData) {
                // Always use binary for raw data loading
                dependency._iLoader.dataFormat = URLLoaderDataFormat.BINARY;
            }
            else {
                if (!dependency.parser)
                    dependency._iSetParser(this.getParserFromSuffix(dependency.request.url));
                if (dependency.parser) {
                    dependency._iLoader.dataFormat = dependency.parser.dataFormat;
                }
                else {
                    // Always use BINARY for unknown file formats. The thorough
                    // file type check will determine format after load, and if
                    // binary, a text load will have broken the file data.
                    dependency._iLoader.dataFormat = URLLoaderDataFormat.BINARY;
                }
            }
            dependency._iLoader.load(dependency.request);
        }
    };
    AssetLoader.prototype.joinUrl = function (base, end) {
        if (end.charAt(0) == '/')
            end = end.substr(1);
        if (base.length == 0)
            return end;
        if (base.charAt(base.length - 1) == '/')
            base = base.substr(0, base.length - 1);
        return base.concat('/', end);
    };
    AssetLoader.prototype.resolveDependencyUrl = function (dependency) {
        var scheme_re;
        var base;
        var url = dependency.request.url;
        // Has the user re-mapped this URL?
        if (this._context && this._context._iHasMappingForUrl(url))
            return this._context._iGetRemappedUrl(url);
        // This is the "base" dependency, i.e. the actual requested asset.
        // We will not try to resolve this since the user can probably be
        // thrusted to know this URL better than our automatic resolver. :)
        if (url == this._uri)
            return url;
        // Absolute URL? Check if starts with slash or a URL
        // scheme definition (e.g. ftp://, http://, file://)
        scheme_re = new RegExp('/^[a-zA-Z]{3,4}:\/\//');
        if (url.charAt(0) == '/') {
            if (this._context && this._context.overrideAbsolutePaths)
                return this.joinUrl(this._context.dependencyBaseUrl, url);
            else
                return url;
        }
        else if (scheme_re.test(url)) {
            // If overriding full URLs, get rid of scheme (e.g. "http://")
            // and replace with the dependencyBaseUrl defined by user.
            if (this._context && this._context.overrideFullURLs) {
                var noscheme_url = url.replace(scheme_re, ''); //url['replace'](scheme_re);
                return this.joinUrl(this._context.dependencyBaseUrl, noscheme_url);
            }
        }
        // Since not absolute, just get rid of base file name to find it's
        // folder and then concatenate dynamic URL
        if (this._context && this._context.dependencyBaseUrl) {
            base = this._context.dependencyBaseUrl;
            return this.joinUrl(base, url);
        }
        else {
            base = this._uri.substring(0, this._uri.lastIndexOf('/') + 1);
            return this.joinUrl(base, url);
        }
    };
    AssetLoader.prototype.retrieveParserDependencies = function () {
        if (!this._currentDependency)
            return;
        var parserDependancies = this._currentDependency.parser.dependencies;
        var i, len = parserDependancies.length;
        for (i = 0; i < len; i++)
            this._currentDependency.dependencies[i] = parserDependancies[i];
        // Since more dependencies might be added eventually, empty this
        // list so that the same dependency isn't retrieved more than once.
        parserDependancies.length = 0;
        this._stack.push(this._currentDependency);
        this.retrieveNext();
    };
    AssetLoader.prototype.resolveParserDependencies = function () {
        this._currentDependency._iSuccess = true;
        // Retrieve any last dependencies remaining on this parser, or
        // if none exists, just move on.
        if (this._currentDependency.parser && this._currentDependency.parser.dependencies.length && (!this._context || this._context.includeDependencies))
            this.retrieveParserDependencies();
        else
            this.retrieveNext();
    };
    /**
     * Called when a single dependency loading failed, and pushes further dependencies onto the stack.
     * @param event
     */
    AssetLoader.prototype.onLoadError = function (event) {
        var handled;
        var isDependency = (this._currentDependency != this._baseDependency);
        var loader = event.target; //TODO: keep on eye on this one
        this.removeEventListeners(loader);
        if (this.hasEventListener(IOErrorEvent.IO_ERROR)) {
            this.dispatchEvent(event);
            handled = true;
        }
        else {
            // TODO: Consider not doing this even when AssetLoader does have it's own LOAD_ERROR listener
            var i, len = this._errorHandlers.length;
            for (i = 0; i < len; i++)
                if (!handled)
                    handled = this._errorHandlers[i](event);
        }
        if (handled) {
            //if (isDependency && ! event.isDefaultPrevented()) {
            if (isDependency) {
                this._currentDependency.resolveFailure();
                this.retrieveNext();
            }
            else {
                // Either this was the base file (last left in the stack) or
                // default behavior was prevented by the handlers, and hence
                // there is nothing more to do than clean up and bail.
                this.dispose();
                return;
            }
        }
        else {
            throw new Error();
        }
    };
    /**
     * Called when a dependency parsing failed, and dispatches a <code>ParserEvent.PARSE_ERROR</code>
     * @param event
     */
    AssetLoader.prototype.onParseError = function (event) {
        var handled;
        var isDependency = (this._currentDependency != this._baseDependency);
        var loader = event.target;
        this.removeEventListeners(loader);
        if (this.hasEventListener(ParserEvent.PARSE_ERROR)) {
            this.dispatchEvent(event);
            handled = true;
        }
        else {
            // TODO: Consider not doing this even when AssetLoader does
            // have it's own LOAD_ERROR listener
            var i, len = this._parseErrorHandlers.length;
            for (i = 0; i < len; i++)
                if (!handled)
                    handled = this._parseErrorHandlers[i](event);
        }
        if (handled) {
            this.dispose();
            return;
        }
        else {
            throw new Error(event.message);
        }
    };
    AssetLoader.prototype.onAssetComplete = function (event) {
        // Add loaded asset to list of assets retrieved as part
        // of the current dependency. This list will be inspected
        // by the parent parser when dependency is resolved
        if (this._currentDependency)
            this._currentDependency.assets.push(event.asset);
        event.asset.resetAssetPath(event.asset.name, this._namespace);
        if (!this._currentDependency.suppresAssetEvents)
            this.dispatchEvent(event);
    };
    AssetLoader.prototype.onReadyForDependencies = function (event) {
        var parser = event.target;
        if (this._context && !this._context.includeDependencies)
            parser._iResumeParsingAfterDependencies();
        else
            this.retrieveParserDependencies();
    };
    /**
     * Called when a single dependency was parsed, and pushes further dependencies onto the stack.
     * @param event
     */
    AssetLoader.prototype.onLoadComplete = function (event) {
        var loader = event.target;
        this.removeEventListeners(loader);
        // Resolve this dependency
        this._currentDependency._iSetData(loader.data);
        if (this._currentDependency.retrieveAsRawData) {
            // No need to parse this data, which should be returned as is
            this.resolveParserDependencies();
        }
        else {
            this.parseDependency(this._currentDependency);
        }
    };
    /**
     * Called when parsing is complete.
     */
    AssetLoader.prototype.onParseComplete = function (event) {
        var parser = event.target;
        this.resolveParserDependencies(); //resolve in front of removing listeners to allow any remaining asset events to propagate
        parser.removeEventListener(ParserEvent.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
        parser.removeEventListener(ParserEvent.PARSE_COMPLETE, this._onParseCompleteDelegate);
        parser.removeEventListener(ParserEvent.PARSE_ERROR, this._onParseErrorDelegate);
        parser.removeEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        parser.removeEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
    };
    /**
     * Called when an image is too large or it's dimensions are not a power of 2
     * @param event
     */
    AssetLoader.prototype.onTextureSizeError = function (event) {
        event.asset.name = this._currentDependency.resolveName(event.asset);
        this.dispatchEvent(event);
    };
    AssetLoader.prototype.addEventListeners = function (loader) {
        loader.addEventListener(Event.COMPLETE, this._onLoadCompleteDelegate);
        loader.addEventListener(IOErrorEvent.IO_ERROR, this._onLoadErrorDelegate);
    };
    AssetLoader.prototype.removeEventListeners = function (loader) {
        loader.removeEventListener(Event.COMPLETE, this._onLoadCompleteDelegate);
        loader.removeEventListener(IOErrorEvent.IO_ERROR, this._onLoadErrorDelegate);
    };
    AssetLoader.prototype.stop = function () {
        this.dispose();
    };
    AssetLoader.prototype.dispose = function () {
        this._errorHandlers = null;
        this._parseErrorHandlers = null;
        this._context = null;
        this._token = null;
        this._stack = null;
        if (this._currentDependency && this._currentDependency._iLoader)
            this.removeEventListeners(this._currentDependency._iLoader);
        this._currentDependency = null;
    };
    /**
     * @private
     * This method is used by other loader classes (e.g. Loader3D and AssetLibraryBundle) to
     * add error event listeners to the AssetLoader instance. This system is used instead of
     * the regular EventDispatcher system so that the AssetLibrary error handler can be sure
     * that if hasEventListener() returns true, it's client code that's listening for the
     * event. Secondly, functions added as error handler through this custom method are
     * expected to return a boolean value indicating whether the event was handled (i.e.
     * whether they in turn had any client code listening for the event.) If no handlers
     * return true, the AssetLoader knows that the event wasn't handled and will throw an RTE.
     */
    AssetLoader.prototype._iAddParseErrorHandler = function (handler) {
        if (this._parseErrorHandlers.indexOf(handler) < 0)
            this._parseErrorHandlers.push(handler);
    };
    AssetLoader.prototype._iAddErrorHandler = function (handler) {
        if (this._errorHandlers.indexOf(handler) < 0)
            this._errorHandlers.push(handler);
    };
    /**
     * Guesses the parser to be used based on the file contents.
     * @param data The data to be parsed.
     * @param uri The url or id of the object to be parsed.
     * @return An instance of the guessed parser.
     */
    AssetLoader.prototype.getParserFromData = function (data) {
        var len = AssetLoader._parsers.length;
        for (var i = len - 1; i >= 0; i--)
            if (AssetLoader._parsers[i].supportsData(data))
                return new AssetLoader._parsers[i]();
        return null;
    };
    /**
     * Initiates parsing of the loaded dependency.
     *
     * @param The dependency to be parsed.
     */
    AssetLoader.prototype.parseDependency = function (dependency) {
        var parser = dependency.parser;
        // If no parser has been defined, try to find one by letting
        // all plugged in parsers inspect the actual data.
        if (!parser)
            dependency._iSetParser(parser = this.getParserFromData(dependency.data));
        if (parser) {
            parser.addEventListener(ParserEvent.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
            parser.addEventListener(ParserEvent.PARSE_COMPLETE, this._onParseCompleteDelegate);
            parser.addEventListener(ParserEvent.PARSE_ERROR, this._onParseErrorDelegate);
            parser.addEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
            parser.addEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
            if (dependency.request && dependency.request.url)
                parser._iFileName = dependency.request.url;
            parser.materialMode = this._materialMode;
            parser.parseAsync(dependency.data);
        }
        else {
            var message = "No parser defined. To enable all parsers for auto-detection, use Parsers.enableAllBundled()";
            if (this.hasEventListener(ParserEvent.PARSE_ERROR))
                this.dispatchEvent(new ParserEvent(ParserEvent.PARSE_ERROR, message));
            else
                throw new Error(message);
        }
    };
    /**
     * Guesses the parser to be used based on the file extension.
     * @return An instance of the guessed parser.
     */
    AssetLoader.prototype.getParserFromSuffix = function (url) {
        // Get rid of query string if any and extract extension
        var base = (url.indexOf('?') > 0) ? url.split('?')[0] : url;
        var fileExtension = base.substr(base.lastIndexOf('.') + 1).toLowerCase();
        var len = AssetLoader._parsers.length;
        for (var i = len - 1; i >= 0; i--) {
            var parserClass = AssetLoader._parsers[i];
            if (parserClass.supportsType(fileExtension))
                return new parserClass();
        }
        return null;
    };
    // Image parser only parser that is added by default, to save file size.
    AssetLoader._parsers = new Array(Texture2DParser, CubeTextureParser);
    return AssetLoader;
})(EventDispatcher);
module.exports = AssetLoader;


},{"awayjs-core/lib/errors/Error":5,"awayjs-core/lib/events/AssetEvent":7,"awayjs-core/lib/events/Event":8,"awayjs-core/lib/events/EventDispatcher":9,"awayjs-core/lib/events/IOErrorEvent":11,"awayjs-core/lib/events/LoaderEvent":12,"awayjs-core/lib/events/ParserEvent":13,"awayjs-core/lib/library/AssetLoaderToken":24,"awayjs-core/lib/net/URLLoader":33,"awayjs-core/lib/net/URLLoaderDataFormat":34,"awayjs-core/lib/parsers/CubeTextureParser":38,"awayjs-core/lib/parsers/ResourceDependency":41,"awayjs-core/lib/parsers/Texture2DParser":42}],24:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
/**
 * Dispatched when any asset finishes parsing. Also see specific events for each
 * individual asset type (meshes, materials et c.)
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="assetComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a full resource (including dependencies) finishes loading.
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when a single dependency (which may be the main file of a resource)
 * finishes loading.
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when an error occurs during loading. I
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="loadError", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when an error occurs during parsing.
 *
 * @eventType away.events.ParserEvent
 */
//[Event(name="parseError", type="away3d.events.ParserEvent")]
/**
 * Dispatched when a skybox asset has been costructed from a ressource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="skyboxComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a camera3d asset has been costructed from a ressource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="cameraComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a mesh asset has been costructed from a ressource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="meshComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a geometry asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="geometryComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a skeleton asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="skeletonComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a skeleton pose asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="skeletonPoseComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a container asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="containerComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a texture asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="textureComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a texture projector asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="textureProjectorComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a material asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="materialComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a animator asset has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="animatorComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an animation set has been constructed from a group of animation state resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="animationSetComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an animation state has been constructed from a group of animation node resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="animationStateComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an animation node has been constructed from a resource.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="animationNodeComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an animation state transition has been constructed from a group of animation node resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="stateTransitionComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an light asset has been constructed from a resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="lightComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an light picker asset has been constructed from a resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="lightPickerComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an effect method asset has been constructed from a resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="effectMethodComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when an shadow map method asset has been constructed from a resources.
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="shadowMapMethodComplete", type="away3d.events.AssetEvent")]
/**
 * Instances of this class are returned as tokens by loading operations
 * to provide an object on which events can be listened for in cases where
 * the actual asset loader is not directly available (e.g. when using the
 * AssetLibrary to perform the load.)
 *
 * By listening for events on this class instead of directly on the
 * AssetLibrary, one can distinguish different loads from each other.
 *
 * The token will dispatch all events that the original AssetLoader dispatches,
 * while not providing an interface to obstruct the load and is as such a
 * safer return value for loader wrappers than the loader itself.
 */
var AssetLoaderToken = (function (_super) {
    __extends(AssetLoaderToken, _super);
    function AssetLoaderToken(loader) {
        _super.call(this);
        this._iLoader = loader;
    }
    AssetLoaderToken.prototype.addEventListener = function (type, listener) {
        this._iLoader.addEventListener(type, listener);
    };
    AssetLoaderToken.prototype.removeEventListener = function (type, listener) {
        this._iLoader.removeEventListener(type, listener);
    };
    AssetLoaderToken.prototype.hasEventListener = function (type, listener) {
        if (listener === void 0) { listener = null; }
        return this._iLoader.hasEventListener(type, listener);
    };
    return AssetLoaderToken;
})(EventDispatcher);
module.exports = AssetLoaderToken;


},{"awayjs-core/lib/events/EventDispatcher":9}],25:[function(require,module,exports){
var AssetType = (function () {
    function AssetType() {
    }
    AssetType.ANIMATION_NODE = 'animationNode';
    AssetType.ANIMATION_SET = 'animationSet';
    AssetType.ANIMATION_STATE = 'animationState';
    AssetType.ANIMATOR = 'animator';
    AssetType.BILLBOARD = 'billboard';
    AssetType.CAMERA = 'camera';
    AssetType.CONTAINER = 'container';
    AssetType.EFFECTS_METHOD = 'effectsMethod';
    AssetType.GEOMETRY = 'geometry';
    AssetType.LINE_SEGMENT = 'lineSegment';
    AssetType.LIGHT = 'light';
    AssetType.LIGHT_PICKER = 'lightPicker';
    AssetType.MATERIAL = 'material';
    AssetType.MESH = 'mesh';
    AssetType.TRIANGLE_SUB_MESH = 'triangleSubMesh';
    AssetType.LINE_SUB_MESH = 'lineSubMesh';
    AssetType.PRIMITIVE_PREFAB = 'primitivePrefab';
    AssetType.SHADOW_MAP_METHOD = 'shadowMapMethod';
    AssetType.SKELETON = 'skeleton';
    AssetType.SKELETON_POSE = 'skeletonPose';
    AssetType.SKYBOX = 'skybox';
    AssetType.STATE_TRANSITION = 'stateTransition';
    AssetType.TEXTURE = 'texture';
    AssetType.TEXTURE_PROJECTOR = 'textureProjector';
    return AssetType;
})();
module.exports = AssetType;


},{}],26:[function(require,module,exports){
/**
 * Enumaration class for precedence when resolving naming conflicts in the library.
 *
 * @see away.library.AssetLibrary.conflictPrecedence
 * @see away.library.AssetLibrary.conflictStrategy
 * @see away.library.naming.ConflictStrategy
 */
var ConflictPrecedence = (function () {
    function ConflictPrecedence() {
    }
    /**
     * Signals that in a conflict, the previous owner of the conflicting name
     * should be favored (and keep it's name) and that the newly renamed asset
     * is reverted to a non-conflicting name.
     */
    ConflictPrecedence.FAVOR_OLD = 'favorOld';
    /**
     * Signales that in a conflict, the newly renamed asset is favored (and keeps
     * it's newly defined name) and that the previous owner of that name gets
     * renamed to a non-conflicting name.
     */
    ConflictPrecedence.FAVOR_NEW = 'favorNew';
    return ConflictPrecedence;
})();
module.exports = ConflictPrecedence;


},{}],27:[function(require,module,exports){
var ErrorConflictStrategy = require("awayjs-core/lib/library/ErrorConflictStrategy");
var IgnoreConflictStrategy = require("awayjs-core/lib/library/IgnoreConflictStrategy");
var NumSuffixConflictStrategy = require("awayjs-core/lib/library/NumSuffixConflictStrategy");
/**
 * Enumeration class for bundled conflict strategies. Set one of these values (or an
 * instance of a self-defined sub-class of ConflictStrategyBase) to the conflictStrategy
 * property on an AssetLibrary to define how that library resolves naming conflicts.
 *
 * The value of the <code>AssetLibrary.conflictPrecedence</code> property defines which
 * of the conflicting assets will get to keep it's name, and which is renamed (if any.)
 *
 * @see away.library.AssetLibrary.conflictStrategy
 * @see away.library.naming.ConflictStrategyBase
 */
var ConflictStrategy = (function () {
    function ConflictStrategy(include) {
        //TODO: find out why typescript d.ts files do not include this class
    }
    /**
     * Specifies that in case of a naming conflict, one of the assets will be renamed and
     * a numeric suffix appended to the base name.
     */
    ConflictStrategy.APPEND_NUM_SUFFIX = new NumSuffixConflictStrategy();
    /**
     * Specifies that naming conflicts should be ignored. This is not recommended in most
     * cases, unless it can be 100% guaranteed that the application does not cause naming
     * conflicts in the library (i.e. when an app-level system is in place to prevent this.)
     */
    ConflictStrategy.IGNORE = new IgnoreConflictStrategy();
    /**
     * Specifies that an error should be thrown if a naming conflict is discovered. Use this
     * to be 100% sure that naming conflicts never occur unnoticed, and when it's undesirable
     * to have the library automatically rename assets to avoid such conflicts.
     */
    ConflictStrategy.THROW_ERROR = new ErrorConflictStrategy();
    return ConflictStrategy;
})();
module.exports = ConflictStrategy;


},{"awayjs-core/lib/library/ErrorConflictStrategy":29,"awayjs-core/lib/library/IgnoreConflictStrategy":30,"awayjs-core/lib/library/NumSuffixConflictStrategy":32}],28:[function(require,module,exports){
var ConflictPrecedence = require("awayjs-core/lib/library/ConflictPrecedence");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var AssetEvent = require("awayjs-core/lib/events/AssetEvent");
/**
 * Abstract base class for naming conflict resolution classes. Extend this to create a
 * strategy class which the asset library can use to resolve asset naming conflicts, or
 * use one of the bundled concrete strategy classes:
 *
 * <ul>
 *   <li>IgnoreConflictStrategy (ConflictStrategy.IGNORE)</li>
 *   <li>ErrorConflictStrategy (ConflictStrategy.THROW_ERROR)</li>
 *   <li>NumSuffixConflictStrategy (ConflictStrategy.APPEND_NUM_SUFFIX)</li>
 * </ul>
 *
 * @see away.library.AssetLibrary.conflictStrategy
 * @see away.library.ConflictStrategy
 * @see away.library.IgnoreConflictStrategy
 * @see away.library.ErrorConflictStrategy
 * @see away.library.NumSuffixConflictStrategy
 */
var ConflictStrategyBase = (function () {
    function ConflictStrategyBase() {
    }
    /**
     * Resolve a naming conflict between two assets. Must be implemented by concrete strategy
     * classes.
     */
    ConflictStrategyBase.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        throw new AbstractMethodError();
    };
    /**
     * Create instance of this conflict strategy. Used internally by the AssetLibrary to
     * make sure the same strategy instance is not used in all AssetLibrary instances, which
     * would break any state caching that happens inside the strategy class.
     */
    ConflictStrategyBase.prototype.create = function () {
        throw new AbstractMethodError();
    };
    /**
     * Provided as a convenience method for all conflict strategy classes, as a way to finalize
     * the conflict resolution by applying the new names and dispatching the correct events.
     */
    ConflictStrategyBase.prototype._pUpdateNames = function (ns, nonConflictingName, oldAsset, newAsset, assetsDictionary, precedence) {
        var loser_prev_name;
        var winner;
        var loser;
        winner = (precedence === ConflictPrecedence.FAVOR_NEW) ? newAsset : oldAsset;
        loser = (precedence === ConflictPrecedence.FAVOR_NEW) ? oldAsset : newAsset;
        loser_prev_name = loser.name;
        assetsDictionary[winner.name] = winner;
        assetsDictionary[nonConflictingName] = loser;
        loser.resetAssetPath(nonConflictingName, ns, false);
        loser.dispatchEvent(new AssetEvent(AssetEvent.ASSET_CONFLICT_RESOLVED, loser, loser_prev_name));
    };
    return ConflictStrategyBase;
})();
module.exports = ConflictStrategyBase;


},{"awayjs-core/lib/errors/AbstractMethodError":3,"awayjs-core/lib/events/AssetEvent":7,"awayjs-core/lib/library/ConflictPrecedence":26}],29:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ConflictStrategyBase = require("awayjs-core/lib/library/ConflictStrategyBase");
var Error = require("awayjs-core/lib/errors/Error");
var ErrorConflictStrategy = (function (_super) {
    __extends(ErrorConflictStrategy, _super);
    function ErrorConflictStrategy() {
        _super.call(this);
    }
    ErrorConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        throw new Error('Asset name collision while AssetLibrary.namingStrategy set to AssetLibrary.THROW_ERROR. Asset path: ' + changedAsset.assetFullPath);
    };
    ErrorConflictStrategy.prototype.create = function () {
        return new ErrorConflictStrategy();
    };
    return ErrorConflictStrategy;
})(ConflictStrategyBase);
module.exports = ErrorConflictStrategy;


},{"awayjs-core/lib/errors/Error":5,"awayjs-core/lib/library/ConflictStrategyBase":28}],30:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ConflictStrategyBase = require("awayjs-core/lib/library/ConflictStrategyBase");
var IgnoreConflictStrategy = (function (_super) {
    __extends(IgnoreConflictStrategy, _super);
    function IgnoreConflictStrategy() {
        _super.call(this);
    }
    IgnoreConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        // Do nothing, ignore the fact that there is a conflict.
        return;
    };
    IgnoreConflictStrategy.prototype.create = function () {
        return new IgnoreConflictStrategy();
    };
    return IgnoreConflictStrategy;
})(ConflictStrategyBase);
module.exports = IgnoreConflictStrategy;


},{"awayjs-core/lib/library/ConflictStrategyBase":28}],31:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var AssetEvent = require("awayjs-core/lib/events/AssetEvent");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var NamedAssetBase = (function (_super) {
    __extends(NamedAssetBase, _super);
    function NamedAssetBase(name) {
        if (name === void 0) { name = null; }
        _super.call(this);
        this._id = NamedAssetBase.ID_COUNT++;
        if (name == null)
            name = 'null';
        this._name = name;
        this._originalName = name;
        this.updateFullPath();
    }
    Object.defineProperty(NamedAssetBase.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            throw new AbstractMethodError();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NamedAssetBase.prototype, "originalName", {
        /**
         * The original name used for this asset in the resource (e.g. file) in which
         * it was found. This may not be the same as <code>name</code>, which may
         * have changed due to of a name conflict.
         */
        get: function () {
            return this._originalName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NamedAssetBase.prototype, "id", {
        /**
         * A unique id for the asset, used to identify assets in an associative array
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NamedAssetBase.prototype, "name", {
        get: function () {
            return this._name;
        },
        set: function (val) {
            var prev;
            prev = this._name;
            this._name = val;
            if (this._name == null)
                this._name = 'null';
            this.updateFullPath();
            //if (hasEventListener(AssetEvent.ASSET_RENAME))
            this.dispatchEvent(new AssetEvent(AssetEvent.ASSET_RENAME, this, prev));
        },
        enumerable: true,
        configurable: true
    });
    NamedAssetBase.prototype.dispose = function () {
        throw new AbstractMethodError();
    };
    Object.defineProperty(NamedAssetBase.prototype, "assetNamespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NamedAssetBase.prototype, "assetFullPath", {
        get: function () {
            return this._full_path;
        },
        enumerable: true,
        configurable: true
    });
    NamedAssetBase.prototype.assetPathEquals = function (name, ns) {
        return (this._name == name && (!ns || this._namespace == ns));
    };
    NamedAssetBase.prototype.resetAssetPath = function (name, ns, overrideOriginal) {
        if (ns === void 0) { ns = null; }
        if (overrideOriginal === void 0) { overrideOriginal = true; }
        this._name = name ? name : 'null';
        this._namespace = ns ? ns : NamedAssetBase.DEFAULT_NAMESPACE;
        if (overrideOriginal)
            this._originalName = this._name;
        this.updateFullPath();
    };
    NamedAssetBase.prototype.updateFullPath = function () {
        this._full_path = [this._namespace, this._name];
    };
    NamedAssetBase.ID_COUNT = 0;
    NamedAssetBase.DEFAULT_NAMESPACE = 'default';
    return NamedAssetBase;
})(EventDispatcher);
module.exports = NamedAssetBase;


},{"awayjs-core/lib/errors/AbstractMethodError":3,"awayjs-core/lib/events/AssetEvent":7,"awayjs-core/lib/events/EventDispatcher":9}],32:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ConflictStrategyBase = require("awayjs-core/lib/library/ConflictStrategyBase");
var NumSuffixConflictStrategy = (function (_super) {
    __extends(NumSuffixConflictStrategy, _super);
    function NumSuffixConflictStrategy(separator) {
        if (separator === void 0) { separator = '.'; }
        _super.call(this);
        this._separator = separator;
        this._next_suffix = {};
    }
    NumSuffixConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        var orig;
        var new_name;
        var base;
        var suffix;
        orig = changedAsset.name;
        if (orig.indexOf(this._separator) >= 0) {
            // Name has an ocurrence of the separator, so get base name and suffix,
            // unless suffix is non-numerical, in which case revert to zero and
            // use entire name as base
            base = orig.substring(0, orig.lastIndexOf(this._separator));
            suffix = parseInt(orig.substring(base.length - 1));
            if (isNaN(suffix)) {
                base = orig;
                suffix = 0;
            }
        }
        else {
            base = orig;
            suffix = 0;
        }
        if (suffix == 0 && this._next_suffix.hasOwnProperty(base)) {
            suffix = this._next_suffix[base];
        }
        do {
            suffix++;
            new_name = base.concat(this._separator, suffix.toString());
        } while (assetsDictionary.hasOwnProperty(new_name));
        this._next_suffix[base] = suffix;
        this._pUpdateNames(oldAsset.assetNamespace, new_name, oldAsset, changedAsset, assetsDictionary, precedence);
    };
    NumSuffixConflictStrategy.prototype.create = function () {
        return new NumSuffixConflictStrategy(this._separator);
    };
    return NumSuffixConflictStrategy;
})(ConflictStrategyBase);
module.exports = NumSuffixConflictStrategy;


},{"awayjs-core/lib/library/ConflictStrategyBase":28}],33:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var URLLoaderDataFormat = require("awayjs-core/lib/net/URLLoaderDataFormat");
var URLRequestMethod = require("awayjs-core/lib/net/URLRequestMethod");
var URLVariables = require("awayjs-core/lib/net/URLVariables");
var AwayEvent = require("awayjs-core/lib/events/Event");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var HTTPStatusEvent = require("awayjs-core/lib/events/HTTPStatusEvent");
var IOErrorEvent = require("awayjs-core/lib/events/IOErrorEvent");
var AwayProgressEvent = require("awayjs-core/lib/events/ProgressEvent");
/**
 * The URLLoader is used to load a single file, as part of a resource.
 *
 * While URLLoader can be used directly, e.g. to create a third-party asset
 * management system, it's recommended to use any of the classes Loader3D, AssetLoader
 * and AssetLibrary instead in most cases.
 *
 * @see AssetLoader
 * @see away.library.AssetLibrary
 */
var URLLoader = (function (_super) {
    __extends(URLLoader, _super);
    /**
     * Creates a new URLLoader object.
     */
    function URLLoader() {
        _super.call(this);
        this._bytesLoaded = 0;
        this._bytesTotal = 0;
        this._dataFormat = URLLoaderDataFormat.TEXT;
        this._loadError = false;
    }
    Object.defineProperty(URLLoader.prototype, "url", {
        /**
         *
         */
        get: function () {
            return this._request ? this._request.url : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "data", {
        /**
         *
         */
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "dataFormat", {
        get: function () {
            return this._dataFormat;
        },
        /**
         *
         * URLLoaderDataFormat.BINARY
         * URLLoaderDataFormat.TEXT
         * URLLoaderDataFormat.VARIABLES
         *
         * @param format
         */
        set: function (format) {
            this._dataFormat = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._bytesLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "bytesTotal", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._bytesTotal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Load a resource from a file.
     *
     * @param request The URLRequest object containing the URL of the object to be loaded.
     */
    URLLoader.prototype.load = function (request) {
        this._request = request;
        this.initXHR();
        if (request.method === URLRequestMethod.POST)
            this.postRequest(request);
        else
            this.getRequest(request);
    };
    /**
     *
     */
    URLLoader.prototype.close = function () {
        this._XHR.abort();
        this.disposeXHR();
    };
    /**
     *
     */
    URLLoader.prototype.dispose = function () {
        if (this._XHR)
            this._XHR.abort();
        this.disposeXHR();
        this._data = null;
        this._dataFormat = null;
        this._bytesLoaded = null;
        this._bytesTotal = null;
    };
    /**
     *
     * @param xhr
     * @param responseType
     */
    URLLoader.prototype.setResponseType = function (xhr, responseType) {
        switch (responseType) {
            case URLLoaderDataFormat.ARRAY_BUFFER:
            case URLLoaderDataFormat.BLOB:
            case URLLoaderDataFormat.TEXT:
                xhr.responseType = responseType;
                break;
            case URLLoaderDataFormat.VARIABLES:
                xhr.responseType = URLLoaderDataFormat.TEXT;
                break;
            case URLLoaderDataFormat.BINARY:
                xhr.responseType = '';
                break;
            default:
        }
    };
    /**
     *
     * @param request {URLRequest}
     */
    URLLoader.prototype.getRequest = function (request) {
        try {
            this._XHR.open(request.method, request.url, request.async);
            this.setResponseType(this._XHR, this._dataFormat);
            this._XHR.send(); // No data to send
        }
        catch (e) {
            this.handleXmlHttpRequestException(e);
        }
    };
    /**
     *
     * @param request {URLRequest}
     */
    URLLoader.prototype.postRequest = function (request) {
        this._loadError = false;
        this._XHR.open(request.method, request.url, request.async);
        if (request.data != null) {
            if (request.data instanceof URLVariables) {
                var urlVars = request.data;
                try {
                    this._XHR.responseType = 'text';
                    this._XHR.send(urlVars.formData);
                }
                catch (e) {
                    this.handleXmlHttpRequestException(e);
                }
            }
            else {
                this.setResponseType(this._XHR, this._dataFormat);
                if (request.data)
                    this._XHR.send(request.data); // TODO: Test
                else
                    this._XHR.send(); // no data to send
            }
        }
        else {
            this._XHR.send(); // No data to send
        }
    };
    /**
     *
     * @param error {XMLHttpRequestException}
     */
    URLLoader.prototype.handleXmlHttpRequestException = function (error /* <XMLHttpRequestException> */) {
        switch (error.code) {
            case 101:
                break;
        }
    };
    /**
     *
     */
    URLLoader.prototype.initXHR = function () {
        var _this = this;
        if (!this._XHR) {
            this._XHR = new XMLHttpRequest();
            this._XHR.onloadstart = function (event) { return _this.onLoadStart(event); }; // loadstart	        - When the request starts.
            this._XHR.onprogress = function (event) { return _this.onProgress(event); }; // progress	            - While loading and sending data.
            this._XHR.onabort = function (event) { return _this.onAbort(event); }; // abort	            - When the request has been aborted, either by invoking the abort() method or navigating away from the page.
            this._XHR.onerror = function (event) { return _this.onLoadError(event); }; // error	            - When the request has failed.
            this._XHR.onload = function (event) { return _this.onLoadComplete(event); }; // load	                - When the request has successfully completed.
            this._XHR.ontimeout = function (event) { return _this.onTimeOut(event); }; // timeout	            - When the author specified timeout has passed before the request could complete.
            this._XHR.onloadend = function (event) { return _this.onLoadEnd(event); }; // loadend	            - When the request has completed, regardless of whether or not it was successful.
            this._XHR.onreadystatechange = function (event) { return _this.onReadyStateChange(event); }; // onreadystatechange   - When XHR state changes
        }
    };
    /**
     *
     */
    URLLoader.prototype.disposeXHR = function () {
        if (this._XHR !== null) {
            this._XHR.onloadstart = null;
            this._XHR.onprogress = null;
            this._XHR.onabort = null;
            this._XHR.onerror = null;
            this._XHR.onload = null;
            this._XHR.ontimeout = null;
            this._XHR.onloadend = null;
            this._XHR = null;
        }
    };
    /**
     *
     * @param source
     */
    URLLoader.prototype.decodeURLVariables = function (source) {
        var result = new Object();
        source = source.split("+").join(" ");
        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
        while (tokens = re.exec(source))
            result[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
        return result;
    };
    // XMLHttpRequest - Event Handlers
    /**
     * When XHR state changes
     * @param event
     */
    URLLoader.prototype.onReadyStateChange = function (event) {
        if (this._XHR.readyState == 4) {
            if (this._XHR.status == 404) {
                this._loadError = true;
                if (!this._loadErrorEvent)
                    this._loadErrorEvent = new IOErrorEvent(IOErrorEvent.IO_ERROR);
                this.dispatchEvent(this._loadErrorEvent);
            }
            this.dispatchEvent(new HTTPStatusEvent(HTTPStatusEvent.HTTP_STATUS, this._XHR.status));
        }
    };
    /**
     * When the request has completed, regardless of whether or not it was successful.
     * @param event
     */
    URLLoader.prototype.onLoadEnd = function (event) {
        if (this._loadError === true)
            return;
    };
    /**
     * When the author specified timeout has passed before the request could complete.
     * @param event
     */
    URLLoader.prototype.onTimeOut = function (event) {
        //TODO: Timeout not currently implemented ( also not part of AS3 API )
    };
    /**
     * When the request has been aborted, either by invoking the abort() method or navigating away from the page.
     * @param event
     */
    URLLoader.prototype.onAbort = function (event) {
        // TODO: investigate whether this needs to be an IOError
    };
    /**
     * While loading and sending data.
     * @param event
     */
    URLLoader.prototype.onProgress = function (event) {
        if (!this._progressEvent)
            this._progressEvent = new AwayProgressEvent(AwayProgressEvent.PROGRESS);
        this._progressEvent.bytesTotal = event.total;
        this._progressEvent.bytesLoaded = event.loaded;
        this.dispatchEvent(this._progressEvent);
    };
    /**
     * When the request starts.
     * @param event
     */
    URLLoader.prototype.onLoadStart = function (event) {
        if (!this._loadStartEvent)
            this._loadStartEvent = new AwayEvent(AwayEvent.OPEN);
        this.dispatchEvent(this._loadStartEvent);
    };
    /**
     * When the request has successfully completed.
     * @param event
     */
    URLLoader.prototype.onLoadComplete = function (event) {
        if (this._loadError === true)
            return;
        switch (this._dataFormat) {
            case URLLoaderDataFormat.TEXT:
                this._data = this._XHR.responseText;
                break;
            case URLLoaderDataFormat.VARIABLES:
                this._data = this.decodeURLVariables(this._XHR.responseText);
                break;
            case URLLoaderDataFormat.BLOB:
            case URLLoaderDataFormat.ARRAY_BUFFER:
            case URLLoaderDataFormat.BINARY:
                this._data = this._XHR.response;
                break;
            default:
                this._data = this._XHR.responseText;
                break;
        }
        if (!this._loadCompleteEvent)
            this._loadCompleteEvent = new AwayEvent(AwayEvent.COMPLETE);
        this.dispatchEvent(this._loadCompleteEvent);
    };
    /**
     * When the request has failed. ( due to network issues ).
     * @param event
     */
    URLLoader.prototype.onLoadError = function (event) {
        this._loadError = true;
        if (!this._loadErrorEvent)
            this._loadErrorEvent = new IOErrorEvent(IOErrorEvent.IO_ERROR);
        this.dispatchEvent(this._loadErrorEvent);
    };
    return URLLoader;
})(EventDispatcher);
module.exports = URLLoader;


},{"awayjs-core/lib/events/Event":8,"awayjs-core/lib/events/EventDispatcher":9,"awayjs-core/lib/events/HTTPStatusEvent":10,"awayjs-core/lib/events/IOErrorEvent":11,"awayjs-core/lib/events/ProgressEvent":14,"awayjs-core/lib/net/URLLoaderDataFormat":34,"awayjs-core/lib/net/URLRequestMethod":36,"awayjs-core/lib/net/URLVariables":37}],34:[function(require,module,exports){
var URLLoaderDataFormat = (function () {
    function URLLoaderDataFormat() {
    }
    /**
     * TEXT
     * @type {string}
     */
    URLLoaderDataFormat.TEXT = "text";
    /**
     * Variables / Value Pairs
     * @type {string}
     */
    URLLoaderDataFormat.VARIABLES = "variables";
    /**
     *
     * @type {string}
     */
    URLLoaderDataFormat.BLOB = "blob";
    /**
     *
     * @type {string}
     */
    URLLoaderDataFormat.ARRAY_BUFFER = "arraybuffer";
    /**
     *
     * @type {string}
     */
    URLLoaderDataFormat.BINARY = "binary";
    return URLLoaderDataFormat;
})();
module.exports = URLLoaderDataFormat;


},{}],35:[function(require,module,exports){
var URLRequestMethod = require("awayjs-core/lib/net/URLRequestMethod");
var URLRequest = (function () {
    /**

     * @param url
     */
    function URLRequest(url) {
        if (url === void 0) { url = null; }
        /**
         *
         * away.net.URLRequestMethod.GET
         * away.net.URLRequestMethod.POST
         *
         * @type {string}
         */
        this.method = URLRequestMethod.GET;
        /**
         * Use asynchronous XMLHttpRequest
         * @type {boolean}
         */
        this.async = true;
        this._url = url;
    }
    Object.defineProperty(URLRequest.prototype, "url", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._url;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            this._url = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * dispose
     */
    URLRequest.prototype.dispose = function () {
        this.data = null;
        this._url = null;
    };
    return URLRequest;
})();
module.exports = URLRequest;


},{"awayjs-core/lib/net/URLRequestMethod":36}],36:[function(require,module,exports){
var URLRequestMethod = (function () {
    function URLRequestMethod() {
    }
    /**
     *
     * @type {string}
     */
    URLRequestMethod.POST = 'POST';
    /**
     *
     * @type {string}
     */
    URLRequestMethod.GET = 'GET';
    return URLRequestMethod;
})();
module.exports = URLRequestMethod;


},{}],37:[function(require,module,exports){
var URLVariables = (function () {
    /**
     *
     * @param source
     */
    function URLVariables(source) {
        if (source === void 0) { source = null; }
        this._variables = new Object();
        if (source !== null)
            this.decode(source);
    }
    /**
     *
     * @param source
     */
    URLVariables.prototype.decode = function (source) {
        source = source.split("+").join(" ");
        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
        while (tokens = re.exec(source))
            this._variables[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
    };
    /**
     *
     * @returns {string}
     */
    URLVariables.prototype.toString = function () {
        return '';
    };
    Object.defineProperty(URLVariables.prototype, "variables", {
        /**
         *
         * @returns {Object}
         */
        get: function () {
            return this._variables;
        },
        /**
         *
         * @returns {Object}
         */
        set: function (obj) {
            this._variables = obj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLVariables.prototype, "formData", {
        /**
         *
         * @returns {Object}
         */
        get: function () {
            var fd = new FormData();
            for (var s in this._variables)
                fd.append(s, this._variables[s]);
            return fd;
        },
        enumerable: true,
        configurable: true
    });
    return URLVariables;
})();
module.exports = URLVariables;


},{}],38:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var URLLoaderDataFormat = require("awayjs-core/lib/net/URLLoaderDataFormat");
var URLRequest = require("awayjs-core/lib/net/URLRequest");
var ParserBase = require("awayjs-core/lib/parsers/ParserBase");
var ImageCubeTexture = require("awayjs-core/lib/textures/ImageCubeTexture");
/**
 * CubeTextureParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
 * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
 * exception cases.
 */
var CubeTextureParser = (function (_super) {
    __extends(CubeTextureParser, _super);
    /**
     * Creates a new CubeTextureParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function CubeTextureParser() {
        _super.call(this, URLLoaderDataFormat.TEXT);
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    CubeTextureParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "cube";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    CubeTextureParser.supportsData = function (data) {
        try {
            var obj = JSON.parse(data);
            if (obj) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    CubeTextureParser.prototype._iResolveDependency = function (resourceDependency) {
    };
    /**
     * @inheritDoc
     */
    CubeTextureParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
    };
    /**
     * @inheritDoc
     */
    CubeTextureParser.prototype._pProceedParsing = function () {
        if (this._imgDependencyDictionary != null) {
            var asset = new ImageCubeTexture(this._getHTMLImageElement(CubeTextureParser.posX), this._getHTMLImageElement(CubeTextureParser.negX), this._getHTMLImageElement(CubeTextureParser.posY), this._getHTMLImageElement(CubeTextureParser.negY), this._getHTMLImageElement(CubeTextureParser.posZ), this._getHTMLImageElement(CubeTextureParser.negZ));
            //clear dictionary
            this._imgDependencyDictionary = null;
            asset.name = this._iFileName;
            this._pFinalizeAsset(asset, this._iFileName);
            return ParserBase.PARSING_DONE;
        }
        try {
            var json = JSON.parse(this.data);
            var data = json.data;
            var rec;
            if (data.length != 6)
                this._pDieWithError('CubeTextureParser: Error - cube texture should have exactly 6 images');
            if (json) {
                this._imgDependencyDictionary = new Object();
                for (var c = 0; c < data.length; c++) {
                    rec = data[c];
                    this._imgDependencyDictionary[rec.id] = this._pAddDependency(rec.id, new URLRequest(rec.image.toString()));
                }
                if (!this._validateCubeData()) {
                    this._pDieWithError("CubeTextureParser: JSON data error - cubes require id of:   \n" + CubeTextureParser.posX + ', ' + CubeTextureParser.negX + ',  \n' + CubeTextureParser.posY + ', ' + CubeTextureParser.negY + ',  \n' + CubeTextureParser.posZ + ', ' + CubeTextureParser.negZ);
                    return ParserBase.PARSING_DONE;
                }
                this._pPauseAndRetrieveDependencies();
                return ParserBase.MORE_TO_PARSE;
            }
        }
        catch (e) {
            this._pDieWithError('CubeTexturePaser Error parsing JSON');
        }
        return ParserBase.PARSING_DONE;
    };
    CubeTextureParser.prototype._validateCubeData = function () {
        return (this._imgDependencyDictionary[CubeTextureParser.posX] != null && this._imgDependencyDictionary[CubeTextureParser.negX] != null && this._imgDependencyDictionary[CubeTextureParser.posY] != null && this._imgDependencyDictionary[CubeTextureParser.negY] != null && this._imgDependencyDictionary[CubeTextureParser.posZ] != null && this._imgDependencyDictionary[CubeTextureParser.negZ] != null);
    };
    CubeTextureParser.prototype._getHTMLImageElement = function (name) {
        var dependency = this._imgDependencyDictionary[name];
        if (dependency) {
            return dependency.assets[0].htmlImageElement;
        }
        return null;
    };
    CubeTextureParser.posX = 'posX';
    CubeTextureParser.negX = 'negX';
    CubeTextureParser.posY = 'posY';
    CubeTextureParser.negY = 'negY';
    CubeTextureParser.posZ = 'posZ';
    CubeTextureParser.negZ = 'negZ';
    return CubeTextureParser;
})(ParserBase);
module.exports = CubeTextureParser;


},{"awayjs-core/lib/net/URLLoaderDataFormat":34,"awayjs-core/lib/net/URLRequest":35,"awayjs-core/lib/parsers/ParserBase":39,"awayjs-core/lib/textures/ImageCubeTexture":44}],39:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var AssetEvent = require("awayjs-core/lib/events/AssetEvent");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var ParserEvent = require("awayjs-core/lib/events/ParserEvent");
var TimerEvent = require("awayjs-core/lib/events/TimerEvent");
var ParserUtils = require("awayjs-core/lib/parsers/ParserUtils");
var ResourceDependency = require("awayjs-core/lib/parsers/ResourceDependency");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var Timer = require("awayjs-core/lib/utils/Timer");
var getTimer = require("awayjs-core/lib/utils/getTimer");
/**
 * <code>ParserBase</code> provides an abstract base class for objects that convert blocks of data to data structures
 * supported by away.
 *
 * If used by <code>AssetLoader</code> to automatically determine the parser type, two public static methods should
 * be implemented, with the following signatures:
 *
 * <code>public static supportsType(extension : string) : boolean</code>
 * Indicates whether or not a given file extension is supported by the parser.
 *
 * <code>public static supportsData(data : *) : boolean</code>
 * Tests whether a data block can be parsed by the parser.
 *
 * Furthermore, for any concrete subtype, the method <code>initHandle</code> should be overridden to immediately
 * create the object that will contain the parsed data. This allows <code>ResourceManager</code> to return an object
 * handle regardless of whether the object was loaded or not.
 *
 * @see AssetLoader
 */
var ParserBase = (function (_super) {
    __extends(ParserBase, _super);
    /**
     * Creates a new ParserBase object
     * @param format The data format of the file data to be parsed. Can be either <code>ParserDataFormat.BINARY</code> or <code>ParserDataFormat.PLAIN_TEXT</code>, and should be provided by the concrete subtype.
     *
     * @see away.loading.parsers.ParserDataFormat
     */
    function ParserBase(format) {
        var _this = this;
        _super.call(this);
        this._materialMode = 0;
        this._dataFormat = format;
        this._dependencies = new Array();
        this._pOnIntervalDelegate = function (event) { return _this._pOnInterval(event); };
    }
    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
    // TODO: add error checking for the following ( could cause a problem if this function is not implemented )
    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
    // Needs to be implemented in all Parsers (
    //<code>public static supportsType(extension : string) : boolean</code>
    //* Indicates whether or not a given file extension is supported by the parser.
    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ParserBase.supportsType = function (extension) {
        throw new AbstractMethodError();
    };
    Object.defineProperty(ParserBase.prototype, "content", {
        /* Protected */
        get: function () {
            return this._pContent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validates a bitmapData loaded before assigning to a default BitmapMaterial
     */
    ParserBase.prototype.isBitmapDataValid = function (bitmapData) {
        var isValid = TextureUtils.isBitmapDataValid(bitmapData);
        if (!isValid) {
            console.log(">> Bitmap loaded is not having power of 2 dimensions or is higher than 2048");
        }
        return isValid;
    };
    Object.defineProperty(ParserBase.prototype, "parsingFailure", {
        get: function () {
            return this._parsingFailure;
        },
        set: function (b) {
            this._parsingFailure = b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "parsingPaused", {
        get: function () {
            return this._parsingPaused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "parsingComplete", {
        get: function () {
            return this._parsingComplete;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "materialMode", {
        get: function () {
            return this._materialMode;
        },
        set: function (newMaterialMode) {
            this._materialMode = newMaterialMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "dataFormat", {
        /**
         * The data format of the file data to be parsed. Options are <code>URLLoaderDataFormat.BINARY</code>, <code>URLLoaderDataFormat.ARRAY_BUFFER</code>, <code>URLLoaderDataFormat.BLOB</code>, <code>URLLoaderDataFormat.VARIABLES</code> or <code>URLLoaderDataFormat.TEXT</code>.
         */
        get: function () {
            return this._dataFormat;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse data (possibly containing bytearry, plain text or BitmapAsset) asynchronously, meaning that
     * the parser will periodically stop parsing so that the AVM may proceed to the
     * next frame.
     *
     * @param data The untyped data object in which the loaded data resides.
     * @param frameLimit number of milliseconds of parsing allowed per frame. The
     * actual time spent on a frame can exceed this number since time-checks can
     * only be performed between logical sections of the parsing procedure.
     */
    ParserBase.prototype.parseAsync = function (data, frameLimit) {
        if (frameLimit === void 0) { frameLimit = 30; }
        this._data = data;
        this._pStartParsing(frameLimit);
    };
    Object.defineProperty(ParserBase.prototype, "dependencies", {
        /**
         * A list of dependencies that need to be loaded and resolved for the object being parsed.
         */
        get: function () {
            return this._dependencies;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolve a dependency when it's loaded. For example, a dependency containing an ImageResource would be assigned
     * to a Mesh instance as a BitmapMaterial, a scene graph object would be added to its intended parent. The
     * dependency should be a member of the dependencies property.
     *
     * @param resourceDependency The dependency to be resolved.
     */
    ParserBase.prototype._iResolveDependency = function (resourceDependency) {
        throw new AbstractMethodError();
    };
    /**
     * Resolve a dependency loading failure. Used by parser to eventually provide a default map
     *
     * @param resourceDependency The dependency to be resolved.
     */
    ParserBase.prototype._iResolveDependencyFailure = function (resourceDependency) {
        throw new AbstractMethodError();
    };
    /**
     * Resolve a dependency name
     *
     * @param resourceDependency The dependency to be resolved.
     */
    ParserBase.prototype._iResolveDependencyName = function (resourceDependency, asset) {
        return asset.name;
    };
    ParserBase.prototype._iResumeParsingAfterDependencies = function () {
        this._parsingPaused = false;
        if (this._timer)
            this._timer.start();
    };
    ParserBase.prototype._pFinalizeAsset = function (asset, name) {
        if (name === void 0) { name = null; }
        var type_event;
        var type_name;
        if (name != null)
            asset.name = name;
        // If the asset has no name, give it
        // a per-type default name.
        if (!asset.name)
            asset.name = asset.assetType;
        this.dispatchEvent(new AssetEvent(AssetEvent.ASSET_COMPLETE, asset));
    };
    /**
     * Parse the next block of data.
     * @return Whether or not more data needs to be parsed. Can be <code>ParserBase.ParserBase.PARSING_DONE</code> or
     * <code>ParserBase.ParserBase.MORE_TO_PARSE</code>.
     */
    ParserBase.prototype._pProceedParsing = function () {
        throw new AbstractMethodError();
    };
    ParserBase.prototype._pDieWithError = function (message) {
        if (message === void 0) { message = 'Unknown parsing error'; }
        if (this._timer) {
            this._timer.removeEventListener(TimerEvent.TIMER, this._pOnIntervalDelegate);
            this._timer.stop();
            this._timer = null;
        }
        this.dispatchEvent(new ParserEvent(ParserEvent.PARSE_ERROR, message));
    };
    ParserBase.prototype._pAddDependency = function (id, req, retrieveAsRawData, data, suppressErrorEvents) {
        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
        if (data === void 0) { data = null; }
        if (suppressErrorEvents === void 0) { suppressErrorEvents = false; }
        var dependency = new ResourceDependency(id, req, data, null, this, retrieveAsRawData, suppressErrorEvents);
        this._dependencies.push(dependency);
        return dependency;
    };
    ParserBase.prototype._pPauseAndRetrieveDependencies = function () {
        if (this._timer)
            this._timer.stop();
        this._parsingPaused = true;
        this.dispatchEvent(new ParserEvent(ParserEvent.READY_FOR_DEPENDENCIES));
    };
    /**
     * Tests whether or not there is still time left for parsing within the maximum allowed time frame per session.
     * @return True if there is still time left, false if the maximum allotted time was exceeded and parsing should be interrupted.
     */
    ParserBase.prototype._pHasTime = function () {
        return ((getTimer() - this._lastFrameTime) < this._frameLimit);
    };
    /**
     * Called when the parsing pause interval has passed and parsing can proceed.
     */
    ParserBase.prototype._pOnInterval = function (event) {
        if (event === void 0) { event = null; }
        this._lastFrameTime = getTimer();
        if (this._pProceedParsing() && !this._parsingFailure)
            this._pFinishParsing();
    };
    /**
     * Initializes the parsing of data.
     * @param frameLimit The maximum duration of a parsing session.
     */
    ParserBase.prototype._pStartParsing = function (frameLimit) {
        this._frameLimit = frameLimit;
        this._timer = new Timer(this._frameLimit, 0);
        this._timer.addEventListener(TimerEvent.TIMER, this._pOnIntervalDelegate);
        this._timer.start();
    };
    /**
     * Finish parsing the data.
     */
    ParserBase.prototype._pFinishParsing = function () {
        if (this._timer) {
            this._timer.removeEventListener(TimerEvent.TIMER, this._pOnIntervalDelegate);
            this._timer.stop();
        }
        this._timer = null;
        this._parsingComplete = true;
        this.dispatchEvent(new ParserEvent(ParserEvent.PARSE_COMPLETE));
    };
    /**
     *
     * @returns {string}
     * @private
     */
    ParserBase.prototype._pGetTextData = function () {
        return ParserUtils.toString(this._data);
    };
    /**
     *
     * @returns {string}
     * @private
     */
    ParserBase.prototype._pGetByteData = function () {
        return ParserUtils.toByteArray(this._data);
    };
    /**
     * Returned by <code>proceedParsing</code> to indicate no more parsing is needed.
     */
    ParserBase.PARSING_DONE = true;
    /* Protected */
    /**
     * Returned by <code>proceedParsing</code> to indicate more parsing is needed, allowing asynchronous parsing.
     */
    ParserBase.MORE_TO_PARSE = false;
    return ParserBase;
})(EventDispatcher);
module.exports = ParserBase;


},{"awayjs-core/lib/errors/AbstractMethodError":3,"awayjs-core/lib/events/AssetEvent":7,"awayjs-core/lib/events/EventDispatcher":9,"awayjs-core/lib/events/ParserEvent":13,"awayjs-core/lib/events/TimerEvent":15,"awayjs-core/lib/parsers/ParserUtils":40,"awayjs-core/lib/parsers/ResourceDependency":41,"awayjs-core/lib/utils/TextureUtils":54,"awayjs-core/lib/utils/Timer":55,"awayjs-core/lib/utils/getTimer":56}],40:[function(require,module,exports){
var ByteArray = require("awayjs-core/lib/utils/ByteArray");
var ParserUtils = (function () {
    function ParserUtils() {
    }
    /**
     * Converts an ArrayBuffer to a base64 string
     *
     * @param image data as a ByteArray
     *
     * @return HTMLImageElement
     *
     */
    ParserUtils.arrayBufferToImage = function (data) {
        var byteStr = '';
        var bytes = new Uint8Array(data);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++)
            byteStr += String.fromCharCode(bytes[i]);
        var base64Image = window.btoa(byteStr);
        var str = 'data:image/png;base64,' + base64Image;
        var img = new Image();
        img.src = str;
        return img;
    };
    /**
     * Converts an ByteArray to an Image - returns an HTMLImageElement
     *
     * @param image data as a ByteArray
     *
     * @return HTMLImageElement
     *
     */
    ParserUtils.byteArrayToImage = function (data) {
        var byteStr = '';
        var bytes = new Uint8Array(data.arraybytes);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++)
            byteStr += String.fromCharCode(bytes[i]);
        var base64Image = window.btoa(byteStr);
        var str = 'data:image/png;base64,' + base64Image;
        var img = new Image();
        img.src = str;
        return img;
    };
    /**
     * Converts an Blob to an Image - returns an HTMLImageElement
     *
     * @param image data as a Blob
     *
     * @return HTMLImageElement
     *
     */
    ParserUtils.blobToImage = function (data) {
        var URLObj = window['URL'] || window['webkitURL'];
        var src = URLObj.createObjectURL(data);
        var img = new Image();
        img.src = src;
        return img;
    };
    /**
     * Returns a object as ByteArray, if possible.
     *
     * @param data The object to return as ByteArray
     *
     * @return The ByteArray or null
     *
     */
    ParserUtils.toByteArray = function (data) {
        var b = new ByteArray();
        b.setArrayBuffer(data);
        return b;
    };
    /**
     * Returns a object as String, if possible.
     *
     * @param data The object to return as String
     * @param length The length of the returned String
     *
     * @return The String or null
     *
     */
    ParserUtils.toString = function (data, length) {
        if (length === void 0) { length = 0; }
        if (typeof data === 'string') {
            var s = data;
            if (s['substr'] != null)
                return s.substr(0, s.length);
        }
        if (data instanceof ByteArray) {
            var ba = data;
            ba.position = 0;
            return ba.readUTFBytes(Math.min(ba.getBytesAvailable(), length));
        }
        return null;
        /*
         var ba:ByteArray;

         length ||= uint.MAX_VALUE;

         if (data is String)
         return String(data).substr(0, length);

         ba = toByteArray(data);
         if (ba) {
         ba.position = 0;
         return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
         }

         return null;

         */
    };
    return ParserUtils;
})();
module.exports = ParserUtils;


},{"awayjs-core/lib/utils/ByteArray":49}],41:[function(require,module,exports){
/**
 * ResourceDependency represents the data required to load, parse and resolve additional files ("dependencies")
 * required by a parser, used by ResourceLoadSession.
 *
 */
var ResourceDependency = (function () {
    function ResourceDependency(id, request, data, parser, parentParser, retrieveAsRawData, suppressAssetEvents) {
        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
        if (suppressAssetEvents === void 0) { suppressAssetEvents = false; }
        this._id = id;
        this._request = request;
        this._data = data;
        this._parser = parser;
        this._parentParser = parentParser;
        this._retrieveAsRawData = retrieveAsRawData;
        this._suppressAssetEvents = suppressAssetEvents;
        this._assets = new Array();
        this._dependencies = new Array();
    }
    Object.defineProperty(ResourceDependency.prototype, "id", {
        /**
         *
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "request", {
        /**
         *
         */
        get: function () {
            return this._request;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "data", {
        /**
         * The data containing the dependency to be parsed, if the resource was already loaded.
         */
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "parser", {
        /**
         *
         */
        get: function () {
            return this._parser;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "parentParser", {
        /**
         * The parser which is dependent on this ResourceDependency object.
         */
        get: function () {
            return this._parentParser;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
        /**
         *
         */
        get: function () {
            return this._retrieveAsRawData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
        /**
         *
         */
        get: function () {
            return this._suppressAssetEvents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "assets", {
        /**
         *
         */
        get: function () {
            return this._assets;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "dependencies", {
        /**
         *
         */
        get: function () {
            return this._dependencies;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * Method to set data after having already created the dependency object, e.g. after load.
     */
    ResourceDependency.prototype._iSetData = function (data) {
        this._data = data;
    };
    /**
     * @private
     *
     */
    ResourceDependency.prototype._iSetParser = function (parser) {
        this._parser = parser;
    };
    /**
     * Resolve the dependency when it's loaded with the parent parser. For example, a dependency containing an
     * ImageResource would be assigned to a Mesh instance as a BitmapMaterial, a scene graph object would be added
     * to its intended parent. The dependency should be a member of the dependencies property.
     */
    ResourceDependency.prototype.resolve = function () {
        if (this._parentParser)
            this._parentParser._iResolveDependency(this);
    };
    /**
     * Resolve a dependency failure. For example, map loading failure from a 3d file
     */
    ResourceDependency.prototype.resolveFailure = function () {
        if (this._parentParser)
            this._parentParser._iResolveDependencyFailure(this);
    };
    /**
     * Resolve the dependencies name
     */
    ResourceDependency.prototype.resolveName = function (asset) {
        if (this._parentParser)
            return this._parentParser._iResolveDependencyName(this, asset);
        return asset.name;
    };
    return ResourceDependency;
})();
module.exports = ResourceDependency;


},{}],42:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var URLLoaderDataFormat = require("awayjs-core/lib/net/URLLoaderDataFormat");
var ParserBase = require("awayjs-core/lib/parsers/ParserBase");
var ParserUtils = require("awayjs-core/lib/parsers/ParserUtils");
var ByteArray = require("awayjs-core/lib/utils/ByteArray");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var ImageTexture = require("awayjs-core/lib/textures/ImageTexture");
/**
 * Texture2DParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
 * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
 * exception cases.
 */
var Texture2DParser = (function (_super) {
    __extends(Texture2DParser, _super);
    /**
     * Creates a new Texture2DParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function Texture2DParser() {
        _super.call(this, URLLoaderDataFormat.BLOB);
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    Texture2DParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "gif"; //|| extension == "bmp";//|| extension == "atf";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    Texture2DParser.supportsData = function (data) {
        if (data instanceof HTMLImageElement)
            return true;
        if (!(data instanceof ByteArray))
            return false;
        var ba = data;
        ba.position = 0;
        if (ba.readUnsignedShort() == 0xffd8)
            return true; // JPEG, maybe check for "JFIF" as well?
        ba.position = 0;
        if (ba.readShort() == 0x424D)
            return true; // BMP
        ba.position = 1;
        if (ba.readUTFBytes(3) == 'PNG')
            return true;
        ba.position = 0;
        if (ba.readUTFBytes(3) == 'GIF' && ba.readShort() == 0x3839 && ba.readByte() == 0x61)
            return true;
        ba.position = 0;
        if (ba.readUTFBytes(3) == 'ATF')
            return true;
        return false;
    };
    /**
     * @inheritDoc
     */
    Texture2DParser.prototype._pProceedParsing = function () {
        var _this = this;
        var asset;
        var sizeError = false;
        if (this._loadingImage) {
            return ParserBase.MORE_TO_PARSE;
        }
        else if (this._htmlImageElement) {
            if (TextureUtils.isHTMLImageElementValid(this._htmlImageElement)) {
                asset = new ImageTexture(this._htmlImageElement);
                this._pFinalizeAsset(asset, this._iFileName);
            }
        }
        else if (this.data instanceof HTMLImageElement) {
            if (TextureUtils.isHTMLImageElementValid(this.data)) {
                asset = new ImageTexture(this.data);
                this._pFinalizeAsset(asset, this._iFileName);
            }
            else {
                sizeError = true;
            }
        }
        else if (this.data instanceof ByteArray) {
            var ba = this.data;
            ba.position = 0;
            var htmlImageElement = ParserUtils.byteArrayToImage(this.data);
            if (TextureUtils.isHTMLImageElementValid(htmlImageElement)) {
                asset = new ImageTexture(htmlImageElement);
                this._pFinalizeAsset(asset, this._iFileName);
            }
            else {
                sizeError = true;
            }
        }
        else if (this.data instanceof ArrayBuffer) {
            this._htmlImageElement = ParserUtils.arrayBufferToImage(this.data);
            asset = new ImageTexture(this._htmlImageElement);
            this._pFinalizeAsset(asset, this._iFileName);
        }
        else if (this.data instanceof Blob) {
            this._htmlImageElement = ParserUtils.blobToImage(this.data);
            this._htmlImageElement.onload = function (event) { return _this.onLoadComplete(event); };
            this._loadingImage = true;
            return ParserBase.MORE_TO_PARSE;
        }
        if (sizeError == true) {
        }
        this._pContent = asset;
        return ParserBase.PARSING_DONE;
    };
    Texture2DParser.prototype.onLoadComplete = function (event) {
        this._loadingImage = false;
    };
    return Texture2DParser;
})(ParserBase);
module.exports = Texture2DParser;


},{"awayjs-core/lib/net/URLLoaderDataFormat":34,"awayjs-core/lib/parsers/ParserBase":39,"awayjs-core/lib/parsers/ParserUtils":40,"awayjs-core/lib/textures/ImageTexture":45,"awayjs-core/lib/utils/ByteArray":49,"awayjs-core/lib/utils/TextureUtils":54}],43:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var MipmapGenerator = require("awayjs-core/lib/textures/MipmapGenerator");
var TextureProxyBase = require("awayjs-core/lib/textures/TextureProxyBase");
var CubeTextureBase = (function (_super) {
    __extends(CubeTextureBase, _super);
    function CubeTextureBase(generateMipmaps) {
        if (generateMipmaps === void 0) { generateMipmaps = false; }
        _super.call(this, generateMipmaps);
        this._mipmapDataArray = new Array(6);
        this._mipmapDataDirtyArray = new Array(6);
    }
    /**
     *
     * @param width
     * @param height
     * @private
     */
    CubeTextureBase.prototype._pSetSize = function (size) {
        if (this._pSize != size)
            this.invalidateSize();
        for (var i = 0; i < 6; i++)
            this._mipmapDataDirtyArray[i] = true;
        this._pSize = size;
    };
    /**
     * @inheritDoc
     */
    CubeTextureBase.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        for (var i = 0; i < 6; i++) {
            var mipmapData = this._mipmapDataArray[i];
            var len = mipmapData.length;
            for (var j = 0; j < len; j++)
                MipmapGenerator.freeMipMapHolder(mipmapData[j]);
        }
    };
    /**
     *
     */
    CubeTextureBase.prototype.invalidateContent = function () {
        _super.prototype.invalidateContent.call(this);
        for (var i = 0; i < 6; i++)
            this._mipmapDataDirtyArray[i] = true;
    };
    CubeTextureBase.prototype._iGetMipmapData = function (side) {
        if (this._mipmapDataDirtyArray[side]) {
            this._mipmapDataDirtyArray[side] = false;
            var mipmapData = this._mipmapDataArray[side] || (this._mipmapDataArray[side] = new Array());
            MipmapGenerator.generateMipMaps(this._iGetTextureData(side), mipmapData, true);
        }
        return this._mipmapDataArray[side];
    };
    CubeTextureBase.prototype._iGetTextureData = function (side) {
        throw new AbstractMethodError();
    };
    return CubeTextureBase;
})(TextureProxyBase);
module.exports = CubeTextureBase;


},{"awayjs-core/lib/errors/AbstractMethodError":3,"awayjs-core/lib/textures/MipmapGenerator":46,"awayjs-core/lib/textures/TextureProxyBase":48}],44:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
var CubeTextureBase = require("awayjs-core/lib/textures/CubeTextureBase");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var ImageCubeTexture = (function (_super) {
    __extends(ImageCubeTexture, _super);
    function ImageCubeTexture(posX, negX, posY, negY, posZ, negZ, generateMipmaps) {
        if (generateMipmaps === void 0) { generateMipmaps = false; }
        _super.call(this, generateMipmaps);
        this._htmlImageElements = new Array(6);
        this._testSize(this._htmlImageElements[0] = posX);
        this._testSize(this._htmlImageElements[1] = negX);
        this._testSize(this._htmlImageElements[2] = posY);
        this._testSize(this._htmlImageElements[3] = negY);
        this._testSize(this._htmlImageElements[4] = posZ);
        this._testSize(this._htmlImageElements[5] = negZ);
        this.invalidateContent();
        this._pSetSize(posX.width);
    }
    Object.defineProperty(ImageCubeTexture.prototype, "positiveX", {
        /**
         * The texture on the cube's right face.
         */
        get: function () {
            return this._htmlImageElements[0];
        },
        set: function (value) {
            this._testSize(value);
            this.invalidateContent();
            this._pSetSize(value.width);
            this._htmlImageElements[0] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageCubeTexture.prototype, "negativeX", {
        /**
         * The texture on the cube's left face.
         */
        get: function () {
            return this._htmlImageElements[1];
        },
        set: function (value) {
            this._testSize(value);
            this.invalidateContent();
            this._pSetSize(value.width);
            this._htmlImageElements[1] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageCubeTexture.prototype, "positiveY", {
        /**
         * The texture on the cube's top face.
         */
        get: function () {
            return this._htmlImageElements[2];
        },
        set: function (value) {
            this._testSize(value);
            this.invalidateContent();
            this._pSetSize(value.width);
            this._htmlImageElements[2] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageCubeTexture.prototype, "negativeY", {
        /**
         * The texture on the cube's bottom face.
         */
        get: function () {
            return this._htmlImageElements[3];
        },
        set: function (value) {
            this._testSize(value);
            this.invalidateContent();
            this._pSetSize(value.width);
            this._htmlImageElements[3] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageCubeTexture.prototype, "positiveZ", {
        /**
         * The texture on the cube's far face.
         */
        get: function () {
            return this._htmlImageElements[4];
        },
        set: function (value) {
            this._testSize(value);
            this.invalidateContent();
            this._pSetSize(value.width);
            this._htmlImageElements[4] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageCubeTexture.prototype, "negativeZ", {
        /**
         * The texture on the cube's near face.
         */
        get: function () {
            return this._htmlImageElements[5];
        },
        set: function (value) {
            this._testSize(value);
            this.invalidateContent();
            this._pSetSize(value.width);
            this._htmlImageElements[5] = value;
        },
        enumerable: true,
        configurable: true
    });
    ImageCubeTexture.prototype._testSize = function (value) {
        if (value.width != value.height)
            throw new Error("BitmapData should have equal width and height!");
        if (!TextureUtils.isHTMLImageElementValid(value))
            throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
    };
    ImageCubeTexture.prototype._iGetTextureData = function (side) {
        return this._htmlImageElements[side];
    };
    return ImageCubeTexture;
})(CubeTextureBase);
module.exports = ImageCubeTexture;


},{"awayjs-core/lib/errors/Error":5,"awayjs-core/lib/textures/CubeTextureBase":43,"awayjs-core/lib/utils/TextureUtils":54}],45:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
var Texture2DBase = require("awayjs-core/lib/textures/Texture2DBase");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var ImageTexture = (function (_super) {
    __extends(ImageTexture, _super);
    /**
     *
     * @param htmlImageElement
     * @param generateMipmaps
     */
    function ImageTexture(htmlImageElement, generateMipmaps) {
        if (generateMipmaps === void 0) { generateMipmaps = false; }
        _super.call(this, generateMipmaps);
        this.htmlImageElement = htmlImageElement;
    }
    Object.defineProperty(ImageTexture.prototype, "htmlImageElement", {
        /**
         *
         */
        get: function () {
            return this._htmlImageElement;
        },
        set: function (value) {
            if (this._htmlImageElement == value)
                return;
            if (!TextureUtils.isHTMLImageElementValid(value))
                throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
            this._htmlImageElement = value;
            this.invalidateContent();
            this._pSetSize(value.width, value.height);
        },
        enumerable: true,
        configurable: true
    });
    ImageTexture.prototype._iGetTextureData = function () {
        return this._htmlImageElement;
    };
    return ImageTexture;
})(Texture2DBase);
module.exports = ImageTexture;


},{"awayjs-core/lib/errors/Error":5,"awayjs-core/lib/textures/Texture2DBase":47,"awayjs-core/lib/utils/TextureUtils":54}],46:[function(require,module,exports){
var BitmapData = require("awayjs-core/lib/base/BitmapData");
var Matrix = require("awayjs-core/lib/geom/Matrix");
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
/**
 * MipmapGenerator is a helper class that uploads BitmapData to a Texture including mipmap levels.
 */
var MipmapGenerator = (function () {
    function MipmapGenerator() {
    }
    MipmapGenerator.generateMipMaps = function (source, output, alpha) {
        if (alpha === void 0) { alpha = false; }
        var w = source.width;
        var h = source.height;
        var i = 0;
        var mipmap;
        MipmapGenerator._rect.width = w;
        MipmapGenerator._rect.height = h;
        while (w >= 1 && h >= 1) {
            mipmap = output[i] = MipmapGenerator._getMipmapHolder(output[i], w, h);
            if (alpha)
                mipmap.fillRect(MipmapGenerator._rect, 0);
            MipmapGenerator._matrix.a = MipmapGenerator._rect.width / source.width;
            MipmapGenerator._matrix.d = MipmapGenerator._rect.height / source.height;
            mipmap.draw(source, MipmapGenerator._matrix); //TODO: smoothing?
            w >>= 1;
            h >>= 1;
            MipmapGenerator._rect.width = w > 1 ? w : 1;
            MipmapGenerator._rect.height = h > 1 ? h : 1;
            i++;
        }
    };
    MipmapGenerator._getMipmapHolder = function (mipMapHolder, newW, newH) {
        if (mipMapHolder) {
            if (mipMapHolder.width == newW && mipMapHolder.height == newH)
                return mipMapHolder;
            MipmapGenerator.freeMipMapHolder(mipMapHolder);
        }
        if (!MipmapGenerator._mipMaps[newW]) {
            MipmapGenerator._mipMaps[newW] = [];
            MipmapGenerator._mipMapUses[newW] = [];
        }
        if (!MipmapGenerator._mipMaps[newW][newH]) {
            mipMapHolder = MipmapGenerator._mipMaps[newW][newH] = new BitmapData(newW, newH, true);
            MipmapGenerator._mipMapUses[newW][newH] = 1;
        }
        else {
            MipmapGenerator._mipMapUses[newW][newH] = MipmapGenerator._mipMapUses[newW][newH] + 1;
            mipMapHolder = MipmapGenerator._mipMaps[newW][newH];
        }
        return mipMapHolder;
    };
    MipmapGenerator.freeMipMapHolder = function (mipMapHolder) {
        var holderWidth = mipMapHolder.width;
        var holderHeight = mipMapHolder.height;
        if (--MipmapGenerator._mipMapUses[holderWidth][holderHeight] == 0) {
            MipmapGenerator._mipMaps[holderWidth][holderHeight].dispose();
            MipmapGenerator._mipMaps[holderWidth][holderHeight] = null;
        }
    };
    MipmapGenerator._mipMaps = [];
    MipmapGenerator._mipMapUses = [];
    MipmapGenerator._matrix = new Matrix();
    MipmapGenerator._rect = new Rectangle();
    return MipmapGenerator;
})();
module.exports = MipmapGenerator;


},{"awayjs-core/lib/base/BitmapData":2,"awayjs-core/lib/geom/Matrix":16,"awayjs-core/lib/geom/Rectangle":18}],47:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var MipmapGenerator = require("awayjs-core/lib/textures/MipmapGenerator");
var TextureProxyBase = require("awayjs-core/lib/textures/TextureProxyBase");
var Texture2DBase = (function (_super) {
    __extends(Texture2DBase, _super);
    function Texture2DBase(generateMipmaps) {
        if (generateMipmaps === void 0) { generateMipmaps = false; }
        _super.call(this, generateMipmaps);
    }
    Object.defineProperty(Texture2DBase.prototype, "width", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._pWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2DBase.prototype, "height", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._pHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2DBase.prototype, "size", {
        get: function () {
            return this._pWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    Texture2DBase.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._mipmapData) {
            var len = this._mipmapData.length;
            for (var i = 0; i < len; i++)
                MipmapGenerator.freeMipMapHolder(this._mipmapData[i]);
        }
    };
    /**
     *
     */
    Texture2DBase.prototype.invalidateContent = function () {
        _super.prototype.invalidateContent.call(this);
        this._mipmapDataDirty = true;
    };
    /**
     *
     * @param width
     * @param height
     * @private
     */
    Texture2DBase.prototype._pSetSize = function (width, height) {
        if (this._pWidth != width || this._pHeight != height)
            this.invalidateSize();
        this._mipmapDataDirty = true;
        this._pWidth = width;
        this._pHeight = height;
    };
    Texture2DBase.prototype._iGetMipmapData = function () {
        if (this._mipmapDataDirty) {
            this._mipmapDataDirty = false;
            if (!this._mipmapData)
                this._mipmapData = new Array();
            MipmapGenerator.generateMipMaps(this._iGetTextureData(), this._mipmapData, true);
        }
        return this._mipmapData;
    };
    Texture2DBase.prototype._iGetTextureData = function () {
        throw new AbstractMethodError();
    };
    return Texture2DBase;
})(TextureProxyBase);
module.exports = Texture2DBase;


},{"awayjs-core/lib/errors/AbstractMethodError":3,"awayjs-core/lib/textures/MipmapGenerator":46,"awayjs-core/lib/textures/TextureProxyBase":48}],48:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
/**
 *
 */
var TextureProxyBase = (function (_super) {
    __extends(TextureProxyBase, _super);
    /**
     *
     */
    function TextureProxyBase(generateMipmaps) {
        if (generateMipmaps === void 0) { generateMipmaps = false; }
        _super.call(this);
        this._pFormat = "bgra";
        this._textureData = new Array();
        this._generateMipmaps = this._hasMipmaps = generateMipmaps;
    }
    Object.defineProperty(TextureProxyBase.prototype, "size", {
        get: function () {
            return this._pSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProxyBase.prototype, "hasMipmaps", {
        get: function () {
            return this._hasMipmaps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProxyBase.prototype, "format", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._pFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProxyBase.prototype, "generateMipmaps", {
        /**
         *
         * @returns {boolean}
         */
        get: function () {
            return this._generateMipmaps;
        },
        set: function (value) {
            if (this._generateMipmaps == value)
                return;
            this._generateMipmaps = this._hasMipmaps = value;
            this.invalidateContent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProxyBase.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return AssetType.TEXTURE;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    TextureProxyBase.prototype.invalidateContent = function () {
        var len = this._textureData.length;
        for (var i = 0; i < len; i++)
            this._textureData[i].invalidate();
    };
    /**
     *
     * @private
     */
    TextureProxyBase.prototype.invalidateSize = function () {
        while (this._textureData.length)
            this._textureData[0].dispose();
    };
    /**
     * @inheritDoc
     */
    TextureProxyBase.prototype.dispose = function () {
        while (this._textureData.length)
            this._textureData[0].dispose();
    };
    TextureProxyBase.prototype._iAddTextureData = function (textureData) {
        this._textureData.push(textureData);
        return textureData;
    };
    TextureProxyBase.prototype._iRemoveTextureData = function (textureData) {
        this._textureData.splice(this._textureData.indexOf(textureData), 1);
        return textureData;
    };
    return TextureProxyBase;
})(NamedAssetBase);
module.exports = TextureProxyBase;


},{"awayjs-core/lib/library/AssetType":25,"awayjs-core/lib/library/NamedAssetBase":31}],49:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ByteArrayBase = require("awayjs-core/lib/utils/ByteArrayBase");
var ByteArray = (function (_super) {
    __extends(ByteArray, _super);
    function ByteArray() {
        _super.call(this);
        this.maxlength = 0;
        this._mode = "Typed array";
        this.maxlength = 4;
        this.arraybytes = new ArrayBuffer(this.maxlength);
        this.unalignedarraybytestemp = new ArrayBuffer(16);
    }
    ByteArray.prototype.ensureWriteableSpace = function (n) {
        this.ensureSpace(n + this.position);
    };
    ByteArray.prototype.setArrayBuffer = function (aBuffer) {
        this.ensureSpace(aBuffer.byteLength);
        this.length = aBuffer.byteLength;
        var inInt8AView = new Int8Array(aBuffer);
        var localInt8View = new Int8Array(this.arraybytes, 0, this.length);
        localInt8View.set(inInt8AView);
        this.position = 0;
    };
    ByteArray.prototype.getBytesAvailable = function () {
        return (this.length) - (this.position);
    };
    ByteArray.prototype.ensureSpace = function (n) {
        if (n > this.maxlength) {
            var newmaxlength = (n + 255) & (~255);
            var newarraybuffer = new ArrayBuffer(newmaxlength);
            var view = new Uint8Array(this.arraybytes, 0, this.length);
            var newview = new Uint8Array(newarraybuffer, 0, this.length);
            newview.set(view); // memcpy
            this.arraybytes = newarraybuffer;
            this.maxlength = newmaxlength;
        }
    };
    ByteArray.prototype.writeByte = function (b) {
        this.ensureWriteableSpace(1);
        var view = new Int8Array(this.arraybytes);
        view[this.position++] = (~~b); // ~~ is cast to int in js...
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArray.prototype.readByte = function () {
        if (this.position >= this.length) {
            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
        }
        var view = new Int8Array(this.arraybytes);
        return view[this.position++];
    };
    ByteArray.prototype.readBytes = function (bytes, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = 0; }
        if (length == null) {
            length = bytes.length;
        }
        bytes.ensureWriteableSpace(offset + length);
        var byteView = new Int8Array(bytes.arraybytes);
        var localByteView = new Int8Array(this.arraybytes);
        byteView.set(localByteView.subarray(this.position, this.position + length), offset);
        this.position += length;
        if (length + offset > bytes.length) {
            bytes.length += (length + offset) - bytes.length;
        }
    };
    ByteArray.prototype.writeUnsignedByte = function (b) {
        this.ensureWriteableSpace(1);
        var view = new Uint8Array(this.arraybytes);
        view[this.position++] = (~~b) & 0xff; // ~~ is cast to int in js...
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArray.prototype.readUnsignedByte = function () {
        if (this.position >= this.length) {
            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
        }
        var view = new Uint8Array(this.arraybytes);
        return view[this.position++];
    };
    ByteArray.prototype.writeUnsignedShort = function (b) {
        this.ensureWriteableSpace(2);
        if ((this.position & 1) == 0) {
            var view = new Uint16Array(this.arraybytes);
            view[this.position >> 1] = (~~b) & 0xffff; // ~~ is cast to int in js...
        }
        else {
            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = (~~b) & 0xffff;
            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
            view2.set(view3);
        }
        this.position += 2;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArray.prototype.readUTFBytes = function (len) {
        var value = "";
        var max = this.position + len;
        var data = new DataView(this.arraybytes);
        while (this.position < max) {
            var c = data.getUint8(this.position++);
            if (c < 0x80) {
                if (c == 0)
                    break;
                value += String.fromCharCode(c);
            }
            else if (c < 0xE0) {
                value += String.fromCharCode(((c & 0x3F) << 6) | (data.getUint8(this.position++) & 0x7F));
            }
            else if (c < 0xF0) {
                var c2 = data.getUint8(this.position++);
                value += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (data.getUint8(this.position++) & 0x7F));
            }
            else {
                var c2 = data.getUint8(this.position++);
                var c3 = data.getUint8(this.position++);
                value += String.fromCharCode(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (data.getUint8(this.position++) & 0x7F));
            }
        }
        return value;
    };
    ByteArray.prototype.readInt = function () {
        var data = new DataView(this.arraybytes);
        var int = data.getInt32(this.position, true);
        this.position += 4;
        return int;
    };
    ByteArray.prototype.readShort = function () {
        var data = new DataView(this.arraybytes);
        var short = data.getInt16(this.position, true);
        this.position += 2;
        return short;
    };
    ByteArray.prototype.readDouble = function () {
        var data = new DataView(this.arraybytes);
        var double = data.getFloat64(this.position, true);
        this.position += 8;
        return double;
    };
    ByteArray.prototype.readUnsignedShort = function () {
        if (this.position > this.length + 2) {
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        }
        if ((this.position & 1) == 0) {
            var view = new Uint16Array(this.arraybytes);
            var pa = this.position >> 1;
            this.position += 2;
            return view[pa];
        }
        else {
            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
            view3.set(view2);
            this.position += 2;
            return view[0];
        }
    };
    ByteArray.prototype.writeUnsignedInt = function (b) {
        this.ensureWriteableSpace(4);
        if ((this.position & 3) == 0) {
            var view = new Uint32Array(this.arraybytes);
            view[this.position >> 2] = (~~b) & 0xffffffff; // ~~ is cast to int in js...
        }
        else {
            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = (~~b) & 0xffffffff;
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view2.set(view3);
        }
        this.position += 4;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArray.prototype.readUnsignedInt = function () {
        if (this.position > this.length + 4) {
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        }
        if ((this.position & 3) == 0) {
            var view = new Uint32Array(this.arraybytes);
            var pa = this.position >> 2;
            this.position += 4;
            return view[pa];
        }
        else {
            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view3.set(view2);
            this.position += 4;
            return view[0];
        }
    };
    ByteArray.prototype.writeFloat = function (b) {
        this.ensureWriteableSpace(4);
        if ((this.position & 3) == 0) {
            var view = new Float32Array(this.arraybytes);
            view[this.position >> 2] = b;
        }
        else {
            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = b;
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view2.set(view3);
        }
        this.position += 4;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArray.prototype.readFloat = function () {
        if (this.position > this.length + 4) {
            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
        }
        if ((this.position & 3) == 0) {
            var view = new Float32Array(this.arraybytes);
            var pa = this.position >> 2;
            this.position += 4;
            return view[pa];
        }
        else {
            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view3.set(view2);
            this.position += 4;
            return view[0];
        }
    };
    return ByteArray;
})(ByteArrayBase);
module.exports = ByteArray;


},{"awayjs-core/lib/utils/ByteArrayBase":50}],50:[function(require,module,exports){
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var ByteArrayBase = (function () {
    function ByteArrayBase() {
        this.position = 0;
        this.length = 0;
        this._mode = "";
    }
    ByteArrayBase.prototype.writeByte = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readByte = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeUnsignedByte = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readUnsignedByte = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeUnsignedShort = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readUnsignedShort = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeUnsignedInt = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readUnsignedInt = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeFloat = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.toFloatBits = function (x) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readFloat = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.fromFloatBits = function (x) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.getBytesAvailable = function () {
        throw new AbstractMethodError('ByteArrayBase, getBytesAvailable() not implemented ');
    };
    ByteArrayBase.prototype.toString = function () {
        return "[ByteArray] ( " + this._mode + " ) position=" + this.position + " length=" + this.length;
    };
    ByteArrayBase.prototype.compareEqual = function (other, count) {
        if (count == undefined || count > this.length - this.position)
            count = this.length - this.position;
        if (count > other.length - other.position)
            count = other.length - other.position;
        var co0 = count;
        var r = true;
        while (r && count >= 4) {
            count -= 4;
            if (this.readUnsignedInt() != other.readUnsignedInt())
                r = false;
        }
        while (r && count >= 1) {
            count--;
            if (this.readUnsignedByte() != other.readUnsignedByte())
                r = false;
        }
        var c0;
        this.position -= (c0 - count);
        other.position -= (c0 - count);
        return r;
    };
    ByteArrayBase.prototype.writeBase64String = function (s) {
        for (var i = 0; i < s.length; i++) {
            var v = s.charAt(i);
        }
    };
    ByteArrayBase.prototype.dumpToConsole = function () {
        var oldpos = this.position;
        this.position = 0;
        var nstep = 8;
        function asHexString(x, digits) {
            var lut = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            var sh = "";
            for (var d = 0; d < digits; d++) {
                sh = lut[(x >> (d << 2)) & 0xf] + sh;
            }
            return sh;
        }
        for (var i = 0; i < this.length; i += nstep) {
            var s = asHexString(i, 4) + ":";
            for (var j = 0; j < nstep && i + j < this.length; j++) {
                s += " " + asHexString(this.readUnsignedByte(), 2);
            }
            console.log(s);
        }
        this.position = oldpos;
    };
    ByteArrayBase.prototype.readBase64String = function (count) {
        if (count == undefined || count > this.length - this.position)
            count = this.length - this.position;
        if (!(count > 0))
            return "";
        return ByteArrayBase.internalGetBase64String(count, this.readUnsignedByte, this);
    };
    ByteArrayBase.internalGetBase64String = function (count, getUnsignedByteFunc, self) {
        var r = "";
        var b0, b1, b2, enc1, enc2, enc3, enc4;
        var base64Key = ByteArrayBase.Base64Key;
        while (count >= 3) {
            b0 = getUnsignedByteFunc.apply(self);
            b1 = getUnsignedByteFunc.apply(self);
            b2 = getUnsignedByteFunc.apply(self);
            enc1 = b0 >> 2;
            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
            enc3 = ((b1 & 15) << 2) | (b2 >> 6);
            enc4 = b2 & 63;
            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + base64Key.charAt(enc4);
            count -= 3;
        }
        // pad
        if (count == 2) {
            b0 = getUnsignedByteFunc.apply(self);
            b1 = getUnsignedByteFunc.apply(self);
            enc1 = b0 >> 2;
            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
            enc3 = ((b1 & 15) << 2);
            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + "=";
        }
        else if (count == 1) {
            b0 = getUnsignedByteFunc.apply(self);
            enc1 = b0 >> 2;
            enc2 = ((b0 & 3) << 4);
            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + "==";
        }
        return r;
    };
    ByteArrayBase.Base64Key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    return ByteArrayBase;
})();
module.exports = ByteArrayBase;


},{"awayjs-core/lib/errors/AbstractMethodError":3}],51:[function(require,module,exports){
/**
 *
 */
var ColorUtils = (function () {
    function ColorUtils() {
    }
    ColorUtils.float32ColorToARGB = function (float32Color) {
        var a = (float32Color & 0xff000000) >>> 24;
        var r = (float32Color & 0xff0000) >>> 16;
        var g = (float32Color & 0xff00) >>> 8;
        var b = float32Color & 0xff;
        var result = [a, r, g, b];
        return result;
    };
    ColorUtils.componentToHex = function (c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    };
    ColorUtils.RGBToHexString = function (argb) {
        return "#" + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
    };
    ColorUtils.ARGBToHexString = function (argb) {
        return "#" + ColorUtils.componentToHex(argb[0]) + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
    };
    return ColorUtils;
})();
module.exports = ColorUtils;


},{}],52:[function(require,module,exports){
var PartialImplementationError = require("awayjs-core/lib/errors/PartialImplementationError");
/**
 *
 */
var Debug = (function () {
    function Debug() {
    }
    Debug.breakpoint = function () {
        Debug['break']();
    };
    Debug.throwPIROnKeyWordOnly = function (str, enable) {
        if (enable === void 0) { enable = true; }
        if (!enable)
            Debug.keyword = null;
        else
            Debug.keyword = str;
    };
    Debug.throwPIR = function (clss, fnc, msg) {
        Debug.logPIR('PartialImplementationError ' + clss, fnc, msg);
        if (Debug.THROW_ERRORS) {
            if (Debug.keyword) {
                var e = clss + fnc + msg;
                if (e.indexOf(Debug.keyword) == -1)
                    return;
            }
            throw new PartialImplementationError(clss + '.' + fnc + ': ' + msg);
        }
    };
    Debug.logPIR = function (clss, fnc, msg) {
        if (msg === void 0) { msg = ''; }
        if (Debug.LOG_PI_ERRORS)
            console.log(clss + '.' + fnc + ': ' + msg);
    };
    Debug.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (Debug.ENABLE_LOG)
            console.log(args);
    };
    Debug.THROW_ERRORS = true;
    Debug.ENABLE_LOG = true;
    Debug.LOG_PI_ERRORS = true;
    Debug.keyword = null;
    return Debug;
})();
module.exports = Debug;


},{"awayjs-core/lib/errors/PartialImplementationError":6}],53:[function(require,module,exports){
var getTimer = require("awayjs-core/lib/utils/getTimer");
var RequestAnimationFrame = (function () {
    function RequestAnimationFrame(callback, callbackContext) {
        var _this = this;
        this._active = false;
        this._argsArray = new Array();
        this._getTimer = getTimer;
        this.setCallback(callback, callbackContext);
        this._rafUpdateFunction = function () {
            if (_this._active)
                _this._tick();
        };
        this._argsArray.push(this._dt);
    }
    // Public
    /**
     *
     * @param callback
     * @param callbackContext
     */
    RequestAnimationFrame.prototype.setCallback = function (callback, callbackContext) {
        this._callback = callback;
        this._callbackContext = callbackContext;
    };
    /**
     *
     */
    RequestAnimationFrame.prototype.start = function () {
        this._prevTime = this._getTimer();
        this._active = true;
        if (window.requestAnimationFrame) {
            window.requestAnimationFrame(this._rafUpdateFunction);
        }
        else {
            if (window['mozRequestAnimationFrame'])
                window.requestAnimationFrame = window['mozRequestAnimationFrame'];
            else if (window['webkitRequestAnimationFrame'])
                window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
            else if (window['oRequestAnimationFrame'])
                window.requestAnimationFrame = window['oRequestAnimationFrame'];
        }
    };
    /**
     *
     */
    RequestAnimationFrame.prototype.stop = function () {
        this._active = false;
    };
    Object.defineProperty(RequestAnimationFrame.prototype, "active", {
        // Get / Set
        /**
         *
         * @returns {boolean}
         */
        get: function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    // Private
    /**
     *
     * @private
     */
    RequestAnimationFrame.prototype._tick = function () {
        this._currentTime = this._getTimer();
        this._dt = this._currentTime - this._prevTime;
        this._argsArray[0] = this._dt;
        this._callback.apply(this._callbackContext, this._argsArray);
        window.requestAnimationFrame(this._rafUpdateFunction);
        this._prevTime = this._currentTime;
    };
    return RequestAnimationFrame;
})();
module.exports = RequestAnimationFrame;


},{"awayjs-core/lib/utils/getTimer":56}],54:[function(require,module,exports){
var TextureUtils = (function () {
    function TextureUtils() {
    }
    TextureUtils.isBitmapDataValid = function (bitmapData) {
        if (bitmapData == null) {
            return true;
        }
        return TextureUtils.isDimensionValid(bitmapData.width) && TextureUtils.isDimensionValid(bitmapData.height);
    };
    TextureUtils.isHTMLImageElementValid = function (image) {
        if (image == null)
            return true;
        return TextureUtils.isDimensionValid(image.width) && TextureUtils.isDimensionValid(image.height);
    };
    TextureUtils.isDimensionValid = function (d) {
        return d >= 1 && d <= TextureUtils.MAX_SIZE && TextureUtils.isPowerOfTwo(d);
    };
    TextureUtils.isPowerOfTwo = function (value) {
        return value ? ((value & -value) == value) : false;
    };
    TextureUtils.getBestPowerOf2 = function (value) {
        var p = 1;
        while (p < value)
            p <<= 1;
        if (p > TextureUtils.MAX_SIZE)
            p = TextureUtils.MAX_SIZE;
        return p;
    };
    TextureUtils.MAX_SIZE = 2048;
    return TextureUtils;
})();
module.exports = TextureUtils;


},{}],55:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var TimerEvent = require("awayjs-core/lib/events/TimerEvent");
var Timer = (function (_super) {
    __extends(Timer, _super);
    function Timer(delay, repeatCount) {
        if (repeatCount === void 0) { repeatCount = 0; }
        _super.call(this);
        this._repeatCount = 0;
        this._currentCount = 0;
        this._running = false;
        this._delay = delay;
        this._repeatCount = repeatCount;
        if (isNaN(delay) || delay < 0) {
            throw new Error("Delay is negative or not a number");
        }
    }
    Object.defineProperty(Timer.prototype, "currentCount", {
        get: function () {
            return this._currentCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Timer.prototype, "delay", {
        get: function () {
            return this._delay;
        },
        set: function (value) {
            this._delay = value;
            if (this._running) {
                this.stop();
                this.start();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Timer.prototype, "repeatCount", {
        get: function () {
            return this._repeatCount;
        },
        set: function (value) {
            this._repeatCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Timer.prototype.reset = function () {
        if (this._running) {
            this.stop();
        }
        this._currentCount = 0;
    };
    Object.defineProperty(Timer.prototype, "running", {
        get: function () {
            return this._running;
        },
        enumerable: true,
        configurable: true
    });
    Timer.prototype.start = function () {
        var _this = this;
        this._running = true;
        clearInterval(this._iid);
        this._iid = setInterval(function () { return _this.tick(); }, this._delay);
    };
    Timer.prototype.stop = function () {
        this._running = false;
        clearInterval(this._iid);
    };
    Timer.prototype.tick = function () {
        this._currentCount++;
        if ((this._repeatCount > 0) && this._currentCount >= this._repeatCount) {
            this.stop();
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER));
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER_COMPLETE));
        }
        else {
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER));
        }
    };
    return Timer;
})(EventDispatcher);
module.exports = Timer;


},{"awayjs-core/lib/errors/Error":5,"awayjs-core/lib/events/EventDispatcher":9,"awayjs-core/lib/events/TimerEvent":15}],56:[function(require,module,exports){
/**
 *
 *
 * @returns {number}
 */
function getTimer() {
    // number milliseconds of 1970/01/01
    // this different to AS3 implementation which gets the number of milliseconds
    // since instance of Flash player was initialised
    return Date.now();
}
module.exports = getTimer;


},{}],57:[function(require,module,exports){
/**
 *
 */
var AlignmentMode = (function () {
    function AlignmentMode() {
    }
    /**
     *
     */
    AlignmentMode.REGISTRATION_POINT = "registrationPoint";
    /**
     *
     */
    AlignmentMode.PIVOT_POINT = "pivot";
    return AlignmentMode;
})();
module.exports = AlignmentMode;


},{}],58:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AxisAlignedBoundingBox = require("awayjs-core/lib/bounds/AxisAlignedBoundingBox");
var MathConsts = require("awayjs-core/lib/geom/MathConsts");
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Matrix3DUtils = require("awayjs-core/lib/geom/Matrix3DUtils");
var Point = require("awayjs-core/lib/geom/Point");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var AlignmentMode = require("awayjs-display/lib/base/AlignmentMode");
var OrientationMode = require("awayjs-display/lib/base/OrientationMode");
var Transform = require("awayjs-display/lib/base/Transform");
var PickingCollisionVO = require("awayjs-display/lib/pick/PickingCollisionVO");
var DisplayObjectEvent = require("awayjs-display/lib/events/DisplayObjectEvent");
var SceneEvent = require("awayjs-display/lib/events/SceneEvent");
/**
 * The DisplayObject class is the base class for all objects that can be
 * placed on the display list. The display list manages all objects displayed
 * in flash. Use the DisplayObjectContainer class to arrange the
 * display objects in the display list. DisplayObjectContainer objects can
 * have child display objects, while other display objects, such as Shape and
 * TextField objects, are "leaf" nodes that have only parents and siblings, no
 * children.
 *
 * <p>The DisplayObject class supports basic functionality like the <i>x</i>
 * and <i>y</i> position of an object, as well as more advanced properties of
 * the object such as its transformation matrix. </p>
 *
 * <p>DisplayObject is an abstract base class; therefore, you cannot call
 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
 * <code>ArgumentError</code> exception. </p>
 *
 * <p>All display objects inherit from the DisplayObject class.</p>
 *
 * <p>The DisplayObject class itself does not include any APIs for rendering
 * content onscreen. For that reason, if you want create a custom subclass of
 * the DisplayObject class, you will want to extend one of its subclasses that
 * do have APIs for rendering content onscreen, such as the Shape, Sprite,
 * Bitmap, SimpleButton, TextField, or MovieClip class.</p>
 *
 * <p>The DisplayObject class contains several broadcast events. Normally, the
 * target of any particular event is a specific DisplayObject instance. For
 * example, the target of an <code>added</code> event is the specific
 * DisplayObject instance that was added to the display list. Having a single
 * target restricts the placement of event listeners to that target and in
 * some cases the target's ancestors on the display list. With broadcast
 * events, however, the target is not a specific DisplayObject instance, but
 * rather all DisplayObject instances, including those that are not on the
 * display list. This means that you can add a listener to any DisplayObject
 * instance to listen for broadcast events. In addition to the broadcast
 * events listed in the DisplayObject class's Events table, the DisplayObject
 * class also inherits two broadcast events from the EventDispatcher class:
 * <code>activate</code> and <code>deactivate</code>.</p>
 *
 * <p>Some properties previously used in the ActionScript 1.0 and 2.0
 * MovieClip, TextField, and Button classes(such as <code>_alpha</code>,
 * <code>_height</code>, <code>_name</code>, <code>_width</code>,
 * <code>_x</code>, <code>_y</code>, and others) have equivalents in the
 * ActionScript 3.0 DisplayObject class that are renamed so that they no
 * longer begin with the underscore(_) character.</p>
 *
 * <p>For more information, see the "Display Programming" chapter of the
 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
 *
 * @event added            Dispatched when a display object is added to the
 *                         display list. The following methods trigger this
 *                         event:
 *                         <code>DisplayObjectContainer.addChild()</code>,
 *                         <code>DisplayObjectContainer.addChildAt()</code>.
 * @event addedToStage     Dispatched when a display object is added to the on
 *                         stage display list, either directly or through the
 *                         addition of a sub tree in which the display object
 *                         is contained. The following methods trigger this
 *                         event:
 *                         <code>DisplayObjectContainer.addChild()</code>,
 *                         <code>DisplayObjectContainer.addChildAt()</code>.
 * @event enterFrame       [broadcast event] Dispatched when the playhead is
 *                         entering a new frame. If the playhead is not
 *                         moving, or if there is only one frame, this event
 *                         is dispatched continuously in conjunction with the
 *                         frame rate. This event is a broadcast event, which
 *                         means that it is dispatched by all display objects
 *                         with a listener registered for this event.
 * @event exitFrame        [broadcast event] Dispatched when the playhead is
 *                         exiting the current frame. All frame scripts have
 *                         been run. If the playhead is not moving, or if
 *                         there is only one frame, this event is dispatched
 *                         continuously in conjunction with the frame rate.
 *                         This event is a broadcast event, which means that
 *                         it is dispatched by all display objects with a
 *                         listener registered for this event.
 * @event frameConstructed [broadcast event] Dispatched after the constructors
 *                         of frame display objects have run but before frame
 *                         scripts have run. If the playhead is not moving, or
 *                         if there is only one frame, this event is
 *                         dispatched continuously in conjunction with the
 *                         frame rate. This event is a broadcast event, which
 *                         means that it is dispatched by all display objects
 *                         with a listener registered for this event.
 * @event removed          Dispatched when a display object is about to be
 *                         removed from the display list. Two methods of the
 *                         DisplayObjectContainer class generate this event:
 *                         <code>removeChild()</code> and
 *                         <code>removeChildAt()</code>.
 *
 *                         <p>The following methods of a
 *                         DisplayObjectContainer object also generate this
 *                         event if an object must be removed to make room for
 *                         the new object: <code>addChild()</code>,
 *                         <code>addChildAt()</code>, and
 *                         <code>setChildIndex()</code>. </p>
 * @event removedFromStage Dispatched when a display object is about to be
 *                         removed from the display list, either directly or
 *                         through the removal of a sub tree in which the
 *                         display object is contained. Two methods of the
 *                         DisplayObjectContainer class generate this event:
 *                         <code>removeChild()</code> and
 *                         <code>removeChildAt()</code>.
 *
 *                         <p>The following methods of a
 *                         DisplayObjectContainer object also generate this
 *                         event if an object must be removed to make room for
 *                         the new object: <code>addChild()</code>,
 *                         <code>addChildAt()</code>, and
 *                         <code>setChildIndex()</code>. </p>
 * @event render           [broadcast event] Dispatched when the display list
 *                         is about to be updated and rendered. This event
 *                         provides the last opportunity for objects listening
 *                         for this event to make changes before the display
 *                         list is rendered. You must call the
 *                         <code>invalidate()</code> method of the Stage
 *                         object each time you want a <code>render</code>
 *                         event to be dispatched. <code>Render</code> events
 *                         are dispatched to an object only if there is mutual
 *                         trust between it and the object that called
 *                         <code>Stage.invalidate()</code>. This event is a
 *                         broadcast event, which means that it is dispatched
 *                         by all display objects with a listener registered
 *                         for this event.
 *
 *                         <p><b>Note: </b>This event is not dispatched if the
 *                         display is not rendering. This is the case when the
 *                         content is either minimized or obscured. </p>
 */
var DisplayObject = (function (_super) {
    __extends(DisplayObject, _super);
    /**
     * Creates a new <code>DisplayObject</code> instance.
     */
    function DisplayObject() {
        _super.call(this);
        this._pSceneTransform = new Matrix3D();
        this._pSceneTransformDirty = true;
        this._matrix3D = new Matrix3D();
        this._matrix3DDirty = true;
        this._inverseSceneTransform = new Matrix3D();
        this._inverseSceneTransformDirty = true;
        this._scenePosition = new Vector3D();
        this._scenePositionDirty = true;
        this._explicitVisibility = true;
        this._pImplicitVisibility = true;
        this._explicitMouseEnabled = true;
        this._pImplicitMouseEnabled = true;
        this._positionDirty = true;
        this._rotationDirty = true;
        this._scaleDirty = true;
        this._rotationX = 0;
        this._rotationY = 0;
        this._rotationZ = 0;
        this._eulers = new Vector3D();
        this._flipY = new Matrix3D();
        this._zOffset = 0;
        this._pScaleX = 1;
        this._pScaleY = 1;
        this._pScaleZ = 1;
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._pivot = new Vector3D();
        this._orientationMatrix = new Matrix3D();
        this._pivotZero = true;
        this._pivotDirty = true;
        this._pos = new Vector3D();
        this._rot = new Vector3D();
        this._sca = new Vector3D();
        this._pIgnoreTransform = false;
        this._pBoundsInvalid = true;
        this._worldBoundsInvalid = true;
        this._pRenderables = new Array();
        /**
         *
         */
        this.alignmentMode = AlignmentMode.REGISTRATION_POINT;
        /**
         *
         */
        this.castsShadows = true;
        /**
         *
         */
        this.orientationMode = OrientationMode.DEFAULT;
        // Cached vector of transformation components used when
        // recomposing the transform matrix in updateTransform()
        this._transformComponents = new Array(3); //_transformComponents = new Vector.<Vector3D>(3, true);
        this._transformComponents[0] = this._pos;
        this._transformComponents[1] = this._rot;
        this._transformComponents[2] = this._sca;
        //creation of associated transform object
        this._transform = new Transform(this);
        this._matrix3D.identity();
        this._flipY.appendScale(1, -1, 1);
        this._pBounds = this.pCreateDefaultBoundingVolume();
        this._worldBounds = this.pCreateDefaultBoundingVolume();
    }
    Object.defineProperty(DisplayObject.prototype, "bounds", {
        /**
         *
         */
        get: function () {
            if (this._pBoundsInvalid)
                this.pUpdateBounds();
            return this._pBounds;
        },
        set: function (value) {
            if (this._pBounds == value)
                return;
            this._pBounds = value;
            this._worldBounds = value.clone();
            this.pInvalidateBounds();
            if (this._boundsVisible)
                this._partitionNode._iUpdateEntityBounds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "depth", {
        /**
         * Indicates the depth of the display object, in pixels. The depth is
         * calculated based on the bounds of the content of the display object. When
         * you set the <code>depth</code> property, the <code>scaleZ</code> property
         * is adjusted accordingly, as shown in the following code:
         *
         * <p>Except for TextField and Video objects, a display object with no
         * content (such as an empty sprite) has a depth of 0, even if you try to
         * set <code>depth</code> to a different value.</p>
         */
        get: function () {
            if (this._pBoundsInvalid)
                this.pUpdateBounds();
            return this._depth;
        },
        set: function (val) {
            if (this._depth == val)
                return;
            this._depth == val;
            this._pScaleZ = val / this.bounds.aabb.depth;
            this.invalidateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "eulers", {
        /**
         * Defines the rotation of the 3d object as a <code>Vector3D</code> object containing euler angles for rotation around x, y and z axis.
         */
        get: function () {
            this._eulers.x = this._rotationX * MathConsts.RADIANS_TO_DEGREES;
            this._eulers.y = this._rotationY * MathConsts.RADIANS_TO_DEGREES;
            this._eulers.z = this._rotationZ * MathConsts.RADIANS_TO_DEGREES;
            return this._eulers;
        },
        set: function (value) {
            this._rotationX = value.x * MathConsts.DEGREES_TO_RADIANS;
            this._rotationY = value.y * MathConsts.DEGREES_TO_RADIANS;
            this._rotationZ = value.z * MathConsts.DEGREES_TO_RADIANS;
            this.invalidateRotation();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "height", {
        /**
         * An indexed array that contains each filter object currently associated
         * with the display object. The flash.filters package contains several
         * classes that define specific filters you can use.
         *
         * <p>Filters can be applied in Flash Professional at design time, or at run
         * time by using ActionScript code. To apply a filter by using ActionScript,
         * you must make a temporary copy of the entire <code>filters</code> array,
         * modify the temporary array, then assign the value of the temporary array
         * back to the <code>filters</code> array. You cannot directly add a new
         * filter object to the <code>filters</code> array.</p>
         *
         * <p>To add a filter by using ActionScript, perform the following steps
         * (assume that the target display object is named
         * <code>myDisplayObject</code>):</p>
         *
         * <ol>
         *   <li>Create a new filter object by using the constructor method of your
         * chosen filter class.</li>
         *   <li>Assign the value of the <code>myDisplayObject.filters</code> array
         * to a temporary array, such as one named <code>myFilters</code>.</li>
         *   <li>Add the new filter object to the <code>myFilters</code> temporary
         * array.</li>
         *   <li>Assign the value of the temporary array to the
         * <code>myDisplayObject.filters</code> array.</li>
         * </ol>
         *
         * <p>If the <code>filters</code> array is undefined, you do not need to use
         * a temporary array. Instead, you can directly assign an array literal that
         * contains one or more filter objects that you create. The first example in
         * the Examples section adds a drop shadow filter by using code that handles
         * both defined and undefined <code>filters</code> arrays.</p>
         *
         * <p>To modify an existing filter object, you must use the technique of
         * modifying a copy of the <code>filters</code> array:</p>
         *
         * <ol>
         *   <li>Assign the value of the <code>filters</code> array to a temporary
         * array, such as one named <code>myFilters</code>.</li>
         *   <li>Modify the property by using the temporary array,
         * <code>myFilters</code>. For example, to set the quality property of the
         * first filter in the array, you could use the following code:
         * <code>myFilters[0].quality = 1;</code></li>
         *   <li>Assign the value of the temporary array to the <code>filters</code>
         * array.</li>
         * </ol>
         *
         * <p>At load time, if a display object has an associated filter, it is
         * marked to cache itself as a transparent bitmap. From this point forward,
         * as long as the display object has a valid filter list, the player caches
         * the display object as a bitmap. This source bitmap is used as a source
         * image for the filter effects. Each display object usually has two bitmaps:
         * one with the original unfiltered source display object and another for the
         * final image after filtering. The final image is used when rendering. As
         * long as the display object does not change, the final image does not need
         * updating.</p>
         *
         * <p>The flash.filters package includes classes for filters. For example, to
         * create a DropShadow filter, you would write:</p>
         *
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
         *                       and the shader output type is not compatible with
         *                       this operation(the shader must specify a
         *                       <code>pixel4</code> output).
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
         *                       and the shader doesn't specify any image input or
         *                       the first input is not an <code>image4</code> input.
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
         *                       and the shader specifies an image input that isn't
         *                       provided.
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter, a
         *                       ByteArray or Vector.<Number> instance as a shader
         *                       input, and the <code>width</code> and
         *                       <code>height</code> properties aren't specified for
         *                       the ShaderInput object, or the specified values
         *                       don't match the amount of data in the input data.
         *                       See the <code>ShaderInput.input</code> property for
         *                       more information.
         */
        //		public filters:Array<Dynamic>;
        /**
         * Indicates the height of the display object, in pixels. The height is
         * calculated based on the bounds of the content of the display object. When
         * you set the <code>height</code> property, the <code>scaleY</code> property
         * is adjusted accordingly, as shown in the following code:
         *
         * <p>Except for TextField and Video objects, a display object with no
         * content (such as an empty sprite) has a height of 0, even if you try to
         * set <code>height</code> to a different value.</p>
         */
        get: function () {
            if (this._pBoundsInvalid)
                this.pUpdateBounds();
            return this._height;
        },
        set: function (val) {
            if (this._height == val)
                return;
            this._height == val;
            this._pScaleY = val / this.bounds.aabb.height;
            this.invalidateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "index", {
        /**
         * Indicates the instance container index of the DisplayObject. The object can be
         * identified in the child list of its parent display object container by
         * calling the <code>getChildByIndex()</code> method of the display object
         * container.
         *
         * <p>If the DisplayObject has no parent container, index defaults to 0.</p>
         */
        get: function () {
            if (this._pParent)
                return this._pParent.getChildIndex(this);
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "inverseSceneTransform", {
        /**
         *
         */
        get: function () {
            if (this._inverseSceneTransformDirty) {
                this._inverseSceneTransform.copyFrom(this.sceneTransform);
                this._inverseSceneTransform.invert();
                this._inverseSceneTransformDirty = false;
            }
            return this._inverseSceneTransform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "ignoreTransform", {
        /**
         *
         */
        get: function () {
            return this._pIgnoreTransform;
        },
        set: function (value) {
            if (this._pIgnoreTransform == value)
                return;
            this._pIgnoreTransform = value;
            if (value) {
                this._pSceneTransform.identity();
                this._scenePosition.setTo(0, 0, 0);
            }
            this.pInvalidateSceneTransform();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "isEntity", {
        /**
         *
         */
        get: function () {
            return this._pIsEntity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "loaderInfo", {
        /**
         * Returns a LoaderInfo object containing information about loading the file
         * to which this display object belongs. The <code>loaderInfo</code> property
         * is defined only for the root display object of a SWF file or for a loaded
         * Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
         * <code>loaderInfo</code> object associated with the SWF file that contains
         * a display object named <code>myDisplayObject</code>, use
         * <code>myDisplayObject.root.loaderInfo</code>.
         *
         * <p>A large SWF file can monitor its download by calling
         * <code>this.root.loaderInfo.addEventListener(Event.COMPLETE,
         * func)</code>.</p>
         */
        get: function () {
            return this._loaderInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "mouseEnabled", {
        /**
         * Specifies whether this object receives mouse, or other user input,
         * messages. The default value is <code>true</code>, which means that by
         * default any InteractiveObject instance that is on the display list
         * receives mouse events or other user input events. If
         * <code>mouseEnabled</code> is set to <code>false</code>, the instance does
         * not receive any mouse events(or other user input events like keyboard
         * events). Any children of this instance on the display list are not
         * affected. To change the <code>mouseEnabled</code> behavior for all
         * children of an object on the display list, use
         * <code>flash.display.DisplayObjectContainer.mouseChildren</code>.
         *
         * <p> No event is dispatched by setting this property. You must use the
         * <code>addEventListener()</code> method to create interactive
         * functionality.</p>
         */
        get: function () {
            return this._explicitMouseEnabled;
        },
        set: function (value) {
            if (this._explicitMouseEnabled == value)
                return;
            this._explicitMouseEnabled = value;
            this._pUpdateImplicitMouseEnabled(this._pParent ? this._pParent.mouseChildren : true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "mouseX", {
        /**
         * Indicates the x coordinate of the mouse or user input device position, in
         * pixels.
         *
         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x
         * coordinate will reflect the non-rotated object.</p>
         */
        get: function () {
            return this._mouseX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "mouseY", {
        /**
         * Indicates the y coordinate of the mouse or user input device position, in
         * pixels.
         *
         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y
         * coordinate will reflect the non-rotated object.</p>
         */
        get: function () {
            return this._mouseY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "parent", {
        /**
         * Indicates the DisplayObjectContainer object that contains this display
         * object. Use the <code>parent</code> property to specify a relative path to
         * display objects that are above the current display object in the display
         * list hierarchy.
         *
         * <p>You can use <code>parent</code> to move up multiple levels in the
         * display list as in the following:</p>
         *
         * @throws SecurityError The parent display object belongs to a security
         *                       sandbox to which you do not have access. You can
         *                       avoid this situation by having the parent movie call
         *                       the <code>Security.allowDomain()</code> method.
         */
        get: function () {
            return this._pParent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "partition", {
        /**
         *
         */
        get: function () {
            return this._explicitPartition;
        },
        set: function (value) {
            if (this._explicitPartition == value)
                return;
            if (this._pScene && this._explicitPartition)
                this._pScene.iUnregisterPartition(this._explicitPartition);
            this._explicitPartition = value;
            if (this._pScene && value)
                this._pScene.iRegisterPartition(value);
            this._pUpdateImplicitPartition(this._pParent ? this._pParent._iAssignedPartition : null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "partitionNode", {
        /**
         *
         */
        get: function () {
            if (!this._partitionNode)
                this._partitionNode = this.pCreateEntityPartitionNode();
            return this._partitionNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "pickingCollider", {
        /**
         *
         */
        get: function () {
            return this._pPickingCollider;
        },
        set: function (value) {
            this._pPickingCollider = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "pivot", {
        /**
         * Defines the local point around which the object rotates.
         */
        get: function () {
            return this._pivot;
        },
        set: function (pivot) {
            this._pivot = pivot.clone();
            this.invalidatePivot();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "root", {
        /**
         * For a display object in a loaded SWF file, the <code>root</code> property
         * is the top-most display object in the portion of the display list's tree
         * structure represented by that SWF file. For a Bitmap object representing a
         * loaded image file, the <code>root</code> property is the Bitmap object
         * itself. For the instance of the main class of the first SWF file loaded,
         * the <code>root</code> property is the display object itself. The
         * <code>root</code> property of the Stage object is the Stage object itself.
         * The <code>root</code> property is set to <code>null</code> for any display
         * object that has not been added to the display list, unless it has been
         * added to a display object container that is off the display list but that
         * is a child of the top-most display object in a loaded SWF file.
         *
         * <p>For example, if you create a new Sprite object by calling the
         * <code>Sprite()</code> constructor method, its <code>root</code> property
         * is <code>null</code> until you add it to the display list(or to a display
         * object container that is off the display list but that is a child of the
         * top-most display object in a SWF file).</p>
         *
         * <p>For a loaded SWF file, even though the Loader object used to load the
         * file may not be on the display list, the top-most display object in the
         * SWF file has its <code>root</code> property set to itself. The Loader
         * object does not have its <code>root</code> property set until it is added
         * as a child of a display object for which the <code>root</code> property is
         * set.</p>
         */
        get: function () {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "rotationX", {
        /**
         * Indicates the x-axis rotation of the DisplayObject instance, in degrees,
         * from its original orientation relative to the 3D parent container. Values
         * from 0 to 180 represent clockwise rotation; values from 0 to -180
         * represent counterclockwise rotation. Values outside this range are added
         * to or subtracted from 360 to obtain a value within the range.
         */
        get: function () {
            return this._rotationX * MathConsts.RADIANS_TO_DEGREES;
        },
        set: function (val) {
            if (this.rotationX == val)
                return;
            this._rotationX = val * MathConsts.DEGREES_TO_RADIANS;
            this.invalidateRotation();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "rotationY", {
        /**
         * Indicates the y-axis rotation of the DisplayObject instance, in degrees,
         * from its original orientation relative to the 3D parent container. Values
         * from 0 to 180 represent clockwise rotation; values from 0 to -180
         * represent counterclockwise rotation. Values outside this range are added
         * to or subtracted from 360 to obtain a value within the range.
         */
        get: function () {
            return this._rotationY * MathConsts.RADIANS_TO_DEGREES;
        },
        set: function (val) {
            if (this.rotationY == val)
                return;
            this._rotationY = val * MathConsts.DEGREES_TO_RADIANS;
            this.invalidateRotation();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "rotationZ", {
        /**
         * Indicates the z-axis rotation of the DisplayObject instance, in degrees,
         * from its original orientation relative to the 3D parent container. Values
         * from 0 to 180 represent clockwise rotation; values from 0 to -180
         * represent counterclockwise rotation. Values outside this range are added
         * to or subtracted from 360 to obtain a value within the range.
         */
        get: function () {
            return this._rotationZ * MathConsts.RADIANS_TO_DEGREES;
        },
        set: function (val) {
            if (this.rotationZ == val)
                return;
            this._rotationZ = val * MathConsts.DEGREES_TO_RADIANS;
            this.invalidateRotation();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scaleX", {
        /**
         * Indicates the horizontal scale(percentage) of the object as applied from
         * the registration point. The default registration point is(0,0). 1.0
         * equals 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code> and
         * <code>y</code> property values, which are defined in whole pixels. </p>
         */
        get: function () {
            return this._pScaleX;
        },
        set: function (val) {
            if (this._pScaleX == val)
                return;
            this._pScaleX = val;
            this.invalidateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scaleY", {
        /**
         * Indicates the vertical scale(percentage) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         * 1.0 is 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code> and
         * <code>y</code> property values, which are defined in whole pixels. </p>
         */
        get: function () {
            return this._pScaleY;
        },
        set: function (val) {
            if (this._pScaleY == val)
                return;
            this._pScaleY = val;
            this.invalidateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scaleZ", {
        /**
         * Indicates the depth scale(percentage) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         * 1.0 is 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code>,
         * <code>y</code> and <code>z</code> property values, which are defined in
         * whole pixels. </p>
         */
        get: function () {
            return this._pScaleZ;
        },
        set: function (val) {
            if (this._pScaleZ == val)
                return;
            this._pScaleZ = val;
            this.invalidateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scene", {
        /**
         *
         */
        get: function () {
            return this._pScene;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scenePosition", {
        /**
         *
         */
        get: function () {
            if (this._scenePositionDirty) {
                if (!this._pivotZero && this.alignmentMode == AlignmentMode.PIVOT_POINT) {
                    var pivotScale = new Vector3D(this._pivot.x / this._pScaleX, this._pivot.y / this._pScaleY, this._pivot.z / this._pScaleZ);
                    this._scenePosition = this.sceneTransform.transformVector(pivotScale);
                }
                else {
                    this.sceneTransform.copyColumnTo(3, this._scenePosition);
                }
                this._scenePositionDirty = false;
            }
            return this._scenePosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "sceneTransform", {
        get: function () {
            if (this._pSceneTransformDirty)
                this.pUpdateSceneTransform();
            return this._pSceneTransform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "shaderPickingDetails", {
        /**
         *
         */
        get: function () {
            return this._shaderPickingDetails;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "boundsVisible", {
        /**
         *
         */
        get: function () {
            return this._boundsVisible;
        },
        set: function (value) {
            if (value == this._boundsVisible)
                return;
            this._boundsVisible = value;
            this._partitionNode.boundsVisible = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "transform", {
        /**
         * An object with properties pertaining to a display object's matrix, color
         * transform, and pixel bounds. The specific properties  -  matrix,
         * colorTransform, and three read-only properties
         * (<code>concatenatedMatrix</code>, <code>concatenatedColorTransform</code>,
         * and <code>pixelBounds</code>)  -  are described in the entry for the
         * Transform class.
         *
         * <p>Each of the transform object's properties is itself an object. This
         * concept is important because the only way to set new values for the matrix
         * or colorTransform objects is to create a new object and copy that object
         * into the transform.matrix or transform.colorTransform property.</p>
         *
         * <p>For example, to increase the <code>tx</code> value of a display
         * object's matrix, you must make a copy of the entire matrix object, then
         * copy the new object into the matrix property of the transform object:</p>
         * <pre xml:space="preserve"><code> public myMatrix:Matrix =
         * myDisplayObject.transform.matrix; myMatrix.tx += 10;
         * myDisplayObject.transform.matrix = myMatrix; </code></pre>
         *
         * <p>You cannot directly set the <code>tx</code> property. The following
         * code has no effect on <code>myDisplayObject</code>: </p>
         * <pre xml:space="preserve"><code> myDisplayObject.transform.matrix.tx +=
         * 10; </code></pre>
         *
         * <p>You can also copy an entire transform object and assign it to another
         * display object's transform property. For example, the following code
         * copies the entire transform object from <code>myOldDisplayObj</code> to
         * <code>myNewDisplayObj</code>:</p>
         * <code>myNewDisplayObj.transform = myOldDisplayObj.transform;</code>
         *
         * <p>The resulting display object, <code>myNewDisplayObj</code>, now has the
         * same values for its matrix, color transform, and pixel bounds as the old
         * display object, <code>myOldDisplayObj</code>.</p>
         *
         * <p>Note that AIR for TV devices use hardware acceleration, if it is
         * available, for color transforms.</p>
         */
        get: function () {
            return this._transform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "visible", {
        /**
         * Whether or not the display object is visible. Display objects that are not
         * visible are disabled. For example, if <code>visible=false</code> for an
         * InteractiveObject instance, it cannot be clicked.
         */
        get: function () {
            return this._explicitVisibility;
        },
        set: function (value) {
            if (this._explicitVisibility == value)
                return;
            this._explicitVisibility = value;
            this._pUpdateImplicitVisibility(this._pParent ? this._pParent._iIsVisible() : true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "width", {
        /**
         * Indicates the width of the display object, in pixels. The width is
         * calculated based on the bounds of the content of the display object. When
         * you set the <code>width</code> property, the <code>scaleX</code> property
         * is adjusted accordingly, as shown in the following code:
         *
         * <p>Except for TextField and Video objects, a display object with no
         * content(such as an empty sprite) has a width of 0, even if you try to set
         * <code>width</code> to a different value.</p>
         */
        get: function () {
            if (this._pBoundsInvalid)
                this.pUpdateBounds();
            return this._width;
        },
        set: function (val) {
            if (this._width == val)
                return;
            this._width == val;
            this._pScaleX = val / this.bounds.aabb.width;
            this.invalidateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "worldBounds", {
        /**
         *
         */
        get: function () {
            // Since this getter is invoked every iteration of the render loop, and
            // the prefab construct could affect the bounds of the entity, the prefab is
            // validated here to give it a chance to rebuild.
            if (this._iSourcePrefab)
                this._iSourcePrefab._iValidate();
            if (this._worldBoundsInvalid) {
                this._worldBoundsInvalid = false;
                this._worldBounds.transformFrom(this.bounds, this.sceneTransform);
            }
            return this._worldBounds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "x", {
        /**
         * Indicates the <i>x</i> coordinate of the DisplayObject instance relative
         * to the local coordinates of the parent DisplayObjectContainer. If the
         * object is inside a DisplayObjectContainer that has transformations, it is
         * in the local coordinate system of the enclosing DisplayObjectContainer.
         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
         * DisplayObjectContainer's children inherit a coordinate system that is
         * rotated 90° counterclockwise. The object's coordinates refer to the
         * registration point position.
         */
        get: function () {
            return this._x;
        },
        set: function (val) {
            if (this._x == val)
                return;
            this._x = val;
            this.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "y", {
        /**
         * Indicates the <i>y</i> coordinate of the DisplayObject instance relative
         * to the local coordinates of the parent DisplayObjectContainer. If the
         * object is inside a DisplayObjectContainer that has transformations, it is
         * in the local coordinate system of the enclosing DisplayObjectContainer.
         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
         * DisplayObjectContainer's children inherit a coordinate system that is
         * rotated 90° counterclockwise. The object's coordinates refer to the
         * registration point position.
         */
        get: function () {
            return this._y;
        },
        set: function (val) {
            if (this._y == val)
                return;
            this._y = val;
            this.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "z", {
        /**
         * Indicates the z coordinate position along the z-axis of the DisplayObject
         * instance relative to the 3D parent container. The z property is used for
         * 3D coordinates, not screen or pixel coordinates.
         *
         * <p>When you set a <code>z</code> property for a display object to
         * something other than the default value of <code>0</code>, a corresponding
         * Matrix3D object is automatically created. for adjusting a display object's
         * position and orientation in three dimensions. When working with the
         * z-axis, the existing behavior of x and y properties changes from screen or
         * pixel coordinates to positions relative to the 3D parent container.</p>
         *
         * <p>For example, a child of the <code>_root</code> at position x = 100, y =
         * 100, z = 200 is not drawn at pixel location(100,100). The child is drawn
         * wherever the 3D projection calculation puts it. The calculation is:</p>
         *
         * <p><code>(x~~cameraFocalLength/cameraRelativeZPosition,
         * y~~cameraFocalLength/cameraRelativeZPosition)</code></p>
         */
        get: function () {
            return this._z;
        },
        set: function (val) {
            if (this._z == val)
                return;
            this._z = val;
            this.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "zOffset", {
        /**
         *
         */
        get: function () {
            return this._zOffset;
        },
        set: function (value) {
            this._zOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    DisplayObject.prototype.addEventListener = function (type, listener) {
        _super.prototype.addEventListener.call(this, type, listener);
        switch (type) {
            case DisplayObjectEvent.POSITION_CHANGED:
                this._listenToPositionChanged = true;
                break;
            case DisplayObjectEvent.ROTATION_CHANGED:
                this._listenToRotationChanged = true;
                break;
            case DisplayObjectEvent.SCALE_CHANGED:
                this._listenToScaleChanged = true;
                break;
        }
    };
    /**
     *
     */
    DisplayObject.prototype.clone = function () {
        var clone = new DisplayObject();
        clone.pivot = this.pivot;
        clone._iMatrix3D = this._iMatrix3D;
        clone.name = name;
        // todo: implement for all subtypes
        return clone;
    };
    /**
     *
     */
    DisplayObject.prototype.dispose = function () {
        if (this.parent)
            this.parent.removeChild(this);
        while (this._pRenderables.length)
            this._pRenderables[0].dispose();
    };
    /**
     * @inheritDoc
     */
    DisplayObject.prototype.disposeAsset = function () {
        this.dispose();
    };
    /**
     * Returns a rectangle that defines the area of the display object relative
     * to the coordinate system of the <code>targetCoordinateSpace</code> object.
     * Consider the following code, which shows how the rectangle returned can
     * vary depending on the <code>targetCoordinateSpace</code> parameter that
     * you pass to the method:
     *
     * <p><b>Note:</b> Use the <code>localToGlobal()</code> and
     * <code>globalToLocal()</code> methods to convert the display object's local
     * coordinates to display coordinates, or display coordinates to local
     * coordinates, respectively.</p>
     *
     * <p>The <code>getBounds()</code> method is similar to the
     * <code>getRect()</code> method; however, the Rectangle returned by the
     * <code>getBounds()</code> method includes any strokes on shapes, whereas
     * the Rectangle returned by the <code>getRect()</code> method does not. For
     * an example, see the description of the <code>getRect()</code> method.</p>
     *
     * @param targetCoordinateSpace The display object that defines the
     *                              coordinate system to use.
     * @return The rectangle that defines the area of the display object relative
     *         to the <code>targetCoordinateSpace</code> object's coordinate
     *         system.
     */
    DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
        return this._bounds; //TODO
    };
    /**
     * Returns a rectangle that defines the boundary of the display object, based
     * on the coordinate system defined by the <code>targetCoordinateSpace</code>
     * parameter, excluding any strokes on shapes. The values that the
     * <code>getRect()</code> method returns are the same or smaller than those
     * returned by the <code>getBounds()</code> method.
     *
     * <p><b>Note:</b> Use <code>localToGlobal()</code> and
     * <code>globalToLocal()</code> methods to convert the display object's local
     * coordinates to Stage coordinates, or Stage coordinates to local
     * coordinates, respectively.</p>
     *
     * @param targetCoordinateSpace The display object that defines the
     *                              coordinate system to use.
     * @return The rectangle that defines the area of the display object relative
     *         to the <code>targetCoordinateSpace</code> object's coordinate
     *         system.
     */
    DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
        return this._bounds; //TODO
    };
    /**
     * Converts the <code>point</code> object from the Stage(global) coordinates
     * to the display object's(local) coordinates.
     *
     * <p>To use this method, first create an instance of the Point class. The
     * <i>x</i> and <i>y</i> values that you assign represent global coordinates
     * because they relate to the origin(0,0) of the main display area. Then
     * pass the Point instance as the parameter to the
     * <code>globalToLocal()</code> method. The method returns a new Point object
     * with <i>x</i> and <i>y</i> values that relate to the origin of the display
     * object instead of the origin of the Stage.</p>
     *
     * @param point An object created with the Point class. The Point object
     *              specifies the <i>x</i> and <i>y</i> coordinates as
     *              properties.
     * @return A Point object with coordinates relative to the display object.
     */
    DisplayObject.prototype.globalToLocal = function (point) {
        return point; //TODO
    };
    /**
     * Converts a two-dimensional point from the Stage(global) coordinates to a
     * three-dimensional display object's(local) coordinates.
     *
     * <p>To use this method, first create an instance of the Point class. The x
     * and y values that you assign to the Point object represent global
     * coordinates because they are relative to the origin(0,0) of the main
     * display area. Then pass the Point object to the
     * <code>globalToLocal3D()</code> method as the <code>point</code> parameter.
     * The method returns three-dimensional coordinates as a Vector3D object
     * containing <code>x</code>, <code>y</code>, and <code>z</code> values that
     * are relative to the origin of the three-dimensional display object.</p>
     *
     * @param point A two dimensional Point object representing global x and y
     *              coordinates.
     * @return A Vector3D object with coordinates relative to the
     *         three-dimensional display object.
     */
    DisplayObject.prototype.globalToLocal3D = function (point) {
        return new Vector3D(); //TODO
    };
    /**
     * Evaluates the bounding box of the display object to see if it overlaps or
     * intersects with the bounding box of the <code>obj</code> display object.
     *
     * @param obj The display object to test against.
     * @return <code>true</code> if the bounding boxes of the display objects
     *         intersect; <code>false</code> if not.
     */
    DisplayObject.prototype.hitTestObject = function (obj) {
        return false; //TODO
    };
    /**
     * Evaluates the display object to see if it overlaps or intersects with the
     * point specified by the <code>x</code> and <code>y</code> parameters. The
     * <code>x</code> and <code>y</code> parameters specify a point in the
     * coordinate space of the Stage, not the display object container that
     * contains the display object(unless that display object container is the
     * Stage).
     *
     * @param x         The <i>x</i> coordinate to test against this object.
     * @param y         The <i>y</i> coordinate to test against this object.
     * @param shapeFlag Whether to check against the actual pixels of the object
     *                 (<code>true</code>) or the bounding box
     *                 (<code>false</code>).
     * @return <code>true</code> if the display object overlaps or intersects
     *         with the specified point; <code>false</code> otherwise.
     */
    DisplayObject.prototype.hitTestPoint = function (x, y, shapeFlag) {
        if (shapeFlag === void 0) { shapeFlag = false; }
        return false; //TODO
    };
    /**
     * @inheritDoc
     */
    DisplayObject.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
        var localRayPosition = this.inverseSceneTransform.transformVector(rayPosition);
        var localRayDirection = this.inverseSceneTransform.deltaTransformVector(rayDirection);
        var pickingCollisionVO = this._iPickingCollisionVO;
        if (!pickingCollisionVO.localNormal)
            pickingCollisionVO.localNormal = new Vector3D();
        var rayEntryDistance = this.bounds.rayIntersection(localRayPosition, localRayDirection, pickingCollisionVO.localNormal);
        if (rayEntryDistance < 0)
            return false;
        pickingCollisionVO.rayEntryDistance = rayEntryDistance;
        pickingCollisionVO.localRayPosition = localRayPosition;
        pickingCollisionVO.localRayDirection = localRayDirection;
        pickingCollisionVO.rayPosition = rayPosition;
        pickingCollisionVO.rayDirection = rayDirection;
        pickingCollisionVO.rayOriginIsInsideBounds = rayEntryDistance == 0;
        return true;
    };
    /**
     * Converts a three-dimensional point of the three-dimensional display
     * object's(local) coordinates to a two-dimensional point in the Stage
     * (global) coordinates.
     *
     * <p>For example, you can only use two-dimensional coordinates(x,y) to draw
     * with the <code>display.Graphics</code> methods. To draw a
     * three-dimensional object, you need to map the three-dimensional
     * coordinates of a display object to two-dimensional coordinates. First,
     * create an instance of the Vector3D class that holds the x-, y-, and z-
     * coordinates of the three-dimensional display object. Then pass the
     * Vector3D object to the <code>local3DToGlobal()</code> method as the
     * <code>point3d</code> parameter. The method returns a two-dimensional Point
     * object that can be used with the Graphics API to draw the
     * three-dimensional object.</p>
     *
     * @param point3d A Vector3D object containing either a three-dimensional
     *                point or the coordinates of the three-dimensional display
     *                object.
     * @return A two-dimensional point representing a three-dimensional point in
     *         two-dimensional space.
     */
    DisplayObject.prototype.local3DToGlobal = function (point3d) {
        return new Point(); //TODO
    };
    /**
     * Rotates the 3d object around to face a point defined relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
     *
     * @param    target        The vector defining the point to be looked at
     * @param    upAxis        An optional vector used to define the desired up orientation of the 3d object after rotation has occurred
     */
    DisplayObject.prototype.lookAt = function (target, upAxis) {
        if (upAxis === void 0) { upAxis = null; }
        var yAxis;
        var zAxis;
        var xAxis;
        var raw;
        if (upAxis == null)
            upAxis = Vector3D.Y_AXIS;
        else
            upAxis.normalize();
        zAxis = target.subtract(this._iMatrix3D.position);
        zAxis.normalize();
        xAxis = upAxis.crossProduct(zAxis);
        xAxis.normalize();
        if (xAxis.length < 0.05) {
            xAxis.x = upAxis.y;
            xAxis.y = upAxis.x;
            xAxis.z = 0;
            xAxis.normalize();
        }
        yAxis = zAxis.crossProduct(xAxis);
        raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        raw[0] = xAxis.x;
        raw[1] = xAxis.y;
        raw[2] = xAxis.z;
        raw[3] = 0;
        raw[4] = yAxis.x;
        raw[5] = yAxis.y;
        raw[6] = yAxis.z;
        raw[7] = 0;
        raw[8] = zAxis.x;
        raw[9] = zAxis.y;
        raw[10] = zAxis.z;
        raw[11] = 0;
        var m = new Matrix3D();
        m.copyRawDataFrom(raw);
        var vec = m.decompose()[1];
        this._rotationX = vec.x;
        this._rotationY = vec.y;
        this._rotationZ = vec.z;
        this.invalidateRotation();
    };
    /**
     * Converts the <code>point</code> object from the display object's(local)
     * coordinates to the Stage(global) coordinates.
     *
     * <p>This method allows you to convert any given <i>x</i> and <i>y</i>
     * coordinates from values that are relative to the origin(0,0) of a
     * specific display object(local coordinates) to values that are relative to
     * the origin of the Stage(global coordinates).</p>
     *
     * <p>To use this method, first create an instance of the Point class. The
     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
     * because they relate to the origin of the display object.</p>
     *
     * <p>You then pass the Point instance that you created as the parameter to
     * the <code>localToGlobal()</code> method. The method returns a new Point
     * object with <i>x</i> and <i>y</i> values that relate to the origin of the
     * Stage instead of the origin of the display object.</p>
     *
     * @param point The name or identifier of a point created with the Point
     *              class, specifying the <i>x</i> and <i>y</i> coordinates as
     *              properties.
     * @return A Point object with coordinates relative to the Stage.
     */
    DisplayObject.prototype.localToGlobal = function (point) {
        return new Point(); //TODO
    };
    /**
     * Moves the 3d object directly to a point in space
     *
     * @param    dx        The amount of movement along the local x axis.
     * @param    dy        The amount of movement along the local y axis.
     * @param    dz        The amount of movement along the local z axis.
     */
    DisplayObject.prototype.moveTo = function (dx, dy, dz) {
        if (this._x == dx && this._y == dy && this._z == dz)
            return;
        this._x = dx;
        this._y = dy;
        this._z = dz;
        this.invalidatePosition();
    };
    /**
     * Moves the local point around which the object rotates.
     *
     * @param    dx        The amount of movement along the local x axis.
     * @param    dy        The amount of movement along the local y axis.
     * @param    dz        The amount of movement along the local z axis.
     */
    DisplayObject.prototype.movePivot = function (dx, dy, dz) {
        if (this._pivot == null)
            this._pivot = new Vector3D();
        this._pivot.x += dx;
        this._pivot.y += dy;
        this._pivot.z += dz;
        this.invalidatePivot();
    };
    /**
     * Rotates the 3d object around it's local x-axis
     *
     * @param    angle        The amount of rotation in degrees
     */
    DisplayObject.prototype.pitch = function (angle) {
        this.rotate(Vector3D.X_AXIS, angle);
    };
    /**
     *
     */
    DisplayObject.prototype.getRenderSceneTransform = function (camera) {
        if (this.orientationMode == OrientationMode.CAMERA_PLANE) {
            var comps = camera.sceneTransform.decompose();
            var scale = comps[2];
            comps[0] = this.scenePosition;
            scale.x = this._pScaleX;
            scale.y = this._pScaleY;
            scale.z = this._pScaleZ;
            this._orientationMatrix.recompose(comps);
            //add in case of pivot
            if (!this._pivotZero && this.alignmentMode == AlignmentMode.PIVOT_POINT)
                this._orientationMatrix.prependTranslation(-this._pivot.x / this._pScaleX, -this._pivot.y / this._pScaleY, -this._pivot.z / this._pScaleZ);
            return this._orientationMatrix;
        }
        return this.sceneTransform;
    };
    /**
     * Rotates the 3d object around it's local z-axis
     *
     * @param    angle        The amount of rotation in degrees
     */
    DisplayObject.prototype.roll = function (angle) {
        this.rotate(Vector3D.Z_AXIS, angle);
    };
    /**
     * Rotates the 3d object around an axis by a defined angle
     *
     * @param    axis        The vector defining the axis of rotation
     * @param    angle        The amount of rotation in degrees
     */
    DisplayObject.prototype.rotate = function (axis, angle) {
        var m = new Matrix3D();
        m.prependRotation(angle, axis);
        var vec = m.decompose()[1];
        this._rotationX += vec.x;
        this._rotationY += vec.y;
        this._rotationZ += vec.z;
        this.invalidateRotation();
    };
    /**
     * Rotates the 3d object directly to a euler angle
     *
     * @param    ax        The angle in degrees of the rotation around the x axis.
     * @param    ay        The angle in degrees of the rotation around the y axis.
     * @param    az        The angle in degrees of the rotation around the z axis.
     */
    DisplayObject.prototype.rotateTo = function (ax, ay, az) {
        this._rotationX = ax * MathConsts.DEGREES_TO_RADIANS;
        this._rotationY = ay * MathConsts.DEGREES_TO_RADIANS;
        this._rotationZ = az * MathConsts.DEGREES_TO_RADIANS;
        this.invalidateRotation();
    };
    /**
     *
     */
    DisplayObject.prototype.removeEventListener = function (type, listener) {
        _super.prototype.removeEventListener.call(this, type, listener);
        if (this.hasEventListener(type, listener))
            return;
        switch (type) {
            case DisplayObjectEvent.POSITION_CHANGED:
                this._listenToPositionChanged = false;
                break;
            case DisplayObjectEvent.ROTATION_CHANGED:
                this._listenToRotationChanged = false;
                break;
            case DisplayObjectEvent.SCALE_CHANGED:
                this._listenToScaleChanged = false;
                break;
        }
    };
    /**
     * Moves the 3d object along a vector by a defined length
     *
     * @param    axis        The vector defining the axis of movement
     * @param    distance    The length of the movement
     */
    DisplayObject.prototype.translate = function (axis, distance) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = distance / Math.sqrt(x * x + y * y + z * z);
        this._x += x * len;
        this._y += y * len;
        this._z += z * len;
        this.invalidatePosition();
    };
    /**
     * Moves the 3d object along a vector by a defined length
     *
     * @param    axis        The vector defining the axis of movement
     * @param    distance    The length of the movement
     */
    DisplayObject.prototype.translateLocal = function (axis, distance) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = distance / Math.sqrt(x * x + y * y + z * z);
        this._iMatrix3D.prependTranslation(x * len, y * len, z * len);
        this._matrix3D.copyColumnTo(3, this._pos);
        this._x = this._pos.x;
        this._y = this._pos.y;
        this._z = this._pos.z;
        this.invalidatePosition();
    };
    /**
     * Rotates the 3d object around it's local y-axis
     *
     * @param    angle        The amount of rotation in degrees
     */
    DisplayObject.prototype.yaw = function (angle) {
        this.rotate(Vector3D.Y_AXIS, angle);
    };
    Object.defineProperty(DisplayObject.prototype, "_iAssignedPartition", {
        /**
         * @internal
         */
        get: function () {
            return this._pImplicitPartition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "_iMatrix3D", {
        /**
         * The transformation of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         *
         * @internal
         */
        get: function () {
            if (this._matrix3DDirty)
                this._pUpdateMatrix3D();
            return this._matrix3D;
        },
        set: function (val) {
            // TODO: From AS3 - Do we still need this in JS ?
            //ridiculous matrix error
            /*
            if (!val.rawData[0]) {
    
                var raw:number[] = Matrix3DUtils.RAW_DATA_CONTAINER;
                val.copyRawDataTo(raw);
                raw[0] = this._smallestNumber;
                val.copyRawDataFrom(raw);
            }
            //*/
            var elements = val.decompose();
            var vec;
            vec = elements[0];
            if (this._x != vec.x || this._y != vec.y || this._z != vec.z) {
                this._x = vec.x;
                this._y = vec.y;
                this._z = vec.z;
                this.invalidatePosition();
            }
            vec = elements[1];
            if (this._rotationX != vec.x || this._rotationY != vec.y || this._rotationZ != vec.z) {
                this._rotationX = vec.x;
                this._rotationY = vec.y;
                this._rotationZ = vec.z;
                this.invalidateRotation();
            }
            vec = elements[2];
            if (this._pScaleX != vec.x || this._pScaleY != vec.y || this._pScaleZ != vec.z) {
                this._pScaleX = vec.x;
                this._pScaleY = vec.y;
                this._pScaleZ = vec.z;
                this.invalidateScale();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "_iPickingCollisionVO", {
        /**
         * @internal
         */
        get: function () {
            if (!this._pPickingCollisionVO)
                this._pPickingCollisionVO = new PickingCollisionVO(this);
            return this._pPickingCollisionVO;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    DisplayObject.prototype.iSetParent = function (value) {
        this._pParent = value;
        if (value) {
            this._pUpdateImplicitMouseEnabled(value.mouseChildren);
            this._pUpdateImplicitVisibility(value._iIsVisible());
            this._pUpdateImplicitPartition(value._iAssignedPartition);
            this._iSetScene(value._pScene);
        }
        else {
            this._pUpdateImplicitMouseEnabled(true);
            this._pUpdateImplicitVisibility(true);
            this._pUpdateImplicitPartition(null);
            this._iSetScene(null);
        }
    };
    /**
     * @protected
     */
    DisplayObject.prototype.pCreateDefaultBoundingVolume = function () {
        // point lights should be using sphere bounds
        // directional lights should be using null bounds
        return new AxisAlignedBoundingBox();
    };
    /**
     * @protected
     */
    DisplayObject.prototype.pCreateEntityPartitionNode = function () {
        throw new AbstractMethodError();
    };
    /**
     * @protected
     */
    DisplayObject.prototype.pInvalidateBounds = function () {
        this._pBoundsInvalid = true;
        this._worldBoundsInvalid = true;
        if (this.isEntity)
            this.invalidatePartition();
    };
    /**
     * @protected
     */
    DisplayObject.prototype.pInvalidateSceneTransform = function () {
        this._pSceneTransformDirty = !this._pIgnoreTransform;
        this._inverseSceneTransformDirty = !this._pIgnoreTransform;
        this._scenePositionDirty = !this._pIgnoreTransform;
        this._worldBoundsInvalid = !this._pIgnoreTransform;
        if (this.isEntity)
            this.invalidatePartition();
        if (this._listenToSceneTransformChanged)
            this.notifySceneTransformChange();
    };
    /**
     * @protected
     */
    DisplayObject.prototype.pUpdateBounds = function () {
        this._width = this._pBounds.aabb.width * this._pScaleX;
        this._height = this._pBounds.aabb.height * this._pScaleY;
        this._depth = this._pBounds.aabb.depth * this._pScaleZ;
        this._pBoundsInvalid = false;
    };
    /**
     * @protected
     */
    DisplayObject.prototype._pUpdateImplicitMouseEnabled = function (value) {
        this._pImplicitMouseEnabled = this._explicitMouseEnabled && value;
        // If there is a parent and this child does not have a picking collider, use its parent's picking collider.
        if (this._pImplicitMouseEnabled && this._pParent && !this._pPickingCollider)
            this._pPickingCollider = this._pParent._pPickingCollider;
    };
    /**
     * @protected
     */
    DisplayObject.prototype._pUpdateImplicitPartition = function (value) {
        // assign parent implicit partition if no explicit one is given
        this._pImplicitPartition = this._explicitPartition || value;
    };
    /**
     * @protected
     */
    DisplayObject.prototype._pUpdateImplicitVisibility = function (value) {
        this._pImplicitVisibility = this._explicitVisibility && value;
    };
    /**
     * @protected
     */
    DisplayObject.prototype._pUpdateMatrix3D = function () {
        this._pos.x = this._x;
        this._pos.y = this._y;
        this._pos.z = this._z;
        this._rot.x = this._rotationX;
        this._rot.y = this._rotationY;
        this._rot.z = this._rotationZ;
        this._sca.x = this._pScaleX;
        this._sca.y = this._pScaleY;
        this._sca.z = this._pScaleZ;
        this._matrix3D.recompose(this._transformComponents);
        if (!this._pivotZero) {
            this._matrix3D.prependTranslation(-this._pivot.x / this._pScaleX, -this._pivot.y / this._pScaleY, -this._pivot.z / this._pScaleZ);
            if (this.alignmentMode != AlignmentMode.PIVOT_POINT)
                this._matrix3D.appendTranslation(this._pivot.x, this._pivot.y, this._pivot.z);
        }
        this._matrix3DDirty = false;
        this._positionDirty = false;
        this._rotationDirty = false;
        this._scaleDirty = false;
        this._pivotDirty = false;
    };
    /**
     * @protected
     */
    DisplayObject.prototype.pUpdateSceneTransform = function () {
        if (this._pParent && !this._pParent._iIsRoot) {
            this._pSceneTransform.copyFrom(this._pParent.sceneTransform);
            this._pSceneTransform.prepend(this._iMatrix3D);
        }
        else {
            this._pSceneTransform.copyFrom(this._iMatrix3D);
        }
        this._pSceneTransformDirty = false;
    };
    DisplayObject.prototype._iAddRenderable = function (renderable) {
        this._pRenderables.push(renderable);
        return renderable;
    };
    DisplayObject.prototype._iRemoveRenderable = function (renderable) {
        var index = this._pRenderables.indexOf(renderable);
        this._pRenderables.splice(index, 1);
        return renderable;
    };
    /**
     * //TODO
     *
     * @param shortestCollisionDistance
     * @param findClosest
     * @returns {boolean}
     *
     * @internal
     */
    DisplayObject.prototype._iTestCollision = function (shortestCollisionDistance, findClosest) {
        return false;
    };
    /**
     *
     */
    DisplayObject.prototype._iInternalUpdate = function () {
        if (this._iController)
            this._iController.update();
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iIsVisible = function () {
        return this._pImplicitVisibility;
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iIsMouseEnabled = function () {
        return this._pImplicitMouseEnabled;
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iSetScene = function (value) {
        // test to see if we're switching roots while we're already using a scene partition
        /*
        if (value == null)
            this._oldScene = this._pScene;

        if (this._explicitPartition && this._oldScene && this._oldScene != this._pScene)
            this.partition = null;

        if (value)
            this._oldScene = null;

        // end of stupid partition test code
        //*/
        if (this._pScene == value)
            return;
        this._pUpdateScene(value);
        if (!this._pSceneTransformDirty && !this._pIgnoreTransform)
            this.pInvalidateSceneTransform();
    };
    /**
     * @protected
     */
    DisplayObject.prototype._pUpdateScene = function (value) {
        if (this._pScene) {
            this._pScene.dispatchEvent(new SceneEvent(SceneEvent.REMOVED_FROM_SCENE, this));
            //unregister entity from current scene
            this._pScene.iUnregisterEntity(this);
        }
        this._pScene = value;
        if (value) {
            value.dispatchEvent(new SceneEvent(SceneEvent.ADDED_TO_SCENE, this));
            //register entity with new scene
            value.iRegisterEntity(this);
        }
        this.notifySceneChange();
    };
    /**
     * @private
     */
    DisplayObject.prototype.notifyPositionChanged = function () {
        if (!this._positionChanged)
            this._positionChanged = new DisplayObjectEvent(DisplayObjectEvent.POSITION_CHANGED, this);
        this.dispatchEvent(this._positionChanged);
    };
    /**
     * @private
     */
    DisplayObject.prototype.notifyRotationChanged = function () {
        if (!this._rotationChanged)
            this._rotationChanged = new DisplayObjectEvent(DisplayObjectEvent.ROTATION_CHANGED, this);
        this.dispatchEvent(this._rotationChanged);
    };
    /**
     * @private
     */
    DisplayObject.prototype.notifyScaleChanged = function () {
        if (!this._scaleChanged)
            this._scaleChanged = new DisplayObjectEvent(DisplayObjectEvent.SCALE_CHANGED, this);
        this.dispatchEvent(this._scaleChanged);
    };
    /**
     * @private
     */
    DisplayObject.prototype.notifySceneChange = function () {
        if (this._listenToSceneChanged) {
            if (!this._scenechanged)
                this._scenechanged = new DisplayObjectEvent(DisplayObjectEvent.SCENE_CHANGED, this);
            this.dispatchEvent(this._scenechanged);
        }
    };
    /**
     * @private
     */
    DisplayObject.prototype.notifySceneTransformChange = function () {
        if (!this._sceneTransformChanged)
            this._sceneTransformChanged = new DisplayObjectEvent(DisplayObjectEvent.SCENETRANSFORM_CHANGED, this);
        this.dispatchEvent(this._sceneTransformChanged);
    };
    /**
     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
     *
     * @private
     */
    DisplayObject.prototype.invalidateMatrix3D = function () {
        if (this._matrix3DDirty)
            return;
        this._matrix3DDirty = true;
        if (!this._pSceneTransformDirty && !this._pIgnoreTransform)
            this.pInvalidateSceneTransform();
    };
    /**
     * @private
     */
    DisplayObject.prototype.invalidatePartition = function () {
        if (this._iAssignedPartition)
            this._iAssignedPartition.iMarkForUpdate(this);
    };
    /**
     * @private
     */
    DisplayObject.prototype.invalidatePivot = function () {
        this._pivotZero = (this._pivot.x == 0) && (this._pivot.y == 0) && (this._pivot.z == 0);
        if (this._pivotDirty)
            return;
        this._pivotDirty = true;
        this.invalidateMatrix3D();
    };
    /**
     * @private
     */
    DisplayObject.prototype.invalidatePosition = function () {
        if (this._positionDirty)
            return;
        this._positionDirty = true;
        this.invalidateMatrix3D();
        if (this._listenToPositionChanged)
            this.notifyPositionChanged();
    };
    /**
     * @private
     */
    DisplayObject.prototype.invalidateRotation = function () {
        if (this._rotationDirty)
            return;
        this._rotationDirty = true;
        this.invalidateMatrix3D();
        if (this._listenToRotationChanged)
            this.notifyRotationChanged();
    };
    /**
     * @private
     */
    DisplayObject.prototype.invalidateScale = function () {
        if (this._scaleDirty)
            return;
        this._scaleDirty = true;
        this.invalidateMatrix3D();
        if (this._listenToScaleChanged)
            this.notifyScaleChanged();
    };
    return DisplayObject;
})(NamedAssetBase);
module.exports = DisplayObject;


},{"awayjs-core/lib/bounds/AxisAlignedBoundingBox":97,"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/geom/MathConsts":111,"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Matrix3DUtils":114,"awayjs-core/lib/geom/Point":118,"awayjs-core/lib/geom/Vector3D":120,"awayjs-core/lib/library/NamedAssetBase":122,"awayjs-display/lib/base/AlignmentMode":57,"awayjs-display/lib/base/OrientationMode":60,"awayjs-display/lib/base/Transform":61,"awayjs-display/lib/events/DisplayObjectEvent":70,"awayjs-display/lib/events/SceneEvent":74,"awayjs-display/lib/pick/PickingCollisionVO":89}],59:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var DisplayObjectContainer = require("awayjs-display/lib/containers/DisplayObjectContainer");
var LightEvent = require("awayjs-display/lib/events/LightEvent");
var LightBase = (function (_super) {
    __extends(LightBase, _super);
    function LightBase() {
        _super.call(this);
        this._color = 0xffffff;
        this._colorR = 1;
        this._colorG = 1;
        this._colorB = 1;
        this._ambientColor = 0xffffff;
        this._ambient = 0;
        this._iAmbientR = 0;
        this._iAmbientG = 0;
        this._iAmbientB = 0;
        this._specular = 1;
        this._iSpecularR = 1;
        this._iSpecularG = 1;
        this._iSpecularB = 1;
        this._diffuse = 1;
        this._iDiffuseR = 1;
        this._iDiffuseG = 1;
        this._iDiffuseB = 1;
        this._castsShadows = false;
    }
    Object.defineProperty(LightBase.prototype, "castsShadows", {
        get: function () {
            return this._castsShadows;
        },
        set: function (value) {
            if (this._castsShadows == value)
                return;
            this._castsShadows = value;
            if (value) {
                if (this._shadowMapper == null)
                    this._shadowMapper = this.pCreateShadowMapper();
                this._shadowMapper.light = this;
            }
            else {
                this._shadowMapper.dispose();
                this._shadowMapper = null;
            }
            //*/
            this.dispatchEvent(new LightEvent(LightEvent.CASTS_SHADOW_CHANGE));
        },
        enumerable: true,
        configurable: true
    });
    LightBase.prototype.pCreateShadowMapper = function () {
        throw new AbstractMethodError();
    };
    Object.defineProperty(LightBase.prototype, "specular", {
        get: function () {
            return this._specular;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            this._specular = value;
            this.updateSpecular();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "diffuse", {
        get: function () {
            return this._diffuse;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            this._diffuse = value;
            this.updateDiffuse();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = value;
            this._colorR = ((this._color >> 16) & 0xff) / 0xff;
            this._colorG = ((this._color >> 8) & 0xff) / 0xff;
            this._colorB = (this._color & 0xff) / 0xff;
            this.updateDiffuse();
            this.updateSpecular();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "ambient", {
        get: function () {
            return this._ambient;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            this._ambient = value;
            this.updateAmbient();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "ambientColor", {
        get: function () {
            return this._ambientColor;
        },
        set: function (value) {
            this._ambientColor = value;
            this.updateAmbient();
        },
        enumerable: true,
        configurable: true
    });
    LightBase.prototype.updateAmbient = function () {
        this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
        this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
        this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
    };
    LightBase.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
        if (target === void 0) { target = null; }
        throw new AbstractMethodError();
    };
    Object.defineProperty(LightBase.prototype, "assetType", {
        //@override
        get: function () {
            return AssetType.LIGHT;
        },
        enumerable: true,
        configurable: true
    });
    LightBase.prototype.updateSpecular = function () {
        this._iSpecularR = this._colorR * this._specular;
        this._iSpecularG = this._colorG * this._specular;
        this._iSpecularB = this._colorB * this._specular;
    };
    LightBase.prototype.updateDiffuse = function () {
        this._iDiffuseR = this._colorR * this._diffuse;
        this._iDiffuseG = this._colorG * this._diffuse;
        this._iDiffuseB = this._colorB * this._diffuse;
    };
    Object.defineProperty(LightBase.prototype, "shadowMapper", {
        get: function () {
            return this._shadowMapper;
        },
        set: function (value) {
            this._shadowMapper = value;
            this._shadowMapper.light = this;
        },
        enumerable: true,
        configurable: true
    });
    return LightBase;
})(DisplayObjectContainer);
module.exports = LightBase;


},{"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/library/AssetType":121,"awayjs-display/lib/containers/DisplayObjectContainer":62,"awayjs-display/lib/events/LightEvent":71}],60:[function(require,module,exports){
var OrientationMode = (function () {
    function OrientationMode() {
    }
    /**
     *
     */
    OrientationMode.DEFAULT = "default";
    /**
     *
     */
    OrientationMode.CAMERA_PLANE = "cameraPlane";
    /**
     *
     */
    OrientationMode.CAMERA_POSITION = "cameraPosition";
    return OrientationMode;
})();
module.exports = OrientationMode;


},{}],61:[function(require,module,exports){
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Matrix3DUtils = require("awayjs-core/lib/geom/Matrix3DUtils");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
/**
 * The Transform class provides access to color adjustment properties and two-
 * or three-dimensional transformation objects that can be applied to a
 * display object. During the transformation, the color or the orientation and
 * position of a display object is adjusted(offset) from the current values
 * or coordinates to new values or coordinates. The Transform class also
 * collects data about color and two-dimensional matrix transformations that
 * are applied to a display object and all of its parent objects. You can
 * access these combined transformations through the
 * <code>concatenatedColorTransform</code> and <code>concatenatedMatrix</code>
 * properties.
 *
 * <p>To apply color transformations: create a ColorTransform object, set the
 * color adjustments using the object's methods and properties, and then
 * assign the <code>colorTransformation</code> property of the
 * <code>transform</code> property of the display object to the new
 * ColorTransformation object.</p>
 *
 * <p>To apply two-dimensional transformations: create a Matrix object, set
 * the matrix's two-dimensional transformation, and then assign the
 * <code>transform.matrix</code> property of the display object to the new
 * Matrix object.</p>
 *
 * <p>To apply three-dimensional transformations: start with a
 * three-dimensional display object. A three-dimensional display object has a
 * <code>z</code> property value other than zero. You do not need to create
 * the Matrix3D object. For all three-dimensional objects, a Matrix3D object
 * is created automatically when you assign a <code>z</code> value to a
 * display object. You can access the display object's Matrix3D object through
 * the display object's <code>transform</code> property. Using the methods of
 * the Matrix3D class, you can add to or modify the existing transformation
 * settings. Also, you can create a custom Matrix3D object, set the custom
 * Matrix3D object's transformation elements, and then assign the new Matrix3D
 * object to the display object using the <code>transform.matrix</code>
 * property.</p>
 *
 * <p>To modify a perspective projection of the stage or root object: use the
 * <code>transform.matrix</code> property of the root display object to gain
 * access to the PerspectiveProjection object. Or, apply different perspective
 * projection properties to a display object by setting the perspective
 * projection properties of the display object's parent. The child display
 * object inherits the new properties. Specifically, create a
 * PerspectiveProjection object and set its properties, then assign the
 * PerspectiveProjection object to the <code>perspectiveProjection</code>
 * property of the parent display object's <code>transform</code> property.
 * The specified projection transformation then applies to all the display
 * object's three-dimensional children.</p>
 *
 * <p>Since both PerspectiveProjection and Matrix3D objects perform
 * perspective transformations, do not assign both to a display object at the
 * same time. Use the PerspectiveProjection object for focal length and
 * projection center changes. For more control over the perspective
 * transformation, create a perspective projection Matrix3D object.</p>
 */
var Transform = (function () {
    function Transform(displayObject) {
        this._position = new Vector3D();
        this._displayObject = displayObject;
    }
    Object.defineProperty(Transform.prototype, "backVector", {
        /**
         *
         */
        get: function () {
            var director = Matrix3DUtils.getForward(this._displayObject._iMatrix3D);
            director.negate();
            return director;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "concatenatedColorTransform", {
        /**
         * A ColorTransform object representing the combined color transformations
         * applied to the display object and all of its parent objects, back to the
         * root level. If different color transformations have been applied at
         * different levels, all of those transformations are concatenated into one
         * ColorTransform object for this property.
         */
        get: function () {
            return this._concatenatedColorTransform; //TODO
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "concatenatedMatrix", {
        /**
         * A Matrix object representing the combined transformation matrixes of the
         * display object and all of its parent objects, back to the root level. If
         * different transformation matrixes have been applied at different levels,
         * all of those matrixes are concatenated into one matrix for this property.
         * Also, for resizeable SWF content running in the browser, this property
         * factors in the difference between stage coordinates and window coordinates
         * due to window resizing. Thus, the property converts local coordinates to
         * window coordinates, which may not be the same coordinate space as that of
         * the Stage.
         */
        get: function () {
            return this._concatenatedMatrix; //TODO
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "downVector", {
        /**
         *
         */
        get: function () {
            var director = Matrix3DUtils.getUp(this._displayObject._iMatrix3D);
            director.negate();
            return director;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "forwardVector", {
        /**
         *
         */
        get: function () {
            return Matrix3DUtils.getForward(this._displayObject._iMatrix3D);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "leftVector", {
        /**
         *
         */
        get: function () {
            var director = Matrix3DUtils.getRight(this._displayObject._iMatrix3D);
            director.negate();
            return director;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "matrix3D", {
        /**
         * Provides access to the Matrix3D object of a three-dimensional display
         * object. The Matrix3D object represents a transformation matrix that
         * determines the display object's position and orientation. A Matrix3D
         * object can also perform perspective projection.
         *
         * <p>If the <code>matrix</code> property is set to a value(not
         * <code>null</code>), the <code>matrix3D</code> property is
         * <code>null</code>. And if the <code>matrix3D</code> property is set to a
         * value(not <code>null</code>), the <code>matrix</code> property is
         * <code>null</code>.</p>
         */
        get: function () {
            return this._displayObject._iMatrix3D;
        },
        set: function (val) {
            this._displayObject._iMatrix3D = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "pixelBounds", {
        /**
         * A Rectangle object that defines the bounding rectangle of the display
         * object on the stage.
         */
        get: function () {
            return this._pixelBounds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "position", {
        /**
         * Defines the position of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            return this._displayObject._iMatrix3D.position;
        },
        set: function (value) {
            this._displayObject.x = value.x;
            this._displayObject.y = value.y;
            this._displayObject.z = value.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "rightVector", {
        /**
         *
         */
        get: function () {
            return Matrix3DUtils.getRight(this._displayObject._iMatrix3D);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "rotation", {
        /**
         * Defines the rotation of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            return new Vector3D(this._displayObject.rotationX, this._displayObject.rotationY, this._displayObject.rotationZ);
        },
        set: function (value) {
            this._displayObject.rotationX = value.x;
            this._displayObject.rotationY = value.y;
            this._displayObject.rotationZ = value.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "scale", {
        /**
         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            return new Vector3D(this._displayObject.scaleX, this._displayObject.scaleY, this._displayObject.scaleZ);
        },
        set: function (value) {
            this._displayObject.scaleX = value.x;
            this._displayObject.scaleY = value.y;
            this._displayObject.scaleZ = value.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "upVector", {
        /**
         *
         */
        get: function () {
            return Matrix3DUtils.getUp(this._displayObject._iMatrix3D);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a Matrix3D object, which can transform the space of a specified
     * display object in relation to the current display object's space. You can
     * use the <code>getRelativeMatrix3D()</code> method to move one
     * three-dimensional display object relative to another three-dimensional
     * display object.
     *
     * @param relativeTo The display object relative to which the transformation
     *                   occurs. To get a Matrix3D object relative to the stage,
     *                   set the parameter to the <code>root</code> or
     *                   <code>stage</code> object. To get the world-relative
     *                   matrix of the display object, set the parameter to a
     *                   display object that has a perspective transformation
     *                   applied to it.
     * @return A Matrix3D object that can be used to transform the space from the
     *         <code>relativeTo</code> display object to the current display
     *         object space.
     */
    Transform.prototype.getRelativeMatrix3D = function (relativeTo) {
        return new Matrix3D(); //TODO
    };
    /**
     * Moves the 3d object forwards along it's local z axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveForward = function (distance) {
        this._displayObject.translateLocal(Vector3D.Z_AXIS, distance);
    };
    /**
     * Moves the 3d object backwards along it's local z axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveBackward = function (distance) {
        this._displayObject.translateLocal(Vector3D.Z_AXIS, -distance);
    };
    /**
     * Moves the 3d object backwards along it's local x axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveLeft = function (distance) {
        this._displayObject.translateLocal(Vector3D.X_AXIS, -distance);
    };
    /**
     * Moves the 3d object forwards along it's local x axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveRight = function (distance) {
        this._displayObject.translateLocal(Vector3D.X_AXIS, distance);
    };
    /**
     * Moves the 3d object forwards along it's local y axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveUp = function (distance) {
        this._displayObject.translateLocal(Vector3D.Y_AXIS, distance);
    };
    /**
     * Moves the 3d object backwards along it's local y axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveDown = function (distance) {
        this._displayObject.translateLocal(Vector3D.Y_AXIS, -distance);
    };
    return Transform;
})();
module.exports = Transform;


},{"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Matrix3DUtils":114,"awayjs-core/lib/geom/Vector3D":120}],62:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var ArgumentError = require("awayjs-core/lib/errors/ArgumentError");
var Error = require("awayjs-core/lib/errors/Error");
var RangeError = require("awayjs-core/lib/errors/RangeError");
var DisplayObject = require("awayjs-display/lib/base/DisplayObject");
/**
 * The DisplayObjectContainer class is the base class for all objects that can
 * serve as display object containers on the display list. The display list
 * manages all objects displayed in the Flash runtimes. Use the
 * DisplayObjectContainer class to arrange the display objects in the display
 * list. Each DisplayObjectContainer object has its own child list for
 * organizing the z-order of the objects. The z-order is the front-to-back
 * order that determines which object is drawn in front, which is behind, and
 * so on.
 *
 * <p>DisplayObject is an abstract base class; therefore, you cannot call
 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
 * <code>ArgumentError</code> exception.</p>
 * The DisplayObjectContainer class is an abstract base class for all objects
 * that can contain child objects. It cannot be instantiated directly; calling
 * the <code>new DisplayObjectContainer()</code> constructor throws an
 * <code>ArgumentError</code> exception.
 *
 * <p>For more information, see the "Display Programming" chapter of the
 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
 */
var DisplayObjectContainer = (function (_super) {
    __extends(DisplayObjectContainer, _super);
    /**
     * Calling the <code>new DisplayObjectContainer()</code> constructor throws
     * an <code>ArgumentError</code> exception. You <i>can</i>, however, call
     * constructors for the following subclasses of DisplayObjectContainer:
     * <ul>
     *   <li><code>new Loader()</code></li>
     *   <li><code>new Sprite()</code></li>
     *   <li><code>new MovieClip()</code></li>
     * </ul>
     */
    function DisplayObjectContainer() {
        _super.call(this);
        this._mouseChildren = true;
        this._children = new Array();
    }
    Object.defineProperty(DisplayObjectContainer.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return AssetType.CONTAINER;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObjectContainer.prototype, "mouseChildren", {
        /**
         * Determines whether or not the children of the object are mouse, or user
         * input device, enabled. If an object is enabled, a user can interact with
         * it by using a mouse or user input device. The default is
         * <code>true</code>.
         *
         * <p>This property is useful when you create a button with an instance of
         * the Sprite class(instead of using the SimpleButton class). When you use a
         * Sprite instance to create a button, you can choose to decorate the button
         * by using the <code>addChild()</code> method to add additional Sprite
         * instances. This process can cause unexpected behavior with mouse events
         * because the Sprite instances you add as children can become the target
         * object of a mouse event when you expect the parent instance to be the
         * target object. To ensure that the parent instance serves as the target
         * objects for mouse events, you can set the <code>mouseChildren</code>
         * property of the parent instance to <code>false</code>.</p>
         *
         * <p> No event is dispatched by setting this property. You must use the
         * <code>addEventListener()</code> method to create interactive
         * functionality.</p>
         */
        get: function () {
            return this._mouseChildren;
        },
        set: function (value) {
            if (this._mouseChildren == value)
                return;
            this._mouseChildren = value;
            this._pUpdateImplicitMouseEnabled(this._pParent ? this._pParent.mouseChildren : true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
        /**
         * Returns the number of children of this object.
         */
        get: function () {
            return this._children.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a child DisplayObject instance to this DisplayObjectContainer
     * instance. The child is added to the front(top) of all other children in
     * this DisplayObjectContainer instance.(To add a child to a specific index
     * position, use the <code>addChildAt()</code> method.)
     *
     * <p>If you add a child object that already has a different display object
     * container as a parent, the object is removed from the child list of the
     * other display object container. </p>
     *
     * <p><b>Note:</b> The command <code>stage.addChild()</code> can cause
     * problems with a published SWF file, including security problems and
     * conflicts with other loaded SWF files. There is only one Stage within a
     * Flash runtime instance, no matter how many SWF files you load into the
     * runtime. So, generally, objects should not be added to the Stage,
     * directly, at all. The only object the Stage should contain is the root
     * object. Create a DisplayObjectContainer to contain all of the items on the
     * display list. Then, if necessary, add that DisplayObjectContainer instance
     * to the Stage.</p>
     *
     * @param child The DisplayObject instance to add as a child of this
     *              DisplayObjectContainer instance.
     * @return The DisplayObject instance that you pass in the <code>child</code>
     *         parameter.
     * @throws ArgumentError Throws if the child is the same as the parent. Also
     *                       throws if the caller is a child(or grandchild etc.)
     *                       of the child being added.
     * @event added Dispatched when a display object is added to the display
     *              list.
     */
    DisplayObjectContainer.prototype.addChild = function (child) {
        if (child == null)
            throw new Error("Parameter child cannot be null.");
        //if child already has a parent, remove it.
        if (child._pParent)
            child._pParent.removeChildInternal(child);
        child.iSetParent(this);
        this._children.push(child);
        return child;
    };
    /**
     * Adds a child DisplayObject instance to this DisplayObjectContainer
     * instance. The child is added at the index position specified. An index of
     * 0 represents the back(bottom) of the display list for this
     * DisplayObjectContainer object.
     *
     * <p>For example, the following example shows three display objects, labeled
     * a, b, and c, at index positions 0, 2, and 1, respectively:</p>
     *
     * <p>If you add a child object that already has a different display object
     * container as a parent, the object is removed from the child list of the
     * other display object container. </p>
     *
     * @param child The DisplayObject instance to add as a child of this
     *              DisplayObjectContainer instance.
     * @param index The index position to which the child is added. If you
     *              specify a currently occupied index position, the child object
     *              that exists at that position and all higher positions are
     *              moved up one position in the child list.
     * @return The DisplayObject instance that you pass in the <code>child</code>
     *         parameter.
     * @throws ArgumentError Throws if the child is the same as the parent. Also
     *                       throws if the caller is a child(or grandchild etc.)
     *                       of the child being added.
     * @throws RangeError    Throws if the index position does not exist in the
     *                       child list.
     * @event added Dispatched when a display object is added to the display
     *              list.
     */
    DisplayObjectContainer.prototype.addChildAt = function (child, index /*int*/) {
        return child;
    };
    DisplayObjectContainer.prototype.addChildren = function () {
        var childarray = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            childarray[_i - 0] = arguments[_i];
        }
        var len = childarray.length;
        for (var i = 0; i < len; i++)
            this.addChild(childarray[i]);
    };
    /**
     *
     */
    DisplayObjectContainer.prototype.clone = function () {
        var clone = new DisplayObjectContainer();
        clone.pivot = this.pivot;
        clone._iMatrix3D = this._iMatrix3D;
        clone.partition = this.partition;
        clone.name = name;
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            clone.addChild(this._children[i].clone());
        // todo: implement for all subtypes
        return clone;
    };
    /**
     * Determines whether the specified display object is a child of the
     * DisplayObjectContainer instance or the instance itself. The search
     * includes the entire display list including this DisplayObjectContainer
     * instance. Grandchildren, great-grandchildren, and so on each return
     * <code>true</code>.
     *
     * @param child The child object to test.
     * @return <code>true</code> if the <code>child</code> object is a child of
     *         the DisplayObjectContainer or the container itself; otherwise
     *         <code>false</code>.
     */
    DisplayObjectContainer.prototype.contains = function (child) {
        return this._children.indexOf(child) >= 0;
    };
    /**
     *
     */
    DisplayObjectContainer.prototype.disposeWithChildren = function () {
        this.dispose();
        while (this.numChildren > 0)
            this.getChildAt(0).dispose();
    };
    /**
     * Returns the child display object instance that exists at the specified
     * index.
     *
     * @param index The index position of the child object.
     * @return The child display object at the specified index position.
     * @throws RangeError    Throws if the index does not exist in the child
     *                       list.
     */
    DisplayObjectContainer.prototype.getChildAt = function (index /*int*/) {
        var child = this._children[index];
        if (child == null)
            throw new RangeError("Index does not exist in the child list of the caller");
        return child;
    };
    /**
     * Returns the child display object that exists with the specified name. If
     * more that one child display object has the specified name, the method
     * returns the first object in the child list.
     *
     * <p>The <code>getChildAt()</code> method is faster than the
     * <code>getChildByName()</code> method. The <code>getChildAt()</code> method
     * accesses a child from a cached array, whereas the
     * <code>getChildByName()</code> method has to traverse a linked list to
     * access a child.</p>
     *
     * @param name The name of the child to return.
     * @return The child display object with the specified name.
     */
    DisplayObjectContainer.prototype.getChildByName = function (name) {
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            if (this._children[i].name == name)
                return this._children[i];
        return null;
    };
    /**
     * Returns the index position of a <code>child</code> DisplayObject instance.
     *
     * @param child The DisplayObject instance to identify.
     * @return The index position of the child display object to identify.
     * @throws ArgumentError Throws if the child parameter is not a child of this
     *                       object.
     */
    DisplayObjectContainer.prototype.getChildIndex = function (child) {
        var childIndex = this._children.indexOf(child);
        if (childIndex == -1)
            throw new ArgumentError("Child parameter is not a child of the caller");
        return childIndex;
    };
    /**
     * Returns an array of objects that lie under the specified point and are
     * children(or grandchildren, and so on) of this DisplayObjectContainer
     * instance. Any child objects that are inaccessible for security reasons are
     * omitted from the returned array. To determine whether this security
     * restriction affects the returned array, call the
     * <code>areInaccessibleObjectsUnderPoint()</code> method.
     *
     * <p>The <code>point</code> parameter is in the coordinate space of the
     * Stage, which may differ from the coordinate space of the display object
     * container(unless the display object container is the Stage). You can use
     * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
     * methods to convert points between these coordinate spaces.</p>
     *
     * @param point The point under which to look.
     * @return An array of objects that lie under the specified point and are
     *         children(or grandchildren, and so on) of this
     *         DisplayObjectContainer instance.
     */
    DisplayObjectContainer.prototype.getObjectsUnderPoint = function (point) {
        return new Array();
    };
    /**
     * Removes the specified <code>child</code> DisplayObject instance from the
     * child list of the DisplayObjectContainer instance. The <code>parent</code>
     * property of the removed child is set to <code>null</code> , and the object
     * is garbage collected if no other references to the child exist. The index
     * positions of any display objects above the child in the
     * DisplayObjectContainer are decreased by 1.
     *
     * <p>The garbage collector reallocates unused memory space. When a variable
     * or object is no longer actively referenced or stored somewhere, the
     * garbage collector sweeps through and wipes out the memory space it used to
     * occupy if no other references to it exist.</p>
     *
     * @param child The DisplayObject instance to remove.
     * @return The DisplayObject instance that you pass in the <code>child</code>
     *         parameter.
     * @throws ArgumentError Throws if the child parameter is not a child of this
     *                       object.
     */
    DisplayObjectContainer.prototype.removeChild = function (child) {
        if (child == null)
            throw new Error("Parameter child cannot be null");
        this.removeChildInternal(child);
        child.iSetParent(null);
        return child;
    };
    /**
     * Removes a child DisplayObject from the specified <code>index</code>
     * position in the child list of the DisplayObjectContainer. The
     * <code>parent</code> property of the removed child is set to
     * <code>null</code>, and the object is garbage collected if no other
     * references to the child exist. The index positions of any display objects
     * above the child in the DisplayObjectContainer are decreased by 1.
     *
     * <p>The garbage collector reallocates unused memory space. When a variable
     * or object is no longer actively referenced or stored somewhere, the
     * garbage collector sweeps through and wipes out the memory space it used to
     * occupy if no other references to it exist.</p>
     *
     * @param index The child index of the DisplayObject to remove.
     * @return The DisplayObject instance that was removed.
     * @throws RangeError    Throws if the index does not exist in the child
     *                       list.
     * @throws SecurityError This child display object belongs to a sandbox to
     *                       which the calling object does not have access. You
     *                       can avoid this situation by having the child movie
     *                       call the <code>Security.allowDomain()</code> method.
     */
    DisplayObjectContainer.prototype.removeChildAt = function (index /*int*/) {
        return this.removeChild(this._children[index]);
    };
    /**
     * Removes all <code>child</code> DisplayObject instances from the child list
     * of the DisplayObjectContainer instance. The <code>parent</code> property
     * of the removed children is set to <code>null</code>, and the objects are
     * garbage collected if no other references to the children exist.
     *
     * The garbage collector reallocates unused memory space. When a variable or
     * object is no longer actively referenced or stored somewhere, the garbage
     * collector sweeps through and wipes out the memory space it used to occupy
     * if no other references to it exist.
     *
     * @param beginIndex The beginning position. A value smaller than 0 throws a RangeError.
     * @param endIndex The ending position. A value smaller than 0 throws a RangeError.
     * @throws RangeError    Throws if the beginIndex or endIndex positions do
     *                       not exist in the child list.
     */
    DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
        if (beginIndex === void 0) { beginIndex = 0; }
        if (endIndex === void 0) { endIndex = 2147483647; }
        if (beginIndex < 0)
            throw new RangeError("beginIndex is out of range of the child list");
        if (endIndex > this._children.length)
            throw new RangeError("endIndex is out of range of the child list");
        for (var i = beginIndex; i < endIndex; i++)
            this.removeChild(this._children[i]);
    };
    /**
     * Changes the position of an existing child in the display object container.
     * This affects the layering of child objects. For example, the following
     * example shows three display objects, labeled a, b, and c, at index
     * positions 0, 1, and 2, respectively:
     *
     * <p>When you use the <code>setChildIndex()</code> method and specify an
     * index position that is already occupied, the only positions that change
     * are those in between the display object's former and new position. All
     * others will stay the same. If a child is moved to an index LOWER than its
     * current index, all children in between will INCREASE by 1 for their index
     * reference. If a child is moved to an index HIGHER than its current index,
     * all children in between will DECREASE by 1 for their index reference. For
     * example, if the display object container in the previous example is named
     * <code>container</code>, you can swap the position of the display objects
     * labeled a and b by calling the following code:</p>
     *
     * <p>This code results in the following arrangement of objects:</p>
     *
     * @param child The child DisplayObject instance for which you want to change
     *              the index number.
     * @param index The resulting index number for the <code>child</code> display
     *              object.
     * @throws ArgumentError Throws if the child parameter is not a child of this
     *                       object.
     * @throws RangeError    Throws if the index does not exist in the child
     *                       list.
     */
    DisplayObjectContainer.prototype.setChildIndex = function (child, index /*int*/) {
        //TODO
    };
    /**
     * Swaps the z-order (front-to-back order) of the two specified child
     * objects. All other child objects in the display object container remain in
     * the same index positions.
     *
     * @param child1 The first child object.
     * @param child2 The second child object.
     * @throws ArgumentError Throws if either child parameter is not a child of
     *                       this object.
     */
    DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
        //TODO
    };
    /**
     * Swaps the z-order(front-to-back order) of the child objects at the two
     * specified index positions in the child list. All other child objects in
     * the display object container remain in the same index positions.
     *
     * @param index1 The index position of the first child object.
     * @param index2 The index position of the second child object.
     * @throws RangeError If either index does not exist in the child list.
     */
    DisplayObjectContainer.prototype.swapChildrenAt = function (index1 /*int*/, index2 /*int*/) {
        //TODO
    };
    /**
     * @protected
     */
    DisplayObjectContainer.prototype.pInvalidateSceneTransform = function () {
        _super.prototype.pInvalidateSceneTransform.call(this);
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i].pInvalidateSceneTransform();
    };
    /**
     * @protected
     */
    DisplayObjectContainer.prototype._pUpdateScene = function (value) {
        _super.prototype._pUpdateScene.call(this, value);
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i]._pUpdateScene(value);
    };
    /**
     * @protected
     */
    DisplayObjectContainer.prototype._pUpdateImplicitMouseEnabled = function (value) {
        _super.prototype._pUpdateImplicitMouseEnabled.call(this, value);
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i]._pUpdateImplicitMouseEnabled(this._mouseChildren);
    };
    /**
     * @protected
     */
    DisplayObjectContainer.prototype._pUpdateImplicitVisibility = function (value) {
        _super.prototype._pUpdateImplicitVisibility.call(this, value);
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i]._pUpdateImplicitVisibility(this._pImplicitVisibility);
    };
    /**
     * @protected
     */
    DisplayObjectContainer.prototype._pUpdateImplicitPartition = function (value) {
        _super.prototype._pUpdateImplicitPartition.call(this, value);
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i]._pUpdateImplicitPartition(this._pImplicitPartition);
    };
    /**
     * @private
     *
     * @param child
     */
    DisplayObjectContainer.prototype.removeChildInternal = function (child) {
        this._children.splice(this.getChildIndex(child), 1);
        return child;
    };
    return DisplayObjectContainer;
})(DisplayObject);
module.exports = DisplayObjectContainer;


},{"awayjs-core/lib/errors/ArgumentError":102,"awayjs-core/lib/errors/Error":103,"awayjs-core/lib/errors/RangeError":105,"awayjs-core/lib/library/AssetType":121,"awayjs-display/lib/base/DisplayObject":58}],63:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var DisplayObjectContainer = require("awayjs-display/lib/containers/DisplayObjectContainer");
var SceneEvent = require("awayjs-display/lib/events/SceneEvent");
var NodeBase = require("awayjs-display/lib/partition/NodeBase");
var Partition = require("awayjs-display/lib/partition/Partition");
var Scene = (function (_super) {
    __extends(Scene, _super);
    function Scene() {
        _super.call(this);
        this._expandedPartitions = new Array();
        this._partitions = new Array();
        this._iCollectionMark = 0;
        this._iSceneGraphRoot = new DisplayObjectContainer();
        this._iSceneGraphRoot._iSetScene(this);
        this._iSceneGraphRoot._iIsRoot = true;
        this._iSceneGraphRoot.partition = new Partition(new NodeBase());
    }
    Scene.prototype.traversePartitions = function (traverser) {
        var i = 0;
        var len = this._partitions.length;
        traverser.scene = this;
        while (i < len) {
            this._iCollectionMark++;
            this._partitions[i++].traverse(traverser);
        }
    };
    Object.defineProperty(Scene.prototype, "partition", {
        get: function () {
            return this._iSceneGraphRoot.partition;
        },
        set: function (value) {
            this._iSceneGraphRoot.partition = value;
            this.dispatchEvent(new SceneEvent(SceneEvent.PARTITION_CHANGED, this._iSceneGraphRoot));
        },
        enumerable: true,
        configurable: true
    });
    Scene.prototype.contains = function (child) {
        return this._iSceneGraphRoot.contains(child);
    };
    Scene.prototype.addChild = function (child) {
        return this._iSceneGraphRoot.addChild(child);
    };
    Scene.prototype.removeChild = function (child) {
        this._iSceneGraphRoot.removeChild(child);
    };
    Scene.prototype.removeChildAt = function (index) {
        this._iSceneGraphRoot.removeChildAt(index);
    };
    Scene.prototype.getChildAt = function (index) {
        return this._iSceneGraphRoot.getChildAt(index);
    };
    Object.defineProperty(Scene.prototype, "numChildren", {
        get: function () {
            return this._iSceneGraphRoot.numChildren;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    Scene.prototype.iRegisterEntity = function (displayObject) {
        if (displayObject.partition)
            this.iRegisterPartition(displayObject.partition);
        if (displayObject.isEntity)
            displayObject._iAssignedPartition.iMarkForUpdate(displayObject);
    };
    /**
     * @internal
     */
    Scene.prototype.iRegisterPartition = function (partition) {
        this._expandedPartitions.push(partition);
        //ensure duplicates are not found in partitions array
        if (this._partitions.indexOf(partition) == -1)
            this._partitions.push(partition);
    };
    /**
     * @internal
     */
    Scene.prototype.iUnregisterEntity = function (displayObject) {
        if (displayObject.partition)
            this.iUnregisterPartition(displayObject.partition);
        if (displayObject.isEntity)
            displayObject._iAssignedPartition.iRemoveEntity(displayObject);
    };
    /**
     * @internal
     */
    Scene.prototype.iUnregisterPartition = function (partition) {
        this._expandedPartitions.splice(this._expandedPartitions.indexOf(partition), 1);
        //if no more partition references found, remove from partitions array
        if (this._expandedPartitions.indexOf(partition) == -1)
            this._partitions.splice(this._partitions.indexOf(partition), 1);
    };
    return Scene;
})(EventDispatcher);
module.exports = Scene;


},{"awayjs-core/lib/events/EventDispatcher":108,"awayjs-display/lib/containers/DisplayObjectContainer":62,"awayjs-display/lib/events/SceneEvent":74,"awayjs-display/lib/partition/NodeBase":85,"awayjs-display/lib/partition/Partition":87}],64:[function(require,module,exports){
var getTimer = require("awayjs-core/lib/utils/getTimer");
var Scene = require("awayjs-display/lib/containers/Scene");
var RaycastPicker = require("awayjs-display/lib/pick/RaycastPicker");
var Camera = require("awayjs-display/lib/entities/Camera");
var CameraEvent = require("awayjs-display/lib/events/CameraEvent");
var SceneEvent = require("awayjs-display/lib/events/SceneEvent");
var RendererEvent = require("awayjs-display/lib/events/RendererEvent");
var MouseManager = require("awayjs-display/lib/managers/MouseManager");
var View = (function () {
    /*
     ***********************************************************************
     * Disabled / Not yet implemented
     ***********************************************************************
     *
     * private _background:away.textures.Texture2DBase;
     *
     * public _pTouch3DManager:away.managers.Touch3DManager;
     *
     */
    function View(renderer, scene, camera) {
        var _this = this;
        if (scene === void 0) { scene = null; }
        if (camera === void 0) { camera = null; }
        this._width = 0;
        this._height = 0;
        this._time = 0;
        this._deltaTime = 0;
        this._backgroundColor = 0x000000;
        this._backgroundAlpha = 1;
        this._viewportDirty = true;
        this._scissorDirty = true;
        this._mousePicker = new RaycastPicker();
        this._onScenePartitionChangedDelegate = function (event) { return _this.onScenePartitionChanged(event); };
        this._onProjectionChangedDelegate = function (event) { return _this.onProjectionChanged(event); };
        this._onViewportUpdatedDelegate = function (event) { return _this.onViewportUpdated(event); };
        this._onScissorUpdatedDelegate = function (event) { return _this.onScissorUpdated(event); };
        this.scene = scene || new Scene();
        this.camera = camera || new Camera();
        this.renderer = renderer;
        //make sure document border is zero
        document.body.style.margin = "0px";
        this._htmlElement = document.createElement("div");
        this._htmlElement.style.position = "absolute";
        document.body.appendChild(this._htmlElement);
        this._mouseManager = MouseManager.getInstance();
        this._mouseManager.registerView(this);
        //			if (this._shareContext)
        //				this._mouse3DManager.addViewLayer(this);
    }
    /**
     *
     * @param e
     */
    View.prototype.onScenePartitionChanged = function (event) {
        if (this._pCamera)
            this._pCamera.partition = this.scene.partition;
    };
    Object.defineProperty(View.prototype, "mouseX", {
        get: function () {
            return this._pMouseX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "mouseY", {
        get: function () {
            return this._pMouseY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "htmlElement", {
        /**
         *
         */
        get: function () {
            return this._htmlElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "renderer", {
        /**
         *
         */
        get: function () {
            return this._pRenderer;
        },
        set: function (value) {
            if (this._pRenderer == value)
                return;
            if (this._pRenderer) {
                this._pRenderer.dispose();
                this._pRenderer.removeEventListener(RendererEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
                this._pRenderer.removeEventListener(RendererEvent.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
            }
            this._pRenderer = value;
            this._pRenderer.addEventListener(RendererEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
            this._pRenderer.addEventListener(RendererEvent.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
            //reset entity collector
            this._pEntityCollector = this._pRenderer._iCreateEntityCollector();
            if (this._pCamera)
                this._pEntityCollector.camera = this._pCamera;
            //reset back buffer
            this._pRenderer._iBackgroundR = ((this._backgroundColor >> 16) & 0xff) / 0xff;
            this._pRenderer._iBackgroundG = ((this._backgroundColor >> 8) & 0xff) / 0xff;
            this._pRenderer._iBackgroundB = (this._backgroundColor & 0xff) / 0xff;
            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha;
            this._pRenderer.width = this._width;
            this._pRenderer.height = this._height;
            this._pRenderer.shareContext = this._shareContext;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "shareContext", {
        /**
         *
         */
        get: function () {
            return this._shareContext;
        },
        set: function (value) {
            if (this._shareContext == value)
                return;
            this._shareContext = value;
            if (this._pRenderer)
                this._pRenderer.shareContext = this._shareContext;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "backgroundColor", {
        /**
         *
         */
        get: function () {
            return this._backgroundColor;
        },
        set: function (value) {
            if (this._backgroundColor == value)
                return;
            this._backgroundColor = value;
            this._pRenderer._iBackgroundR = ((value >> 16) & 0xff) / 0xff;
            this._pRenderer._iBackgroundG = ((value >> 8) & 0xff) / 0xff;
            this._pRenderer._iBackgroundB = (value & 0xff) / 0xff;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "backgroundAlpha", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._backgroundAlpha;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            if (this._backgroundAlpha == value)
                return;
            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "camera", {
        /**
         *
         * @returns {Camera3D}
         */
        get: function () {
            return this._pCamera;
        },
        /**
         * Set camera that's used to render the scene for this viewport
         */
        set: function (value) {
            if (this._pCamera == value)
                return;
            if (this._pCamera)
                this._pCamera.removeEventListener(CameraEvent.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
            this._pCamera = value;
            if (this._pEntityCollector)
                this._pEntityCollector.camera = this._pCamera;
            if (this._pScene)
                this._pCamera.partition = this._pScene.partition;
            this._pCamera.addEventListener(CameraEvent.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
            this._scissorDirty = true;
            this._viewportDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "scene", {
        /**
         *
         * @returns {away.containers.Scene3D}
         */
        get: function () {
            return this._pScene;
        },
        /**
         * Set the scene that's used to render for this viewport
         */
        set: function (value) {
            if (this._pScene == value)
                return;
            if (this._pScene)
                this._pScene.removeEventListener(SceneEvent.PARTITION_CHANGED, this._onScenePartitionChangedDelegate);
            this._pScene = value;
            this._pScene.addEventListener(SceneEvent.PARTITION_CHANGED, this._onScenePartitionChangedDelegate);
            if (this._pCamera)
                this._pCamera.partition = this._pScene.partition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "deltaTime", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._deltaTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "width", {
        /**
         *
         */
        get: function () {
            return this._width;
        },
        set: function (value) {
            if (this._width == value)
                return;
            this._width = value;
            this._aspectRatio = this._width / this._height;
            this._pCamera.projection._iAspectRatio = this._aspectRatio;
            this._pRenderer.width = value;
            this._htmlElement.style.width = value + "px";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "height", {
        /**
         *
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            if (this._height == value)
                return;
            this._height = value;
            this._aspectRatio = this._width / this._height;
            this._pCamera.projection._iAspectRatio = this._aspectRatio;
            this._pRenderer.height = value;
            this._htmlElement.style.height = value + "px";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "mousePicker", {
        /**
         *
         */
        get: function () {
            return this._mousePicker;
        },
        set: function (value) {
            if (this._mousePicker == value)
                return;
            if (value == null)
                this._mousePicker = new RaycastPicker();
            else
                this._mousePicker = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "x", {
        /**
         *
         */
        get: function () {
            return this._pRenderer.x;
        },
        set: function (value) {
            if (this._pRenderer.x == value)
                return;
            this._pRenderer.x == value;
            this._htmlElement.style.left = value + "px";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "y", {
        /**
         *
         */
        get: function () {
            return this._pRenderer.y;
        },
        set: function (value) {
            if (this._pRenderer.y == value)
                return;
            this._pRenderer.y == value;
            this._htmlElement.style.top = value + "px";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "visible", {
        /**
         *
         */
        get: function () {
            return (this._htmlElement.style.visibility == "visible");
        },
        set: function (value) {
            this._htmlElement.style.visibility = value ? "visible" : "hidden";
            //TODO transfer visible property to associated context (if one exists)
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "renderedFacesCount", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return 0; //TODO
            //return this._pEntityCollector._pNumTriangles;//numTriangles;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Renders the view.
     */
    View.prototype.render = function () {
        this.pUpdateTime();
        //update view and size data
        this._pCamera.projection._iAspectRatio = this._aspectRatio;
        if (this._scissorDirty) {
            this._scissorDirty = false;
            this._pCamera.projection._iUpdateScissorRect(this._pRenderer.scissorRect.x, this._pRenderer.scissorRect.y, this._pRenderer.scissorRect.width, this._pRenderer.scissorRect.height);
        }
        if (this._viewportDirty) {
            this._viewportDirty = false;
            this._pCamera.projection._iUpdateViewport(this._pRenderer.viewPort.x, this._pRenderer.viewPort.y, this._pRenderer.viewPort.width, this._pRenderer.viewPort.height);
        }
        // update picking
        if (!this._shareContext) {
            if (this.forceMouseMove && this._htmlElement == this._mouseManager._iActiveDiv && !this._mouseManager._iUpdateDirty)
                this._mouseManager._iCollidingObject = this.mousePicker.getViewCollision(this._pMouseX, this._pMouseY, this);
            this._mouseManager.fireMouseEvents(this.forceMouseMove);
        }
        //_touch3DManager.updateCollider();
        //clear entity collector ready for collection
        this._pEntityCollector.clear();
        // collect stuff to render
        this._pScene.traversePartitions(this._pEntityCollector);
        //render the contents of the entity collector
        this._pRenderer.render(this._pEntityCollector);
    };
    /**
     *
     */
    View.prototype.pUpdateTime = function () {
        var time = getTimer();
        if (this._time == 0)
            this._time = time;
        this._deltaTime = time - this._time;
        this._time = time;
    };
    /**
     *
     */
    View.prototype.dispose = function () {
        this._pRenderer.dispose();
        // TODO: imeplement mouseManager / touch3DManager
        this._mouseManager.unregisterView(this);
        //this._touch3DManager.disableTouchListeners(this);
        //this._touch3DManager.dispose();
        this._mouseManager = null;
        //this._touch3DManager = null;
        this._pRenderer = null;
        this._pEntityCollector = null;
    };
    Object.defineProperty(View.prototype, "iEntityCollector", {
        /**
         *
         */
        get: function () {
            return this._pEntityCollector;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    View.prototype.onProjectionChanged = function (event) {
        this._scissorDirty = true;
        this._viewportDirty = true;
    };
    /**
     *
     */
    View.prototype.onViewportUpdated = function (event) {
        this._viewportDirty = true;
    };
    /**
     *
     */
    View.prototype.onScissorUpdated = function (event) {
        this._scissorDirty = true;
    };
    View.prototype.project = function (point3d) {
        var v = this._pCamera.project(point3d);
        v.x = v.x * this._pRenderer.viewPort.width / 2 + this._width * this._pCamera.projection.originX;
        v.y = v.y * this._pRenderer.viewPort.height / 2 + this._height * this._pCamera.projection.originY;
        return v;
    };
    View.prototype.unproject = function (sX, sY, sZ) {
        return this._pCamera.unproject(2 * (sX - this._width * this._pCamera.projection.originX) / this._pRenderer.viewPort.width, 2 * (sY - this._height * this._pCamera.projection.originY) / this._pRenderer.viewPort.height, sZ);
    };
    View.prototype.getRay = function (sX, sY, sZ) {
        return this._pCamera.getRay((sX * 2 - this._width) / this._width, (sY * 2 - this._height) / this._height, sZ);
    };
    /*TODO: implement Background
     public get background():away.textures.Texture2DBase
     {
     return this._background;
     }
     */
    /*TODO: implement Background
     public set background( value:away.textures.Texture2DBase )
     {
     this._background = value;
     this._renderer.background = _background;
     }
     */
    // TODO: required dependency stageGL
    View.prototype.updateCollider = function () {
        if (!this._shareContext) {
            if (this._htmlElement == this._mouseManager._iActiveDiv)
                this._mouseManager._iCollidingObject = this.mousePicker.getViewCollision(this._pMouseX, this._pMouseY, this);
        }
        else {
            var collidingObject = this.mousePicker.getViewCollision(this._pMouseX, this._pMouseY, this);
            if (this.layeredView || this._mouseManager._iCollidingObject == null || collidingObject.rayEntryDistance < this._mouseManager._iCollidingObject.rayEntryDistance)
                this._mouseManager._iCollidingObject = collidingObject;
        }
    };
    return View;
})();
module.exports = View;


},{"awayjs-core/lib/utils/getTimer":133,"awayjs-display/lib/containers/Scene":63,"awayjs-display/lib/entities/Camera":65,"awayjs-display/lib/events/CameraEvent":69,"awayjs-display/lib/events/RendererEvent":73,"awayjs-display/lib/events/SceneEvent":74,"awayjs-display/lib/managers/MouseManager":75,"awayjs-display/lib/pick/RaycastPicker":90}],65:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var NullBounds = require("awayjs-core/lib/bounds/NullBounds");
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Plane3D = require("awayjs-core/lib/geom/Plane3D");
var AssetType = require("awayjs-core/lib/library/AssetType");
var ProjectionEvent = require("awayjs-core/lib/events/ProjectionEvent");
var PerspectiveProjection = require("awayjs-core/lib/projections/PerspectiveProjection");
var DisplayObjectContainer = require("awayjs-display/lib/containers/DisplayObjectContainer");
var CameraEvent = require("awayjs-display/lib/events/CameraEvent");
var CameraNode = require("awayjs-display/lib/partition/CameraNode");
var Camera = (function (_super) {
    __extends(Camera, _super);
    function Camera(projection) {
        var _this = this;
        if (projection === void 0) { projection = null; }
        _super.call(this);
        this._viewProjection = new Matrix3D();
        this._viewProjectionDirty = true;
        this._frustumPlanesDirty = true;
        this._pIsEntity = true;
        this._onProjectionMatrixChangedDelegate = function (event) { return _this.onProjectionMatrixChanged(event); };
        this._projection = projection || new PerspectiveProjection();
        this._projection.addEventListener(ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
        this._frustumPlanes = [];
        for (var i = 0; i < 6; ++i)
            this._frustumPlanes[i] = new Plane3D();
        this.z = -1000;
    }
    Camera.prototype.pCreateDefaultBoundingVolume = function () {
        return new NullBounds();
    };
    /**
     * @protected
     */
    Camera.prototype.pCreateEntityPartitionNode = function () {
        return new CameraNode(this);
    };
    Object.defineProperty(Camera.prototype, "assetType", {
        //@override
        get: function () {
            return AssetType.CAMERA;
        },
        enumerable: true,
        configurable: true
    });
    Camera.prototype.onProjectionMatrixChanged = function (event) {
        this._viewProjectionDirty = true;
        this._frustumPlanesDirty = true;
        this.dispatchEvent(event);
    };
    Object.defineProperty(Camera.prototype, "frustumPlanes", {
        get: function () {
            if (this._frustumPlanesDirty)
                this.updateFrustum();
            return this._frustumPlanes;
        },
        enumerable: true,
        configurable: true
    });
    Camera.prototype.updateFrustum = function () {
        var a, b, c;
        //var d : Number;
        var c11, c12, c13, c14;
        var c21, c22, c23, c24;
        var c31, c32, c33, c34;
        var c41, c42, c43, c44;
        var p;
        var raw = new Array(16);
        ;
        var invLen;
        this.viewProjection.copyRawDataTo(raw);
        c11 = raw[0];
        c12 = raw[4];
        c13 = raw[8];
        c14 = raw[12];
        c21 = raw[1];
        c22 = raw[5];
        c23 = raw[9];
        c24 = raw[13];
        c31 = raw[2];
        c32 = raw[6];
        c33 = raw[10];
        c34 = raw[14];
        c41 = raw[3];
        c42 = raw[7];
        c43 = raw[11];
        c44 = raw[15];
        // left plane
        p = this._frustumPlanes[0];
        a = c41 + c11;
        b = c42 + c12;
        c = c43 + c13;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = -(c44 + c14) * invLen;
        // right plane
        p = this._frustumPlanes[1];
        a = c41 - c11;
        b = c42 - c12;
        c = c43 - c13;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = (c14 - c44) * invLen;
        // bottom
        p = this._frustumPlanes[2];
        a = c41 + c21;
        b = c42 + c22;
        c = c43 + c23;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = -(c44 + c24) * invLen;
        // top
        p = this._frustumPlanes[3];
        a = c41 - c21;
        b = c42 - c22;
        c = c43 - c23;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = (c24 - c44) * invLen;
        // near
        p = this._frustumPlanes[4];
        a = c31;
        b = c32;
        c = c33;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = -c34 * invLen;
        // far
        p = this._frustumPlanes[5];
        a = c41 - c31;
        b = c42 - c32;
        c = c43 - c33;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = (c34 - c44) * invLen;
        this._frustumPlanesDirty = false;
    };
    /**
     * @protected
     */
    Camera.prototype.pInvalidateSceneTransform = function () {
        _super.prototype.pInvalidateSceneTransform.call(this);
        this._viewProjectionDirty = true;
        this._frustumPlanesDirty = true;
    };
    /**
     * @protected
     */
    Camera.prototype.pUpdateBounds = function () {
        this._pBoundsInvalid = false;
        this._pBounds.nullify();
    };
    Object.defineProperty(Camera.prototype, "projection", {
        /**
         *
         */
        get: function () {
            return this._projection;
        },
        set: function (value) {
            if (this._projection == value)
                return;
            if (!value)
                throw new Error("Projection cannot be null!");
            this._projection.removeEventListener(ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
            this._projection = value;
            this._projection.addEventListener(ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
            this.dispatchEvent(new CameraEvent(CameraEvent.PROJECTION_CHANGED, this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "viewProjection", {
        /**
         *
         */
        get: function () {
            if (this._viewProjectionDirty) {
                this._viewProjection.copyFrom(this.inverseSceneTransform);
                this._viewProjection.append(this._projection.matrix);
                this._viewProjectionDirty = false;
            }
            return this._viewProjection;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calculates the ray in scene space from the camera to the given normalized coordinates in screen space.
     *
     * @param nX The normalised x coordinate in screen space, -1 corresponds to the left edge of the viewport, 1 to the right.
     * @param nY The normalised y coordinate in screen space, -1 corresponds to the top edge of the viewport, 1 to the bottom.
     * @param sZ The z coordinate in screen space, representing the distance into the screen.
     * @return The ray from the camera to the scene space position of the given screen coordinates.
     */
    Camera.prototype.getRay = function (nX, nY, sZ) {
        return this.sceneTransform.deltaTransformVector(this._projection.unproject(nX, nY, sZ));
    };
    /**
     * Calculates the normalised position in screen space of the given scene position.
     *
     * @param point3d the position vector of the scene coordinates to be projected.
     * @return The normalised screen position of the given scene coordinates.
     */
    Camera.prototype.project = function (point3d) {
        return this._projection.project(this.inverseSceneTransform.transformVector(point3d));
    };
    /**
     * Calculates the scene position of the given normalized coordinates in screen space.
     *
     * @param nX The normalised x coordinate in screen space, minus the originX offset of the projection property.
     * @param nY The normalised y coordinate in screen space, minus the originY offset of the projection property.
     * @param sZ The z coordinate in screen space, representing the distance into the screen.
     * @return The scene position of the given screen coordinates.
     */
    Camera.prototype.unproject = function (nX, nY, sZ) {
        return this.sceneTransform.transformVector(this._projection.unproject(nX, nY, sZ));
    };
    Camera.prototype._iCollectRenderables = function (renderer) {
        // Since this getter is invoked every iteration of the render loop, and
        // the prefab construct could affect the sub-meshes, the prefab is
        // validated here to give it a chance to rebuild.
        if (this._iSourcePrefab)
            this._iSourcePrefab._iValidate();
        this._iCollectRenderable(renderer);
    };
    Camera.prototype._iCollectRenderable = function (renderer) {
        //nothing to do here
    };
    return Camera;
})(DisplayObjectContainer);
module.exports = Camera;


},{"awayjs-core/lib/bounds/NullBounds":100,"awayjs-core/lib/events/ProjectionEvent":109,"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Plane3D":116,"awayjs-core/lib/library/AssetType":121,"awayjs-core/lib/projections/PerspectiveProjection":125,"awayjs-display/lib/containers/DisplayObjectContainer":62,"awayjs-display/lib/events/CameraEvent":69,"awayjs-display/lib/partition/CameraNode":81}],66:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var NullBounds = require("awayjs-core/lib/bounds/NullBounds");
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var LightBase = require("awayjs-display/lib/base/LightBase");
var DirectionalLightNode = require("awayjs-display/lib/partition/DirectionalLightNode");
var DirectionalShadowMapper = require("awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper");
var DirectionalLight = (function (_super) {
    __extends(DirectionalLight, _super);
    function DirectionalLight(xDir, yDir, zDir) {
        if (xDir === void 0) { xDir = 0; }
        if (yDir === void 0) { yDir = -1; }
        if (zDir === void 0) { zDir = 1; }
        _super.call(this);
        this._pIsEntity = true;
        this.direction = new Vector3D(xDir, yDir, zDir);
        this._sceneDirection = new Vector3D();
    }
    Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
        get: function () {
            if (this._pSceneTransformDirty)
                this.pUpdateSceneTransform();
            return this._sceneDirection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalLight.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (value) {
            this._direction = value;
            if (!this._tmpLookAt)
                this._tmpLookAt = new Vector3D();
            this._tmpLookAt.x = this.x + this._direction.x;
            this._tmpLookAt.y = this.y + this._direction.y;
            this._tmpLookAt.z = this.z + this._direction.z;
            this.lookAt(this._tmpLookAt);
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @returns {away.bounds.NullBounds}
     */
    DirectionalLight.prototype.pCreateDefaultBoundingVolume = function () {
        //directional lights are to be considered global, hence always in view
        return new NullBounds();
    };
    /**
     *
     */
    DirectionalLight.prototype.pUpdateBounds = function () {
    };
    //@override
    DirectionalLight.prototype.pUpdateSceneTransform = function () {
        _super.prototype.pUpdateSceneTransform.call(this);
        this.sceneTransform.copyColumnTo(2, this._sceneDirection);
        this._sceneDirection.normalize();
    };
    //@override
    DirectionalLight.prototype.pCreateShadowMapper = function () {
        return new DirectionalShadowMapper();
    };
    /**
     * @protected
     */
    DirectionalLight.prototype.pCreateEntityPartitionNode = function () {
        return new DirectionalLightNode(this);
    };
    //override
    DirectionalLight.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
        if (target === void 0) { target = null; }
        var raw = new Array();
        var bounds = entity.bounds;
        var m = new Matrix3D();
        m.copyFrom(entity.getRenderSceneTransform(camera));
        m.append(this.inverseSceneTransform);
        if (!this._projAABBPoints)
            this._projAABBPoints = [];
        m.transformVectors(bounds.aabbPoints, this._projAABBPoints);
        var xMin = Infinity, xMax = -Infinity;
        var yMin = Infinity, yMax = -Infinity;
        var zMin = Infinity, zMax = -Infinity;
        var d;
        for (var i = 0; i < 24;) {
            d = this._projAABBPoints[i++];
            if (d < xMin)
                xMin = d;
            if (d > xMax)
                xMax = d;
            d = this._projAABBPoints[i++];
            if (d < yMin)
                yMin = d;
            if (d > yMax)
                yMax = d;
            d = this._projAABBPoints[i++];
            if (d < zMin)
                zMin = d;
            if (d > zMax)
                zMax = d;
        }
        var invXRange = 1 / (xMax - xMin);
        var invYRange = 1 / (yMax - yMin);
        var invZRange = 1 / (zMax - zMin);
        raw[0] = 2 * invXRange;
        raw[5] = 2 * invYRange;
        raw[10] = invZRange;
        raw[12] = -(xMax + xMin) * invXRange;
        raw[13] = -(yMax + yMin) * invYRange;
        raw[14] = -zMin * invZRange;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
        raw[15] = 1;
        if (!target)
            target = new Matrix3D();
        target.copyRawDataFrom(raw);
        target.prepend(m);
        return target;
    };
    DirectionalLight.prototype._iCollectRenderables = function (renderer) {
        //nothing to do here
    };
    return DirectionalLight;
})(LightBase);
module.exports = DirectionalLight;


},{"awayjs-core/lib/bounds/NullBounds":100,"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Vector3D":120,"awayjs-display/lib/base/LightBase":59,"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper":79,"awayjs-display/lib/partition/DirectionalLightNode":82}],67:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var NullBounds = require("awayjs-core/lib/bounds/NullBounds");
var Error = require("awayjs-core/lib/errors/Error");
var LightBase = require("awayjs-display/lib/base/LightBase");
var LightProbeNode = require("awayjs-display/lib/partition/LightProbeNode");
var LightProbe = (function (_super) {
    __extends(LightProbe, _super);
    function LightProbe(diffuseMap, specularMap) {
        if (specularMap === void 0) { specularMap = null; }
        _super.call(this);
        this._pIsEntity = true;
        this._diffuseMap = diffuseMap;
        this._specularMap = specularMap;
    }
    Object.defineProperty(LightProbe.prototype, "diffuseMap", {
        get: function () {
            return this._diffuseMap;
        },
        set: function (value) {
            this._diffuseMap = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightProbe.prototype, "specularMap", {
        get: function () {
            return this._specularMap;
        },
        set: function (value) {
            this._specularMap = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     */
    LightProbe.prototype.pCreateEntityPartitionNode = function () {
        return new LightProbeNode(this);
    };
    //@override
    LightProbe.prototype.pUpdateBounds = function () {
        this._pBoundsInvalid = false;
    };
    //@override
    LightProbe.prototype.pCreateDefaultBoundingVolume = function () {
        return new NullBounds();
    };
    //@override
    LightProbe.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
        if (target === void 0) { target = null; }
        throw new Error("Object projection matrices are not supported for LightProbe objects!");
    };
    LightProbe.prototype._iCollectRenderables = function (renderer) {
        //nothing to do here
    };
    return LightProbe;
})(LightBase);
module.exports = LightProbe;


},{"awayjs-core/lib/bounds/NullBounds":100,"awayjs-core/lib/errors/Error":103,"awayjs-display/lib/base/LightBase":59,"awayjs-display/lib/partition/LightProbeNode":84}],68:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BoundingSphere = require("awayjs-core/lib/bounds/BoundingSphere");
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var LightBase = require("awayjs-display/lib/base/LightBase");
var PointLightNode = require("awayjs-display/lib/partition/PointLightNode");
var CubeMapShadowMapper = require("awayjs-display/lib/materials/shadowmappers/CubeMapShadowMapper");
var PointLight = (function (_super) {
    __extends(PointLight, _super);
    function PointLight() {
        _super.call(this);
        this._pRadius = 90000;
        this._pFallOff = 100000;
        this._pIsEntity = true;
        this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
    }
    PointLight.prototype.pCreateShadowMapper = function () {
        return new CubeMapShadowMapper();
    };
    Object.defineProperty(PointLight.prototype, "radius", {
        get: function () {
            return this._pRadius;
        },
        set: function (value) {
            this._pRadius = value;
            if (this._pRadius < 0) {
                this._pRadius = 0;
            }
            else if (this._pRadius > this._pFallOff) {
                this._pFallOff = this._pRadius;
                this.pInvalidateBounds();
            }
            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
        },
        enumerable: true,
        configurable: true
    });
    PointLight.prototype.iFallOffFactor = function () {
        return this._pFallOffFactor;
    };
    Object.defineProperty(PointLight.prototype, "fallOff", {
        get: function () {
            return this._pFallOff;
        },
        set: function (value) {
            this._pFallOff = value;
            if (this._pFallOff < 0)
                this._pFallOff = 0;
            if (this._pFallOff < this._pRadius)
                this._pRadius = this._pFallOff;
            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
            this.pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     */
    PointLight.prototype.pCreateEntityPartitionNode = function () {
        return new PointLightNode(this);
    };
    PointLight.prototype.pUpdateBounds = function () {
        this._pBounds.fromSphere(new Vector3D(), this._pFallOff);
        this._pBoundsInvalid = false;
    };
    PointLight.prototype.pCreateDefaultBoundingVolume = function () {
        //point lights are culled based on their falloff radius
        return new BoundingSphere();
    };
    PointLight.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
        if (target === void 0) { target = null; }
        var raw = new Array(16);
        var bounds = entity.bounds;
        var m = new Matrix3D();
        // todo: do not use lookAt on Light
        m.copyFrom(entity.getRenderSceneTransform(camera));
        m.append(this._pParent.inverseSceneTransform);
        this.lookAt(m.position);
        m.copyFrom(entity.getRenderSceneTransform(camera));
        m.append(this.inverseSceneTransform);
        var box = bounds.aabb;
        var v1 = m.deltaTransformVector(new Vector3D(box.left, box.bottom, box.front));
        var v2 = m.deltaTransformVector(new Vector3D(box.right, box.top, box.back));
        var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
        var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
        var d = Math.sqrt(d1 > d2 ? d1 : d2);
        var zMin;
        var zMax;
        var z = m.rawData[14];
        zMin = z - d;
        zMax = z + d;
        raw[5] = raw[0] = zMin / d;
        raw[10] = zMax / (zMax - zMin);
        raw[11] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
        raw[14] = -zMin * raw[10];
        if (!target)
            target = new Matrix3D();
        target.copyRawDataFrom(raw);
        target.prepend(m);
        return target;
    };
    PointLight.prototype._iCollectRenderables = function (renderer) {
        //nothing to do here
    };
    return PointLight;
})(LightBase);
module.exports = PointLight;


},{"awayjs-core/lib/bounds/BoundingSphere":98,"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Vector3D":120,"awayjs-display/lib/base/LightBase":59,"awayjs-display/lib/materials/shadowmappers/CubeMapShadowMapper":78,"awayjs-display/lib/partition/PointLightNode":88}],69:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
/**
 * @class away.events.CameraEvent
 */
var CameraEvent = (function (_super) {
    __extends(CameraEvent, _super);
    function CameraEvent(type, camera) {
        _super.call(this, type);
        this._camera = camera;
    }
    Object.defineProperty(CameraEvent.prototype, "camera", {
        get: function () {
            return this._camera;
        },
        enumerable: true,
        configurable: true
    });
    CameraEvent.PROJECTION_CHANGED = "projectionChanged";
    return CameraEvent;
})(Event);
module.exports = CameraEvent;


},{"awayjs-core/lib/events/Event":107}],70:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var DisplayObjectEvent = (function (_super) {
    __extends(DisplayObjectEvent, _super);
    function DisplayObjectEvent(type, object) {
        _super.call(this, type);
        this.object = object;
    }
    DisplayObjectEvent.VISIBLITY_UPDATED = "visiblityUpdated";
    DisplayObjectEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
    DisplayObjectEvent.SCENE_CHANGED = "sceneChanged";
    DisplayObjectEvent.POSITION_CHANGED = "positionChanged";
    DisplayObjectEvent.ROTATION_CHANGED = "rotationChanged";
    DisplayObjectEvent.SCALE_CHANGED = "scaleChanged";
    return DisplayObjectEvent;
})(Event);
module.exports = DisplayObjectEvent;


},{"awayjs-core/lib/events/Event":107}],71:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var LightEvent = (function (_super) {
    __extends(LightEvent, _super);
    function LightEvent(type) {
        _super.call(this, type);
    }
    //@override
    LightEvent.prototype.clone = function () {
        return new LightEvent(this.type);
    };
    LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
    return LightEvent;
})(Event);
module.exports = LightEvent;


},{"awayjs-core/lib/events/Event":107}],72:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
/**
 * A MouseEvent is dispatched when a mouse event occurs over a mouseEnabled object in View.
 * TODO: we don't have screenZ data, tho this should be easy to implement
 */
var MouseEvent = (function (_super) {
    __extends(MouseEvent, _super);
    /**
     * Create a new MouseEvent object.
     * @param type The type of the MouseEvent.
     */
    function MouseEvent(type) {
        _super.call(this, type);
        // Private.
        this._iAllowedToPropagate = true;
    }
    Object.defineProperty(MouseEvent.prototype, "bubbles", {
        /**
         * @inheritDoc
         */
        get: function () {
            var doesBubble = this._iAllowedToPropagate;
            this._iAllowedToPropagate = true;
            // Don't bubble if propagation has been stopped.
            return doesBubble;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    MouseEvent.prototype.stopPropagation = function () {
        this._iAllowedToPropagate = false;
        if (this._iParentEvent)
            this._iParentEvent.stopPropagation();
    };
    /**
     * @inheritDoc
     */
    MouseEvent.prototype.stopImmediatePropagation = function () {
        this._iAllowedToPropagate = false;
        if (this._iParentEvent)
            this._iParentEvent.stopImmediatePropagation();
    };
    /**
     * Creates a copy of the MouseEvent object and sets the value of each property to match that of the original.
     */
    MouseEvent.prototype.clone = function () {
        var result = new MouseEvent(this.type);
        /* TODO: Debug / test - look into isDefaultPrevented
         if (isDefaultPrevented())
         result.preventDefault();
         */
        result.screenX = this.screenX;
        result.screenY = this.screenY;
        result.view = this.view;
        result.object = this.object;
        result.materialOwner = this.materialOwner;
        result.material = this.material;
        result.uv = this.uv;
        result.localPosition = this.localPosition;
        result.localNormal = this.localNormal;
        result.index = this.index;
        result.subGeometryIndex = this.subGeometryIndex;
        result.delta = this.delta;
        result.ctrlKey = this.ctrlKey;
        result.shiftKey = this.shiftKey;
        result._iParentEvent = this;
        result._iAllowedToPropagate = this._iAllowedToPropagate;
        return result;
    };
    Object.defineProperty(MouseEvent.prototype, "scenePosition", {
        /**
         * The position in scene space where the event took place
         */
        get: function () {
            return this.object.sceneTransform.transformVector(this.localPosition);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEvent.prototype, "sceneNormal", {
        /**
         * The normal in scene space where the event took place
         */
        get: function () {
            var sceneNormal = this.object.sceneTransform.deltaTransformVector(this.localNormal);
            sceneNormal.normalize();
            return sceneNormal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Defines the value of the type property of a mouseOver3d event object.
     */
    MouseEvent.MOUSE_OVER = "mouseOver3d";
    /**
     * Defines the value of the type property of a mouseOut3d event object.
     */
    MouseEvent.MOUSE_OUT = "mouseOut3d";
    /**
     * Defines the value of the type property of a mouseUp3d event object.
     */
    MouseEvent.MOUSE_UP = "mouseUp3d";
    /**
     * Defines the value of the type property of a mouseDown3d event object.
     */
    MouseEvent.MOUSE_DOWN = "mouseDown3d";
    /**
     * Defines the value of the type property of a mouseMove3d event object.
     */
    MouseEvent.MOUSE_MOVE = "mouseMove3d";
    /**
     * Defines the value of the type property of a rollOver3d event object.
     */
    //		public static ROLL_OVER : string = "rollOver3d";
    /**
     * Defines the value of the type property of a rollOut3d event object.
     */
    //		public static ROLL_OUT : string = "rollOut3d";
    /**
     * Defines the value of the type property of a click3d event object.
     */
    MouseEvent.CLICK = "click3d";
    /**
     * Defines the value of the type property of a doubleClick3d event object.
     */
    MouseEvent.DOUBLE_CLICK = "doubleClick3d";
    /**
     * Defines the value of the type property of a mouseWheel3d event object.
     */
    MouseEvent.MOUSE_WHEEL = "mouseWheel3d";
    return MouseEvent;
})(Event);
module.exports = MouseEvent;


},{"awayjs-core/lib/events/Event":107}],73:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var RendererEvent = (function (_super) {
    __extends(RendererEvent, _super);
    function RendererEvent(type) {
        _super.call(this, type);
    }
    RendererEvent.VIEWPORT_UPDATED = "viewportUpdated";
    RendererEvent.SCISSOR_UPDATED = "scissorUpdated";
    return RendererEvent;
})(Event);
module.exports = RendererEvent;


},{"awayjs-core/lib/events/Event":107}],74:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var SceneEvent = (function (_super) {
    __extends(SceneEvent, _super);
    function SceneEvent(type, displayObject) {
        _super.call(this, type);
        this.displayObject = displayObject;
    }
    /**
     *
     */
    SceneEvent.ADDED_TO_SCENE = "addedToScene";
    /**
     *
     */
    SceneEvent.REMOVED_FROM_SCENE = "removedFromScene";
    /**
     *
     */
    SceneEvent.PARTITION_CHANGED = "partitionChanged";
    return SceneEvent;
})(Event);
module.exports = SceneEvent;


},{"awayjs-core/lib/events/Event":107}],75:[function(require,module,exports){
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var AwayMouseEvent = require("awayjs-display/lib/events/MouseEvent");
/**
 * MouseManager enforces a singleton pattern and is not intended to be instanced.
 * it provides a manager class for detecting mouse hits on scene objects and sending out mouse events.
 */
var MouseManager = (function () {
    /**
     * Creates a new <code>MouseManager</code> object.
     */
    function MouseManager() {
        var _this = this;
        this._viewLookup = new Array();
        this._nullVector = new Vector3D();
        this._queuedEvents = new Array();
        this._mouseUp = new AwayMouseEvent(AwayMouseEvent.MOUSE_UP);
        this._mouseClick = new AwayMouseEvent(AwayMouseEvent.CLICK);
        this._mouseOut = new AwayMouseEvent(AwayMouseEvent.MOUSE_OUT);
        this._mouseDown = new AwayMouseEvent(AwayMouseEvent.MOUSE_DOWN);
        this._mouseMove = new AwayMouseEvent(AwayMouseEvent.MOUSE_MOVE);
        this._mouseOver = new AwayMouseEvent(AwayMouseEvent.MOUSE_OVER);
        this._mouseWheel = new AwayMouseEvent(AwayMouseEvent.MOUSE_WHEEL);
        this._mouseDoubleClick = new AwayMouseEvent(AwayMouseEvent.DOUBLE_CLICK);
        this.onClickDelegate = function (event) { return _this.onClick(event); };
        this.onDoubleClickDelegate = function (event) { return _this.onDoubleClick(event); };
        this.onMouseDownDelegate = function (event) { return _this.onMouseDown(event); };
        this.onMouseMoveDelegate = function (event) { return _this.onMouseMove(event); };
        this.onMouseUpDelegate = function (event) { return _this.onMouseUp(event); };
        this.onMouseWheelDelegate = function (event) { return _this.onMouseWheel(event); };
        this.onMouseOverDelegate = function (event) { return _this.onMouseOver(event); };
        this.onMouseOutDelegate = function (event) { return _this.onMouseOut(event); };
    }
    MouseManager.getInstance = function () {
        if (this._instance)
            return this._instance;
        return (this._instance = new MouseManager());
    };
    MouseManager.prototype.fireMouseEvents = function (forceMouseMove) {
        // If colliding object has changed, queue over/out events.
        if (this._iCollidingObject != this._previousCollidingObject) {
            if (this._previousCollidingObject)
                this.queueDispatch(this._mouseOut, this._mouseMoveEvent, this._previousCollidingObject);
            if (this._iCollidingObject)
                this.queueDispatch(this._mouseOver, this._mouseMoveEvent);
        }
        // Fire mouse move events here if forceMouseMove is on.
        if (forceMouseMove && this._iCollidingObject)
            this.queueDispatch(this._mouseMove, this._mouseMoveEvent);
        var event;
        var dispatcher;
        // Dispatch all queued events.
        var len = this._queuedEvents.length;
        for (var i = 0; i < len; ++i) {
            // Only dispatch from first implicitly enabled object ( one that is not a child of a mouseChildren = false hierarchy ).
            event = this._queuedEvents[i];
            dispatcher = event.object;
            while (dispatcher && !dispatcher._iIsMouseEnabled())
                dispatcher = dispatcher.parent;
            if (dispatcher)
                dispatcher.dispatchEvent(event);
        }
        this._queuedEvents.length = 0;
        this._previousCollidingObject = this._iCollidingObject;
        this._iUpdateDirty = false;
    };
    //		public addViewLayer(view:View)
    //		{
    //			var stg:Stage = view.stage;
    //
    //			// Add instance to mouse3dmanager to fire mouse events for multiple views
    //			if (!view.stageGL.mouse3DManager)
    //				view.stageGL.mouse3DManager = this;
    //
    //			if (!hasKey(view))
    //				_view3Ds[view] = 0;
    //
    //			_childDepth = 0;
    //			traverseDisplayObjects(stg);
    //			_viewCount = _childDepth;
    //		}
    MouseManager.prototype.registerView = function (view) {
        view.htmlElement.addEventListener("click", this.onClickDelegate);
        view.htmlElement.addEventListener("dblclick", this.onDoubleClickDelegate);
        view.htmlElement.addEventListener("mousedown", this.onMouseDownDelegate);
        view.htmlElement.addEventListener("mousemove", this.onMouseMoveDelegate);
        view.htmlElement.addEventListener("mouseup", this.onMouseUpDelegate);
        view.htmlElement.addEventListener("mousewheel", this.onMouseWheelDelegate);
        view.htmlElement.addEventListener("mouseover", this.onMouseOverDelegate);
        view.htmlElement.addEventListener("mouseout", this.onMouseOutDelegate);
        this._viewLookup.push(view);
    };
    MouseManager.prototype.unregisterView = function (view) {
        view.htmlElement.removeEventListener("click", this.onClickDelegate);
        view.htmlElement.removeEventListener("dblclick", this.onDoubleClickDelegate);
        view.htmlElement.removeEventListener("mousedown", this.onMouseDownDelegate);
        view.htmlElement.removeEventListener("mousemove", this.onMouseMoveDelegate);
        view.htmlElement.removeEventListener("mouseup", this.onMouseUpDelegate);
        view.htmlElement.removeEventListener("mousewheel", this.onMouseWheelDelegate);
        view.htmlElement.removeEventListener("mouseover", this.onMouseOverDelegate);
        view.htmlElement.removeEventListener("mouseout", this.onMouseOutDelegate);
        this._viewLookup.slice(this._viewLookup.indexOf(view), 1);
    };
    // ---------------------------------------------------------------------
    // Private.
    // ---------------------------------------------------------------------
    MouseManager.prototype.queueDispatch = function (event, sourceEvent, collider) {
        if (collider === void 0) { collider = null; }
        // 2D properties.
        if (sourceEvent) {
            event.ctrlKey = sourceEvent.ctrlKey;
            event.altKey = sourceEvent.altKey;
            event.shiftKey = sourceEvent.shiftKey;
            event.screenX = sourceEvent.clientX;
            event.screenY = sourceEvent.clientY;
        }
        if (collider == null)
            collider = this._iCollidingObject;
        // 3D properties.
        if (collider) {
            // Object.
            event.object = collider.displayObject;
            event.materialOwner = collider.materialOwner;
            // UV.
            event.uv = collider.uv;
            // Position.
            event.localPosition = collider.localPosition ? collider.localPosition.clone() : null;
            // Normal.
            event.localNormal = collider.localNormal ? collider.localNormal.clone() : null;
            // Face index.
            event.index = collider.index;
        }
        else {
            // Set all to null.
            event.uv = null;
            event.object = null;
            event.localPosition = this._nullVector;
            event.localNormal = this._nullVector;
            event.index = 0;
            event.subGeometryIndex = 0;
        }
        // Store event to be dispatched later.
        this._queuedEvents.push(event);
    };
    // ---------------------------------------------------------------------
    // Listeners.
    // ---------------------------------------------------------------------
    MouseManager.prototype.onMouseMove = function (event) {
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseMove, this._mouseMoveEvent = event);
    };
    MouseManager.prototype.onMouseOut = function (event) {
        this._iActiveDiv = null;
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseOut, event);
    };
    MouseManager.prototype.onMouseOver = function (event) {
        this._iActiveDiv = event.target;
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseOver, event);
    };
    MouseManager.prototype.onClick = function (event) {
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseClick, event);
    };
    MouseManager.prototype.onDoubleClick = function (event) {
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseDoubleClick, event);
    };
    MouseManager.prototype.onMouseDown = function (event) {
        this._iActiveDiv = event.target;
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseDown, event);
    };
    MouseManager.prototype.onMouseUp = function (event) {
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseUp, event);
    };
    MouseManager.prototype.onMouseWheel = function (event) {
        this.updateColliders(event);
        if (this._iCollidingObject)
            this.queueDispatch(this._mouseWheel, event);
    };
    MouseManager.prototype.updateColliders = function (event) {
        if (this._iUpdateDirty)
            return;
        var view;
        var bounds;
        var mouseX = event.clientX;
        var mouseY = event.clientY;
        var len = this._viewLookup.length;
        for (var i = 0; i < len; i++) {
            view = this._viewLookup[i];
            bounds = view.htmlElement.getBoundingClientRect();
            if (mouseX < bounds.left || mouseX > bounds.right || mouseY < bounds.top || mouseY > bounds.bottom) {
                view._pMouseX = null;
                view._pMouseY = null;
            }
            else {
                view._pMouseX = mouseX + bounds.left;
                view._pMouseY = mouseY + bounds.top;
                view.updateCollider();
                if (view.layeredView && this._iCollidingObject)
                    break;
            }
        }
        this._iUpdateDirty = true;
    };
    return MouseManager;
})();
module.exports = MouseManager;


},{"awayjs-core/lib/geom/Vector3D":120,"awayjs-display/lib/events/MouseEvent":72}],76:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
/**
 * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
 * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
 * extended to provide more application-specific dynamic selection of lights.
 *
 * @see StaticLightPicker
 */
var LightPickerBase = (function (_super) {
    __extends(LightPickerBase, _super);
    /**
     * Creates a new LightPickerBase object.
     */
    function LightPickerBase() {
        _super.call(this);
        this._pNumPointLights = 0;
        this._pNumDirectionalLights = 0;
        this._pNumCastingPointLights = 0;
        this._pNumCastingDirectionalLights = 0;
        this._pNumLightProbes = 0;
    }
    /**
     * Disposes resources used by the light picker.
     */
    LightPickerBase.prototype.dispose = function () {
    };
    Object.defineProperty(LightPickerBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AssetType.LIGHT_PICKER;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
        /**
         * The maximum amount of directional lights that will be provided.
         */
        get: function () {
            return this._pNumDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
        /**
         * The maximum amount of point lights that will be provided.
         */
        get: function () {
            return this._pNumPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
        /**
         * The maximum amount of directional lights that cast shadows.
         */
        get: function () {
            return this._pNumCastingDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
        /**
         * The amount of point lights that cast shadows.
         */
        get: function () {
            return this._pNumCastingPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
        /**
         * The maximum amount of light probes that will be provided.
         */
        get: function () {
            return this._pNumLightProbes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "pointLights", {
        /**
         * The collected point lights to be used for shading.
         */
        get: function () {
            return this._pPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
        /**
         * The collected directional lights to be used for shading.
         */
        get: function () {
            return this._pDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
        /**
         * The collected point lights that cast shadows to be used for shading.
         */
        get: function () {
            return this._pCastingPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
        /**
         * The collected directional lights that cast shadows to be used for shading.
         */
        get: function () {
            return this._pCastingDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
        /**
         * The collected light probes to be used for shading.
         */
        get: function () {
            return this._pLightProbes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
        /**
         * The weights for each light probe, defining their influence on the object.
         */
        get: function () {
            return this._pLightProbeWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
        /**
         * A collection of all the collected lights.
         */
        get: function () {
            return this._pAllPickedLights;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
     */
    LightPickerBase.prototype.collectLights = function (renderable) {
        this.updateProbeWeights(renderable);
    };
    /**
     * Updates the weights for the light probes, based on the renderable's position relative to them.
     * @param renderable The renderble for which to calculate the light probes' influence.
     */
    LightPickerBase.prototype.updateProbeWeights = function (renderable) {
        // todo: this will cause the same calculations to occur per TriangleSubMesh. See if this can be improved.
        var objectPos = renderable.sourceEntity.scenePosition;
        var lightPos;
        var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
        var dx, dy, dz;
        var w, total = 0;
        var i;
        for (i = 0; i < this._pNumLightProbes; ++i) {
            lightPos = this._pLightProbes[i].scenePosition;
            dx = rx - lightPos.x;
            dy = ry - lightPos.y;
            dz = rz - lightPos.z;
            // weight is inversely proportional to square of distance
            w = dx * dx + dy * dy + dz * dz;
            // just... huge if at the same spot
            w = w > .00001 ? 1 / w : 50000000;
            this._pLightProbeWeights[i] = w;
            total += w;
        }
        // normalize
        total = 1 / total;
        for (i = 0; i < this._pNumLightProbes; ++i)
            this._pLightProbeWeights[i] *= total;
    };
    return LightPickerBase;
})(NamedAssetBase);
module.exports = LightPickerBase;


},{"awayjs-core/lib/library/AssetType":121,"awayjs-core/lib/library/NamedAssetBase":122}],77:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var DirectionalLight = require("awayjs-display/lib/entities/DirectionalLight");
var LightProbe = require("awayjs-display/lib/entities/LightProbe");
var PointLight = require("awayjs-display/lib/entities/PointLight");
var LightEvent = require("awayjs-display/lib/events/LightEvent");
var LightPickerBase = require("awayjs-display/lib/materials/lightpickers/LightPickerBase");
/**
 * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
 * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
 * occur.
 */
var StaticLightPicker = (function (_super) {
    __extends(StaticLightPicker, _super);
    /**
     * Creates a new StaticLightPicker object.
     * @param lights The lights to be used for shading.
     */
    function StaticLightPicker(lights) {
        var _this = this;
        _super.call(this);
        this._onCastShadowChangeDelegate = function (event) { return _this.onCastShadowChange(event); };
        this.lights = lights;
    }
    Object.defineProperty(StaticLightPicker.prototype, "lights", {
        /**
         * The lights used for shading.
         */
        get: function () {
            return this._lights;
        },
        set: function (value) {
            var numPointLights = 0;
            var numDirectionalLights = 0;
            var numCastingPointLights = 0;
            var numCastingDirectionalLights = 0;
            var numLightProbes = 0;
            var light;
            if (this._lights)
                this.clearListeners();
            this._lights = value;
            this._pAllPickedLights = value;
            this._pPointLights = new Array();
            this._pCastingPointLights = new Array();
            this._pDirectionalLights = new Array();
            this._pCastingDirectionalLights = new Array();
            this._pLightProbes = new Array();
            var len = value.length;
            for (var i = 0; i < len; ++i) {
                light = value[i];
                light.addEventListener(LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
                if (light instanceof PointLight) {
                    if (light.castsShadows)
                        this._pCastingPointLights[numCastingPointLights++] = light;
                    else
                        this._pPointLights[numPointLights++] = light;
                }
                else if (light instanceof DirectionalLight) {
                    if (light.castsShadows)
                        this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
                    else
                        this._pDirectionalLights[numDirectionalLights++] = light;
                }
                else if (light instanceof LightProbe) {
                    this._pLightProbes[numLightProbes++] = light;
                }
            }
            if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights)
                return;
            this._pNumDirectionalLights = numDirectionalLights;
            this._pNumCastingDirectionalLights = numCastingDirectionalLights;
            this._pNumPointLights = numPointLights;
            this._pNumCastingPointLights = numCastingPointLights;
            this._pNumLightProbes = numLightProbes;
            // MUST HAVE MULTIPLE OF 4 ELEMENTS!
            this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);
            // notify material lights have changed
            this.dispatchEvent(new Event(Event.CHANGE));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Remove configuration change listeners on the lights.
     */
    StaticLightPicker.prototype.clearListeners = function () {
        var len = this._lights.length;
        for (var i = 0; i < len; ++i)
            this._lights[i].removeEventListener(LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
    };
    /**
     * Notifies the material of a configuration change.
     */
    StaticLightPicker.prototype.onCastShadowChange = function (event) {
        // TODO: Assign to special caster collections, just append it to the lights in SinglePass
        // But keep seperated in multipass
        var light = event.target;
        if (light instanceof PointLight)
            this.updatePointCasting(light);
        else if (light instanceof DirectionalLight)
            this.updateDirectionalCasting(light);
        this.dispatchEvent(new Event(Event.CHANGE));
    };
    /**
     * Called when a directional light's shadow casting configuration changes.
     */
    StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
        var dl = light;
        if (light.castsShadows) {
            --this._pNumDirectionalLights;
            ++this._pNumCastingDirectionalLights;
            this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
            this._pCastingDirectionalLights.push(light);
        }
        else {
            ++this._pNumDirectionalLights;
            --this._pNumCastingDirectionalLights;
            this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
            this._pDirectionalLights.push(light);
        }
    };
    /**
     * Called when a point light's shadow casting configuration changes.
     */
    StaticLightPicker.prototype.updatePointCasting = function (light) {
        var pl = light;
        if (light.castsShadows) {
            --this._pNumPointLights;
            ++this._pNumCastingPointLights;
            this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
            this._pCastingPointLights.push(light);
        }
        else {
            ++this._pNumPointLights;
            --this._pNumCastingPointLights;
            this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
            this._pPointLights.push(light);
        }
    };
    return StaticLightPicker;
})(LightPickerBase);
module.exports = StaticLightPicker;


},{"awayjs-core/lib/events/Event":107,"awayjs-display/lib/entities/DirectionalLight":66,"awayjs-display/lib/entities/LightProbe":67,"awayjs-display/lib/entities/PointLight":68,"awayjs-display/lib/events/LightEvent":71,"awayjs-display/lib/materials/lightpickers/LightPickerBase":76}],78:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var PartialImplementationError = require("awayjs-core/lib/errors/PartialImplementationError");
var Camera = require("awayjs-display/lib/entities/Camera");
var ShadowMapperBase = require("awayjs-display/lib/materials/shadowmappers/ShadowMapperBase");
var CubeMapShadowMapper = (function (_super) {
    __extends(CubeMapShadowMapper, _super);
    function CubeMapShadowMapper() {
        _super.call(this);
        this._pDepthMapSize = 512;
        this._needsRender = new Array();
        this.initCameras();
    }
    CubeMapShadowMapper.prototype.initCameras = function () {
        this._depthCameras = new Array();
        this._projections = new Array();
        // posX, negX, posY, negY, posZ, negZ
        this.addCamera(0, 90, 0);
        this.addCamera(0, -90, 0);
        this.addCamera(-90, 0, 0);
        this.addCamera(90, 0, 0);
        this.addCamera(0, 0, 0);
        this.addCamera(0, 180, 0);
    };
    CubeMapShadowMapper.prototype.addCamera = function (rotationX, rotationY, rotationZ) {
        var cam = new Camera();
        cam.rotationX = rotationX;
        cam.rotationY = rotationY;
        cam.rotationZ = rotationZ;
        cam.projection.near = .01;
        var projection = cam.projection;
        projection.fieldOfView = 90;
        this._projections.push(projection);
        cam.projection._iAspectRatio = 1;
        this._depthCameras.push(cam);
    };
    //@override
    CubeMapShadowMapper.prototype.pCreateDepthTexture = function () {
        throw new PartialImplementationError();
        /*
         return new RenderCubeTexture( this._depthMapSize );
         */
    };
    //@override
    CubeMapShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
        var light = (this._pLight);
        var maxDistance = light._pFallOff;
        var pos = this._pLight.scenePosition;
        for (var i = 0; i < 6; ++i) {
            this._projections[i].far = maxDistance;
            this._depthCameras[i].transform.position = pos;
            this._needsRender[i] = true;
        }
    };
    //@override
    CubeMapShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
        for (var i = 0; i < 6; ++i) {
            if (this._needsRender[i]) {
                this._pCasterCollector.camera = this._depthCameras[i];
                this._pCasterCollector.clear();
                scene.traversePartitions(this._pCasterCollector);
                renderer._iRender(this._pCasterCollector, target, null, i);
            }
        }
    };
    return CubeMapShadowMapper;
})(ShadowMapperBase);
module.exports = CubeMapShadowMapper;


},{"awayjs-core/lib/errors/PartialImplementationError":104,"awayjs-display/lib/entities/Camera":65,"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase":80}],79:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var FreeMatrixProjection = require("awayjs-core/lib/projections/FreeMatrixProjection");
var Camera = require("awayjs-display/lib/entities/Camera");
var ShadowMapperBase = require("awayjs-display/lib/materials/shadowmappers/ShadowMapperBase");
var DirectionalShadowMapper = (function (_super) {
    __extends(DirectionalShadowMapper, _super);
    function DirectionalShadowMapper() {
        _super.call(this);
        this._pLightOffset = 10000;
        this._pSnap = 64;
        this._pCullPlanes = [];
        this._pOverallDepthProjection = new FreeMatrixProjection();
        this._pOverallDepthCamera = new Camera(this._pOverallDepthProjection);
        this._pLocalFrustum = [];
        this._pMatrix = new Matrix3D();
    }
    Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
        get: function () {
            return this._pSnap;
        },
        set: function (value) {
            this._pSnap = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
        get: function () {
            return this._pLightOffset;
        },
        set: function (value) {
            this._pLightOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
        //@arcane
        get: function () {
            return this._pOverallDepthCamera.viewProjection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
        //@arcane
        get: function () {
            return this._pMaxZ - this._pMinZ;
        },
        enumerable: true,
        configurable: true
    });
    //@override
    DirectionalShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
        this._pCasterCollector.camera = this._pOverallDepthCamera;
        this._pCasterCollector.cullPlanes = this._pCullPlanes;
        this._pCasterCollector.clear();
        scene.traversePartitions(this._pCasterCollector);
        renderer._iRender(this._pCasterCollector, target);
    };
    //@protected
    DirectionalShadowMapper.prototype.pUpdateCullPlanes = function (viewCamera) {
        var lightFrustumPlanes = this._pOverallDepthCamera.frustumPlanes;
        var viewFrustumPlanes = viewCamera.frustumPlanes;
        this._pCullPlanes.length = 4;
        this._pCullPlanes[0] = lightFrustumPlanes[0];
        this._pCullPlanes[1] = lightFrustumPlanes[1];
        this._pCullPlanes[2] = lightFrustumPlanes[2];
        this._pCullPlanes[3] = lightFrustumPlanes[3];
        var light = this._pLight;
        var dir = light.sceneDirection;
        var dirX = dir.x;
        var dirY = dir.y;
        var dirZ = dir.z;
        var j = 4;
        for (var i = 0; i < 6; ++i) {
            var plane = viewFrustumPlanes[i];
            if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0)
                this._pCullPlanes[j++] = plane;
        }
    };
    //@override
    DirectionalShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
        this.pUpdateProjectionFromFrustumCorners(viewCamera, viewCamera.projection.frustumCorners, this._pMatrix);
        this._pOverallDepthProjection.matrix = this._pMatrix;
        this.pUpdateCullPlanes(viewCamera);
    };
    DirectionalShadowMapper.prototype.pUpdateProjectionFromFrustumCorners = function (viewCamera, corners, matrix) {
        var raw = new Array();
        var dir;
        var x, y, z;
        var minX, minY;
        var maxX, maxY;
        var i;
        var light = this._pLight;
        dir = light.sceneDirection;
        this._pOverallDepthCamera.transform.matrix3D = this._pLight.sceneTransform;
        x = Math.floor((viewCamera.x - dir.x * this._pLightOffset) / this._pSnap) * this._pSnap;
        y = Math.floor((viewCamera.y - dir.y * this._pLightOffset) / this._pSnap) * this._pSnap;
        z = Math.floor((viewCamera.z - dir.z * this._pLightOffset) / this._pSnap) * this._pSnap;
        this._pOverallDepthCamera.x = x;
        this._pOverallDepthCamera.y = y;
        this._pOverallDepthCamera.z = z;
        this._pMatrix.copyFrom(this._pOverallDepthCamera.inverseSceneTransform);
        this._pMatrix.prepend(viewCamera.sceneTransform);
        this._pMatrix.transformVectors(corners, this._pLocalFrustum);
        minX = maxX = this._pLocalFrustum[0];
        minY = maxY = this._pLocalFrustum[1];
        this._pMaxZ = this._pLocalFrustum[2];
        i = 3;
        while (i < 24) {
            x = this._pLocalFrustum[i];
            y = this._pLocalFrustum[i + 1];
            z = this._pLocalFrustum[i + 2];
            if (x < minX)
                minX = x;
            if (x > maxX)
                maxX = x;
            if (y < minY)
                minY = y;
            if (y > maxY)
                maxY = y;
            if (z > this._pMaxZ)
                this._pMaxZ = z;
            i += 3;
        }
        this._pMinZ = 1;
        var w = maxX - minX;
        var h = maxY - minY;
        var d = 1 / (this._pMaxZ - this._pMinZ);
        if (minX < 0)
            minX -= this._pSnap; // because int() rounds up for < 0
        if (minY < 0)
            minY -= this._pSnap;
        minX = Math.floor(minX / this._pSnap) * this._pSnap;
        minY = Math.floor(minY / this._pSnap) * this._pSnap;
        var snap2 = 2 * this._pSnap;
        w = Math.floor(w / snap2 + 2) * snap2;
        h = Math.floor(h / snap2 + 2) * snap2;
        maxX = minX + w;
        maxY = minY + h;
        w = 1 / w;
        h = 1 / h;
        raw[0] = 2 * w;
        raw[5] = 2 * h;
        raw[10] = d;
        raw[12] = -(maxX + minX) * w;
        raw[13] = -(maxY + minY) * h;
        raw[14] = -this._pMinZ * d;
        raw[15] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
        matrix.copyRawDataFrom(raw);
    };
    return DirectionalShadowMapper;
})(ShadowMapperBase);
module.exports = DirectionalShadowMapper;


},{"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/projections/FreeMatrixProjection":124,"awayjs-display/lib/entities/Camera":65,"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase":80}],80:[function(require,module,exports){
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var ShadowCasterCollector = require("awayjs-display/lib/traverse/ShadowCasterCollector");
var RenderTexture = require("awayjs-core/lib/textures/RenderTexture");
var ShadowMapperBase = (function () {
    function ShadowMapperBase() {
        this._pDepthMapSize = 2048;
        this._autoUpdateShadows = true;
        this._pCasterCollector = this.pCreateCasterCollector();
    }
    ShadowMapperBase.prototype.pCreateCasterCollector = function () {
        return new ShadowCasterCollector();
    };
    Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
        get: function () {
            return this._autoUpdateShadows;
        },
        set: function (value) {
            this._autoUpdateShadows = value;
        },
        enumerable: true,
        configurable: true
    });
    ShadowMapperBase.prototype.updateShadows = function () {
        this._iShadowsInvalid = true;
    };
    ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
        if (this._depthMap == depthMap)
            return;
        if (this._depthMap && !this._explicitDepthMap)
            this._depthMap.dispose();
        this._depthMap = depthMap;
        if (this._depthMap) {
            this._explicitDepthMap = true;
            this._pDepthMapSize = this._depthMap.size;
        }
        else {
            this._explicitDepthMap = false;
        }
    };
    Object.defineProperty(ShadowMapperBase.prototype, "light", {
        get: function () {
            return this._pLight;
        },
        set: function (value) {
            this._pLight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
        get: function () {
            if (!this._depthMap)
                this._depthMap = this.pCreateDepthTexture();
            return this._depthMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
        get: function () {
            return this._pDepthMapSize;
        },
        set: function (value) {
            if (value == this._pDepthMapSize)
                return;
            this._pSetDepthMapSize(value);
        },
        enumerable: true,
        configurable: true
    });
    ShadowMapperBase.prototype.dispose = function () {
        this._pCasterCollector = null;
        if (this._depthMap && !this._explicitDepthMap)
            this._depthMap.dispose();
        this._depthMap = null;
    };
    ShadowMapperBase.prototype.pCreateDepthTexture = function () {
        return new RenderTexture(this._pDepthMapSize, this._pDepthMapSize);
    };
    ShadowMapperBase.prototype.iRenderDepthMap = function (entityCollector, renderer) {
        this._iShadowsInvalid = false;
        this.pUpdateDepthProjection(entityCollector.camera);
        if (!this._depthMap)
            this._depthMap = this.pCreateDepthTexture();
        this.pDrawDepthMap(this._depthMap, entityCollector.scene, renderer);
    };
    ShadowMapperBase.prototype.pUpdateDepthProjection = function (viewCamera) {
        throw new AbstractMethodError();
    };
    ShadowMapperBase.prototype.pDrawDepthMap = function (target, scene, renderer) {
        throw new AbstractMethodError();
    };
    ShadowMapperBase.prototype._pSetDepthMapSize = function (value) {
        this._pDepthMapSize = value;
        if (this._explicitDepthMap) {
            throw Error("Cannot set depth map size for the current renderer.");
        }
        else if (this._depthMap) {
            this._depthMap.dispose();
            this._depthMap = null;
        }
    };
    return ShadowMapperBase;
})();
module.exports = ShadowMapperBase;


},{"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/textures/RenderTexture":128,"awayjs-display/lib/traverse/ShadowCasterCollector":95}],81:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EntityNode = require("awayjs-display/lib/partition/EntityNode");
/**
 * @class away.partition.CameraNode
 */
var CameraNode = (function (_super) {
    __extends(CameraNode, _super);
    function CameraNode(camera) {
        _super.call(this, camera);
    }
    /**
     * @inheritDoc
     */
    CameraNode.prototype.acceptTraverser = function (traverser) {
        // todo: dead end for now, if it has a debug mesh, then sure accept that
    };
    return CameraNode;
})(EntityNode);
module.exports = CameraNode;


},{"awayjs-display/lib/partition/EntityNode":83}],82:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EntityNode = require("awayjs-display/lib/partition/EntityNode");
/**
 * @class away.partition.DirectionalLightNode
 */
var DirectionalLightNode = (function (_super) {
    __extends(DirectionalLightNode, _super);
    /**
     *
     * @param directionalLight
     */
    function DirectionalLightNode(directionalLight) {
        _super.call(this, directionalLight);
        this._directionalLight = directionalLight;
    }
    /**
     * @inheritDoc
     */
    DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
        if (traverser.enterNode(this))
            traverser.applyDirectionalLight(this._directionalLight);
    };
    /**
     *
     * @returns {boolean}
     */
    DirectionalLightNode.prototype.isCastingShadow = function () {
        return false;
    };
    return DirectionalLightNode;
})(EntityNode);
module.exports = DirectionalLightNode;


},{"awayjs-display/lib/partition/EntityNode":83}],83:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var PartialImplementationError = require("awayjs-core/lib/errors/PartialImplementationError");
var NodeBase = require("awayjs-display/lib/partition/NodeBase");
/**
 * @class away.partition.EntityNode
 */
var EntityNode = (function (_super) {
    __extends(EntityNode, _super);
    function EntityNode(entity) {
        _super.call(this);
        this._entity = entity;
        this._iNumEntities = 1;
    }
    Object.defineProperty(EntityNode.prototype, "entity", {
        get: function () {
            return this._entity;
        },
        enumerable: true,
        configurable: true
    });
    EntityNode.prototype.removeFromParent = function () {
        if (this._iParent)
            this._iParent.iRemoveNode(this);
        this._iParent = null;
    };
    /**
     *
     * @returns {boolean}
     */
    EntityNode.prototype.isCastingShadow = function () {
        return this.entity.castsShadows;
    };
    /**
     *
     * @param planes
     * @param numPlanes
     * @returns {boolean}
     */
    EntityNode.prototype.isInFrustum = function (planes, numPlanes) {
        if (!this._entity._iIsVisible())
            return false;
        return this._entity.worldBounds.isInFrustum(planes, numPlanes);
    };
    /**
     * @inheritDoc
     */
    EntityNode.prototype.acceptTraverser = function (traverser) {
        if (traverser.enterNode(this))
            traverser.applyEntity(this._entity);
    };
    /**
     * @inheritDoc
     */
    EntityNode.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
        if (!this._entity._iIsVisible())
            return false;
        return this._entity.isIntersectingRay(rayPosition, rayDirection);
    };
    /**
     *
     * @protected
     */
    EntityNode.prototype._pCreateBoundsPrimitive = function () {
        throw new PartialImplementationError();
        //return this._entity.bounds.boundingEntity;
    };
    return EntityNode;
})(NodeBase);
module.exports = EntityNode;


},{"awayjs-core/lib/errors/PartialImplementationError":104,"awayjs-display/lib/partition/NodeBase":85}],84:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EntityNode = require("awayjs-display/lib/partition/EntityNode");
/**
 * @class away.partition.LightProbeNode
 */
var LightProbeNode = (function (_super) {
    __extends(LightProbeNode, _super);
    /**
     *
     * @param lightProbe
     */
    function LightProbeNode(lightProbe) {
        _super.call(this, lightProbe);
        this._lightProbe = lightProbe;
    }
    /**
     * @inheritDoc
     */
    LightProbeNode.prototype.acceptTraverser = function (traverser) {
        if (traverser.enterNode(this))
            traverser.applyLightProbe(this._lightProbe);
    };
    /**
     *
     * @returns {boolean}
     */
    LightProbeNode.prototype.isCastingShadow = function () {
        return false;
    };
    return LightProbeNode;
})(EntityNode);
module.exports = LightProbeNode;


},{"awayjs-display/lib/partition/EntityNode":83}],85:[function(require,module,exports){
/**
 * @class away.partition.NodeBase
 */
var NodeBase = (function () {
    /**
     *
     */
    function NodeBase() {
        this._pNumChildNodes = 0;
        this._iNumEntities = 0;
        this._pChildNodes = new Array();
    }
    Object.defineProperty(NodeBase.prototype, "boundsVisible", {
        /**
         *
         */
        get: function () {
            return this._explicitBoundsVisible;
        },
        set: function (value) {
            if (this._explicitBoundsVisible == value)
                return;
            this._explicitBoundsVisible = value;
            this._iUpdateImplicitBoundsVisible(this._iParent ? this._iParent.boundsChildrenVisible : false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "boundsChildrenVisible", {
        get: function () {
            return this._boundsChildrenVisible;
        },
        set: function (value) {
            if (this._boundsChildrenVisible == value)
                return;
            this._boundsChildrenVisible = value;
            for (var i = 0; i < this._pNumChildNodes; ++i)
                this._pChildNodes[i]._iUpdateImplicitBoundsVisible(this._boundsChildrenVisible);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "parent", {
        /**
         *
         */
        get: function () {
            return this._iParent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "_pNumEntities", {
        /**
         *
         * @protected
         */
        get: function () {
            return this._iNumEntities;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param planes
     * @param numPlanes
     * @returns {boolean}
     * @internal
     */
    NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
        return true;
    };
    /**
     *
     * @param rayPosition
     * @param rayDirection
     * @returns {boolean}
     */
    NodeBase.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
        return true;
    };
    /**
     *
     * @returns {boolean}
     */
    NodeBase.prototype.isCastingShadow = function () {
        return true;
    };
    /**
     *
     * @param entity
     * @returns {away.partition.NodeBase}
     */
    NodeBase.prototype.findPartitionForEntity = function (entity) {
        return this;
    };
    /**
     *
     * @param traverser
     */
    NodeBase.prototype.acceptTraverser = function (traverser) {
        if (this._pNumEntities == 0 && !this._implicitBoundsVisible)
            return;
        if (traverser.enterNode(this)) {
            var i = 0;
            while (i < this._pNumChildNodes)
                this._pChildNodes[i++].acceptTraverser(traverser);
            if (this._implicitBoundsVisible)
                this._pBoundsPrimitive.partitionNode.acceptTraverser(traverser);
        }
    };
    /**
     *
     * @protected
     */
    NodeBase.prototype._pCreateBoundsPrimitive = function () {
        return null;
    };
    /**
     *
     * @param node
     * @internal
     */
    NodeBase.prototype.iAddNode = function (node) {
        node._iParent = this;
        this._iNumEntities += node._pNumEntities;
        this._pChildNodes[this._pNumChildNodes++] = node;
        node._iUpdateImplicitBoundsVisible(this.boundsChildrenVisible);
        var numEntities = node._pNumEntities;
        node = this;
        do {
            node._iNumEntities += numEntities;
        } while ((node = node._iParent) != null);
    };
    /**
     *
     * @param node
     * @internal
     */
    NodeBase.prototype.iRemoveNode = function (node) {
        var index = this._pChildNodes.indexOf(node);
        this._pChildNodes[index] = this._pChildNodes[--this._pNumChildNodes];
        this._pChildNodes.pop();
        node._iUpdateImplicitBoundsVisible(false);
        var numEntities = node._pNumEntities;
        node = this;
        do {
            node._pNumEntities -= numEntities;
        } while ((node = node._iParent) != null);
    };
    NodeBase.prototype._iUpdateImplicitBoundsVisible = function (value) {
        if (this._implicitBoundsVisible == this._explicitBoundsVisible || value)
            return;
        this._implicitBoundsVisible = this._explicitBoundsVisible || value;
        this._iUpdateEntityBounds();
        for (var i = 0; i < this._pNumChildNodes; ++i)
            this._pChildNodes[i]._iUpdateImplicitBoundsVisible(this._boundsChildrenVisible);
    };
    /**
     * @internal
     */
    NodeBase.prototype._iIsBoundsVisible = function () {
        return this._implicitBoundsVisible;
    };
    //		public _pUpdateNumEntities(value:number)
    //		{
    //			var diff:number = value - this._pNumEntities;
    //			var node:NodeBase = this;
    //
    //			do {
    //				node._pNumEntities += diff;
    //			} while ((node = node._iParent) != null);
    //		}
    NodeBase.prototype._iUpdateEntityBounds = function () {
        if (this._pBoundsPrimitive) {
            this._pBoundsPrimitive.dispose();
            this._pBoundsPrimitive = null;
        }
        if (this._implicitBoundsVisible)
            this._pBoundsPrimitive = this._pCreateBoundsPrimitive();
    };
    return NodeBase;
})();
module.exports = NodeBase;


},{}],86:[function(require,module,exports){
/**
 * @class away.partition.NullNode
 */
var NullNode = (function () {
    function NullNode() {
    }
    return NullNode;
})();
module.exports = NullNode;


},{}],87:[function(require,module,exports){
var NullNode = require("awayjs-display/lib/partition/NullNode");
/**
 * @class away.partition.Partition
 */
var Partition = (function () {
    function Partition(rootNode) {
        this._updatesMade = false;
        this._rootNode = rootNode || new NullNode();
    }
    Object.defineProperty(Partition.prototype, "rootNode", {
        get: function () {
            return this._rootNode;
        },
        enumerable: true,
        configurable: true
    });
    Partition.prototype.traverse = function (traverser) {
        if (this._updatesMade)
            this.updateEntities();
        this._rootNode.acceptTraverser(traverser);
    };
    Partition.prototype.iMarkForUpdate = function (entity) {
        var node = entity.partitionNode;
        var t = this._updateQueue;
        while (t) {
            if (node == t)
                return;
            t = t._iUpdateQueueNext;
        }
        node._iUpdateQueueNext = this._updateQueue;
        this._updateQueue = node;
        this._updatesMade = true;
    };
    Partition.prototype.iRemoveEntity = function (entity) {
        var node = entity.partitionNode;
        var t;
        node.removeFromParent();
        if (node == this._updateQueue) {
            this._updateQueue = node._iUpdateQueueNext;
        }
        else {
            t = this._updateQueue;
            while (t && t._iUpdateQueueNext != node)
                t = t._iUpdateQueueNext;
            if (t)
                t._iUpdateQueueNext = node._iUpdateQueueNext;
        }
        node._iUpdateQueueNext = null;
        if (!this._updateQueue)
            this._updatesMade = false;
    };
    Partition.prototype.updateEntities = function () {
        var node = this._updateQueue;
        var targetNode;
        var t;
        this._updateQueue = null;
        this._updatesMade = false;
        do {
            targetNode = this._rootNode.findPartitionForEntity(node.entity);
            if (node.parent != targetNode) {
                if (node)
                    node.removeFromParent();
                targetNode.iAddNode(node);
            }
            t = node._iUpdateQueueNext;
            node._iUpdateQueueNext = null;
            //required for controllers with autoUpdate set to true
            node.entity._iInternalUpdate();
        } while ((node = t) != null);
    };
    return Partition;
})();
module.exports = Partition;


},{"awayjs-display/lib/partition/NullNode":86}],88:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EntityNode = require("awayjs-display/lib/partition/EntityNode");
/**
 * @class away.partition.PointLightNode
 */
var PointLightNode = (function (_super) {
    __extends(PointLightNode, _super);
    /**
     *
     * @param pointLight
     */
    function PointLightNode(pointLight) {
        _super.call(this, pointLight);
        this._pointLight = pointLight;
    }
    /**
     * @inheritDoc
     */
    PointLightNode.prototype.acceptTraverser = function (traverser) {
        if (traverser.enterNode(this))
            traverser.applyPointLight(this._pointLight);
    };
    /**
     *
     * @returns {boolean}
     */
    PointLightNode.prototype.isCastingShadow = function () {
        return false;
    };
    return PointLightNode;
})(EntityNode);
module.exports = PointLightNode;


},{"awayjs-display/lib/partition/EntityNode":83}],89:[function(require,module,exports){
/**
 * Value object for a picking collision returned by a picking collider. Created as unique objects on display objects
 *
 * @see away.base.DisplayObject#pickingCollisionVO
 * @see away.core.pick.IPickingCollider
 *
 * @class away.pick.PickingCollisionVO
 */
var PickingCollisionVO = (function () {
    /**
     * Creates a new <code>PickingCollisionVO</code> object.
     *
     * @param entity The entity to which this collision object belongs.
     */
    function PickingCollisionVO(displayObject) {
        this.displayObject = displayObject;
    }
    return PickingCollisionVO;
})();
module.exports = PickingCollisionVO;


},{}],90:[function(require,module,exports){
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var RaycastCollector = require("awayjs-display/lib/traverse/RaycastCollector");
/**
 * Picks a 3d object from a view or scene by 3D raycast calculations.
 * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
 * then triggers an optional picking collider on individual entity objects to further determine the precise values of the picking ray collision.
 *
 * @class away.pick.RaycastPicker
 */
var RaycastPicker = (function () {
    /**
     * Creates a new <code>RaycastPicker</code> object.
     *
     * @param findClosestCollision Determines whether the picker searches for the closest bounds collision along the ray,
     * or simply returns the first collision encountered. Defaults to false.
     */
    function RaycastPicker(findClosestCollision) {
        if (findClosestCollision === void 0) { findClosestCollision = false; }
        this._ignoredEntities = [];
        this._onlyMouseEnabled = true;
        this._numEntities = 0;
        this._raycastCollector = new RaycastCollector();
        this._findClosestCollision = findClosestCollision;
        this._entities = new Array();
    }
    Object.defineProperty(RaycastPicker.prototype, "onlyMouseEnabled", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._onlyMouseEnabled;
        },
        set: function (value) {
            this._onlyMouseEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    RaycastPicker.prototype.getViewCollision = function (x, y, view) {
        //update ray
        var rayPosition = view.unproject(x, y, 0);
        var rayDirection = view.unproject(x, y, 1).subtract(rayPosition);
        return this.getSceneCollision(rayPosition, rayDirection, view.scene);
    };
    /**
     * @inheritDoc
     */
    RaycastPicker.prototype.getSceneCollision = function (rayPosition, rayDirection, scene) {
        //clear collector
        this._raycastCollector.clear();
        //setup ray vectors
        this._raycastCollector.rayPosition = rayPosition;
        this._raycastCollector.rayDirection = rayDirection;
        // collect entities to test
        scene.traversePartitions(this._raycastCollector);
        this._numEntities = 0;
        var node = this._raycastCollector.entityHead;
        var entity;
        while (node) {
            if (!this.isIgnored(entity = node.entity))
                this._entities[this._numEntities++] = entity;
            node = node.next;
        }
        //early out if no collisions detected
        if (!this._numEntities)
            return null;
        return this.getPickingCollisionVO(this._raycastCollector);
    };
    //		public getEntityCollision(position:Vector3D, direction:Vector3D, entities:Array<IEntity>):PickingCollisionVO
    //		{
    //			this._numEntities = 0;
    //
    //			var entity:IEntity;
    //			var l:number = entities.length;
    //
    //			for (var c:number = 0; c < l; c++) {
    //				entity = entities[c];
    //
    //				if (entity.isIntersectingRay(position, direction))
    //					this._entities[this._numEntities++] = entity;
    //			}
    //
    //			return this.getPickingCollisionVO(this._raycastCollector);
    //		}
    RaycastPicker.prototype.setIgnoreList = function (entities) {
        this._ignoredEntities = entities;
    };
    RaycastPicker.prototype.isIgnored = function (entity) {
        if (this._onlyMouseEnabled && !entity._iIsMouseEnabled())
            return true;
        var len = this._ignoredEntities.length;
        for (var i = 0; i < len; i++)
            if (this._ignoredEntities[i] == entity)
                return true;
        return false;
    };
    RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
        return entity1._iPickingCollisionVO.rayEntryDistance > entity2._iPickingCollisionVO.rayEntryDistance ? 1 : -1;
    };
    RaycastPicker.prototype.getPickingCollisionVO = function (collector) {
        // trim before sorting
        this._entities.length = this._numEntities;
        // Sort entities from closest to furthest.
        this._entities = this._entities.sort(this.sortOnNearT); // TODO - test sort filter in JS
        // ---------------------------------------------------------------------
        // Evaluate triangle collisions when needed.
        // Replaces collision data provided by bounds collider with more precise data.
        // ---------------------------------------------------------------------
        var shortestCollisionDistance = Number.MAX_VALUE;
        var bestCollisionVO;
        var pickingCollisionVO;
        var entity;
        var i;
        for (i = 0; i < this._numEntities; ++i) {
            entity = this._entities[i];
            pickingCollisionVO = entity._iPickingCollisionVO;
            if (entity.pickingCollider) {
                // If a collision exists, update the collision data and stop all checks.
                if ((bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) && entity._iTestCollision(shortestCollisionDistance, this._findClosestCollision)) {
                    shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;
                    bestCollisionVO = pickingCollisionVO;
                    if (!this._findClosestCollision) {
                        this.updateLocalPosition(pickingCollisionVO);
                        return pickingCollisionVO;
                    }
                }
            }
            else if (bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) {
                // Note: a bounds collision with a ray origin inside its bounds is ONLY ever used
                // to enable the detection of a corresponsding triangle collision.
                // Therefore, bounds collisions with a ray origin inside its bounds can be ignored
                // if it has been established that there is NO triangle collider to test
                if (!pickingCollisionVO.rayOriginIsInsideBounds) {
                    this.updateLocalPosition(pickingCollisionVO);
                    return pickingCollisionVO;
                }
            }
        }
        return bestCollisionVO;
    };
    RaycastPicker.prototype.updateLocalPosition = function (pickingCollisionVO) {
        var collisionPos = (pickingCollisionVO.localPosition == null) ? new Vector3D() : pickingCollisionVO.localPosition;
        var rayDir = pickingCollisionVO.localRayDirection;
        var rayPos = pickingCollisionVO.localRayPosition;
        var t = pickingCollisionVO.rayEntryDistance;
        collisionPos.x = rayPos.x + t * rayDir.x;
        collisionPos.y = rayPos.y + t * rayDir.y;
        collisionPos.z = rayPos.z + t * rayDir.z;
    };
    RaycastPicker.prototype.dispose = function () {
        //TODO
    };
    return RaycastPicker;
})();
module.exports = RaycastPicker;


},{"awayjs-core/lib/geom/Vector3D":120,"awayjs-display/lib/traverse/RaycastCollector":94}],91:[function(require,module,exports){
/**
 * @class away.pool.EntityListItem
 */
var EntityListItem = (function () {
    function EntityListItem() {
    }
    return EntityListItem;
})();
module.exports = EntityListItem;


},{}],92:[function(require,module,exports){
var EntityListItem = require("awayjs-display/lib/pool/EntityListItem");
/**
 * @class away.pool.EntityListItemPool
 */
var EntityListItemPool = (function () {
    /**
     *
     */
    function EntityListItemPool() {
        this._index = 0;
        this._poolSize = 0;
        this._pool = new Array();
    }
    /**
     *
     */
    EntityListItemPool.prototype.getItem = function () {
        var item;
        if (this._index == this._poolSize) {
            item = new EntityListItem();
            this._pool[this._index++] = item;
            ++this._poolSize;
        }
        else {
            item = this._pool[this._index++];
        }
        return item;
    };
    /**
     *
     */
    EntityListItemPool.prototype.freeAll = function () {
        this._index = 0;
    };
    EntityListItemPool.prototype.dispose = function () {
        this._pool.length = 0;
    };
    return EntityListItemPool;
})();
module.exports = EntityListItemPool;


},{"awayjs-display/lib/pool/EntityListItem":91}],93:[function(require,module,exports){
var EntityListItemPool = require("awayjs-display/lib/pool/EntityListItemPool");
/**
 * @class away.traverse.CollectorBase
 */
var CollectorBase = (function () {
    function CollectorBase() {
        this._numCullPlanes = 0;
        this._pNumEntities = 0;
        this._pNumInteractiveEntities = 0;
        this._pEntityListItemPool = new EntityListItemPool();
    }
    Object.defineProperty(CollectorBase.prototype, "camera", {
        /**
         *
         */
        get: function () {
            return this._pCamera;
        },
        set: function (value) {
            this._pCamera = value;
            this._cullPlanes = this._pCamera.frustumPlanes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CollectorBase.prototype, "cullPlanes", {
        /**
         *
         */
        get: function () {
            return this._customCullPlanes;
        },
        set: function (value) {
            this._customCullPlanes = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CollectorBase.prototype, "entityHead", {
        /**
         *
         */
        get: function () {
            return this._pEntityHead;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CollectorBase.prototype, "numEntities", {
        /**
         *
         */
        get: function () {
            return this._pNumEntities;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CollectorBase.prototype, "numInteractiveEntities", {
        /**
         *
         */
        get: function () {
            return this._pNumInteractiveEntities;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    CollectorBase.prototype.clear = function () {
        this._pNumEntities = this._pNumInteractiveEntities = 0;
        this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : (this._pCamera ? this._pCamera.frustumPlanes : null);
        this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
        this._pEntityHead = null;
        this._pEntityListItemPool.freeAll();
    };
    /**
     *
     * @param node
     * @returns {boolean}
     */
    CollectorBase.prototype.enterNode = function (node) {
        var enter = this.scene._iCollectionMark != node._iCollectionMark && node.isInFrustum(this._cullPlanes, this._numCullPlanes);
        node._iCollectionMark = this.scene._iCollectionMark;
        return enter;
    };
    /**
     *
     * @param entity
     */
    CollectorBase.prototype.applyDirectionalLight = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    CollectorBase.prototype.applyEntity = function (entity) {
        this._pNumEntities++;
        if (entity._iIsMouseEnabled())
            this._pNumInteractiveEntities++;
        var item = this._pEntityListItemPool.getItem();
        item.entity = entity;
        item.next = this._pEntityHead;
        this._pEntityHead = item;
    };
    /**
     *
     * @param entity
     */
    CollectorBase.prototype.applyLightProbe = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    CollectorBase.prototype.applyPointLight = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    CollectorBase.prototype.applySkybox = function (entity) {
        //don't do anything here
    };
    return CollectorBase;
})();
module.exports = CollectorBase;


},{"awayjs-display/lib/pool/EntityListItemPool":92}],94:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var CollectorBase = require("awayjs-display/lib/traverse/CollectorBase");
/**
 * The RaycastCollector class is a traverser for scene partitions that collects all scene graph entities that are
 * considered intersecting with the defined ray.
 *
 * @see away.partition.Partition
 * @see away.entities.IEntity
 *
 * @class away.traverse.RaycastCollector
 */
var RaycastCollector = (function (_super) {
    __extends(RaycastCollector, _super);
    /**
     * Creates a new RaycastCollector object.
     */
    function RaycastCollector() {
        _super.call(this);
        this._rayPosition = new Vector3D();
        this._rayDirection = new Vector3D();
        this._iCollectionMark = 0;
    }
    Object.defineProperty(RaycastCollector.prototype, "rayPosition", {
        /**
         * Provides the starting position of the ray.
         */
        get: function () {
            return this._rayPosition;
        },
        set: function (value) {
            this._rayPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RaycastCollector.prototype, "rayDirection", {
        /**
         * Provides the direction vector of the ray.
         */
        get: function () {
            return this._rayDirection;
        },
        set: function (value) {
            this._rayDirection = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
     *
     * @param node The Partition3DNode object to frustum-test.
     */
    RaycastCollector.prototype.enterNode = function (node) {
        return node.isIntersectingRay(this._rayPosition, this._rayDirection);
    };
    return RaycastCollector;
})(CollectorBase);
module.exports = RaycastCollector;


},{"awayjs-core/lib/geom/Vector3D":120,"awayjs-display/lib/traverse/CollectorBase":93}],95:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var CollectorBase = require("awayjs-display/lib/traverse/CollectorBase");
/**
 * @class away.traverse.ShadowCasterCollector
 */
var ShadowCasterCollector = (function (_super) {
    __extends(ShadowCasterCollector, _super);
    function ShadowCasterCollector() {
        _super.call(this);
    }
    /**
     *
     */
    ShadowCasterCollector.prototype.enterNode = function (node) {
        var enter = this.scene._iCollectionMark != node._iCollectionMark && node.isCastingShadow();
        if (!enter) {
            node._iCollectionMark = this.scene._iCollectionMark;
            return false;
        }
        return _super.prototype.enterNode.call(this, node);
    };
    return ShadowCasterCollector;
})(CollectorBase);
module.exports = ShadowCasterCollector;


},{"awayjs-display/lib/traverse/CollectorBase":93}],96:[function(require,module,exports){
module.exports=require(2)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/base/BitmapData.js":2,"awayjs-core/lib/geom/Rectangle":119,"awayjs-core/lib/utils/ColorUtils":131}],97:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BoundingVolumeBase = require("awayjs-core/lib/bounds/BoundingVolumeBase");
var Matrix3DUtils = require("awayjs-core/lib/geom/Matrix3DUtils");
var PlaneClassification = require("awayjs-core/lib/geom/PlaneClassification");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
/**
 * AxisAlignedBoundingBox represents a bounding box volume that has its planes aligned to the local coordinate axes of the bounded object.
 * This is useful for most meshes.
 */
var AxisAlignedBoundingBox = (function (_super) {
    __extends(AxisAlignedBoundingBox, _super);
    /**
     * Creates a new <code>AxisAlignedBoundingBox</code> object.
     */
    function AxisAlignedBoundingBox() {
        _super.call(this);
        this._centerX = 0;
        this._centerY = 0;
        this._centerZ = 0;
        this._halfExtentsX = 0;
        this._halfExtentsY = 0;
        this._halfExtentsZ = 0;
    }
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.nullify = function () {
        _super.prototype.nullify.call(this);
        this._centerX = this._centerY = this._centerZ = 0;
        this._halfExtentsX = this._halfExtentsY = this._halfExtentsZ = 0;
    };
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.isInFrustum = function (planes, numPlanes) {
        for (var i = 0; i < numPlanes; ++i) {
            var plane = planes[i];
            var a = plane.a;
            var b = plane.b;
            var c = plane.c;
            var flippedExtentX = a < 0 ? -this._halfExtentsX : this._halfExtentsX;
            var flippedExtentY = b < 0 ? -this._halfExtentsY : this._halfExtentsY;
            var flippedExtentZ = c < 0 ? -this._halfExtentsZ : this._halfExtentsZ;
            var projDist = a * (this._centerX + flippedExtentX) + b * (this._centerY + flippedExtentY) + c * (this._centerZ + flippedExtentZ) - plane.d;
            if (projDist < 0)
                return false;
        }
        return true;
    };
    AxisAlignedBoundingBox.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this.containsPoint(position))
            return 0;
        var px = position.x - this._centerX;
        var py = position.y - this._centerY;
        var pz = position.z - this._centerZ;
        var vx = direction.x;
        var vy = direction.y;
        var vz = direction.z;
        var ix;
        var iy;
        var iz;
        var rayEntryDistance;
        // ray-plane tests
        var intersects;
        if (vx < 0) {
            rayEntryDistance = (this._halfExtentsX - px) / vx;
            if (rayEntryDistance > 0) {
                iy = py + rayEntryDistance * vy;
                iz = pz + rayEntryDistance * vz;
                if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                    targetNormal.x = 1;
                    targetNormal.y = 0;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vx > 0) {
            rayEntryDistance = (-this._halfExtentsX - px) / vx;
            if (rayEntryDistance > 0) {
                iy = py + rayEntryDistance * vy;
                iz = pz + rayEntryDistance * vz;
                if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                    targetNormal.x = -1;
                    targetNormal.y = 0;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vy < 0) {
            rayEntryDistance = (this._halfExtentsY - py) / vy;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iz = pz + rayEntryDistance * vz;
                if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                    targetNormal.x = 0;
                    targetNormal.y = 1;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vy > 0) {
            rayEntryDistance = (-this._halfExtentsY - py) / vy;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iz = pz + rayEntryDistance * vz;
                if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                    targetNormal.x = 0;
                    targetNormal.y = -1;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vz < 0) {
            rayEntryDistance = (this._halfExtentsZ - pz) / vz;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iy = py + rayEntryDistance * vy;
                if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                    targetNormal.x = 0;
                    targetNormal.y = 0;
                    targetNormal.z = 1;
                    intersects = true;
                }
            }
        }
        if (!intersects && vz > 0) {
            rayEntryDistance = (-this._halfExtentsZ - pz) / vz;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iy = py + rayEntryDistance * vy;
                if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                    targetNormal.x = 0;
                    targetNormal.y = 0;
                    targetNormal.z = -1;
                    intersects = true;
                }
            }
        }
        return intersects ? rayEntryDistance : -1;
    };
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.containsPoint = function (position) {
        var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
        return px <= this._halfExtentsX && px >= -this._halfExtentsX && py <= this._halfExtentsY && py >= -this._halfExtentsY && pz <= this._halfExtentsZ && pz >= -this._halfExtentsZ;
    };
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
        this._centerX = (maxX + minX) * .5;
        this._centerY = (maxY + minY) * .5;
        this._centerZ = (maxZ + minZ) * .5;
        this._halfExtentsX = (maxX - minX) * .5;
        this._halfExtentsY = (maxY - minY) * .5;
        this._halfExtentsZ = (maxZ - minZ) * .5;
        _super.prototype.fromExtremes.call(this, minX, minY, minZ, maxX, maxY, maxZ);
    };
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.clone = function () {
        var clone = new AxisAlignedBoundingBox();
        clone.fromExtremes(this._aabb.x, this._aabb.y + this._aabb.height, this._aabb.z, this._aabb.x + this._aabb.width, this._aabb.y, this._aabb.z + this._aabb.depth);
        return clone;
    };
    Object.defineProperty(AxisAlignedBoundingBox.prototype, "halfExtentsX", {
        get: function () {
            return this._halfExtentsX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisAlignedBoundingBox.prototype, "halfExtentsY", {
        get: function () {
            return this._halfExtentsY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisAlignedBoundingBox.prototype, "halfExtentsZ", {
        get: function () {
            return this._halfExtentsZ;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Finds the closest point on the bounding volume to another given point. This can be used for maximum error calculations for content within a given bound.
     * @param point The point for which to find the closest point on the bounding volume
     * @param target An optional Vector3D to store the result to prevent creating a new object.
     * @return
     */
    AxisAlignedBoundingBox.prototype.closestPointToPoint = function (point, target) {
        if (target === void 0) { target = null; }
        var p;
        if (target == null)
            target = new Vector3D();
        p = point.x;
        if (p < this._aabb.x)
            p = this._aabb.x;
        if (p > this._aabb.x + this._aabb.width)
            p = this._aabb.x + this._aabb.width;
        target.x = p;
        p = point.y;
        if (p < this._aabb.y + this._aabb.height)
            p = this._aabb.y + this._aabb.height;
        if (p > this._aabb.y)
            p = this._aabb.y;
        target.y = p;
        p = point.z;
        if (p < this._aabb.z)
            p = this._aabb.z;
        if (p > this._aabb.z + this._aabb.depth)
            p = this._aabb.z + this._aabb.depth;
        target.z = p;
        return target;
    };
    AxisAlignedBoundingBox.prototype.classifyToPlane = function (plane) {
        var a = plane.a;
        var b = plane.b;
        var c = plane.c;
        var centerDistance = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
        if (a < 0)
            a = -a;
        if (b < 0)
            b = -b;
        if (c < 0)
            c = -c;
        var boundOffset = a * this._halfExtentsX + b * this._halfExtentsY + c * this._halfExtentsZ;
        return centerDistance > boundOffset ? PlaneClassification.FRONT : centerDistance < -boundOffset ? PlaneClassification.BACK : PlaneClassification.INTERSECT;
    };
    AxisAlignedBoundingBox.prototype.transformFrom = function (bounds, matrix) {
        var aabb = bounds;
        var cx = aabb._centerX;
        var cy = aabb._centerY;
        var cz = aabb._centerZ;
        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        matrix.copyRawDataTo(raw);
        var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
        var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
        var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
        this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
        this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
        this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
        if (m11 < 0)
            m11 = -m11;
        if (m12 < 0)
            m12 = -m12;
        if (m13 < 0)
            m13 = -m13;
        if (m21 < 0)
            m21 = -m21;
        if (m22 < 0)
            m22 = -m22;
        if (m23 < 0)
            m23 = -m23;
        if (m31 < 0)
            m31 = -m31;
        if (m32 < 0)
            m32 = -m32;
        if (m33 < 0)
            m33 = -m33;
        var hx = aabb._halfExtentsX;
        var hy = aabb._halfExtentsY;
        var hz = aabb._halfExtentsZ;
        this._halfExtentsX = hx * m11 + hy * m12 + hz * m13;
        this._halfExtentsY = hx * m21 + hy * m22 + hz * m23;
        this._halfExtentsZ = hx * m31 + hy * m32 + hz * m33;
        this._aabb.width = this._aabb.height = this._aabb.depth = this._halfExtentsX * 2;
        this._aabb.x = this._centerX - this._halfExtentsX;
        this._aabb.y = this._centerY + this._halfExtentsY;
        this._aabb.z = this._centerZ - this._halfExtentsZ;
    };
    return AxisAlignedBoundingBox;
})(BoundingVolumeBase);
module.exports = AxisAlignedBoundingBox;


},{"awayjs-core/lib/bounds/BoundingVolumeBase":99,"awayjs-core/lib/geom/Matrix3DUtils":114,"awayjs-core/lib/geom/PlaneClassification":117,"awayjs-core/lib/geom/Vector3D":120}],98:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BoundingVolumeBase = require("awayjs-core/lib/bounds/BoundingVolumeBase");
var PlaneClassification = require("awayjs-core/lib/geom/PlaneClassification");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var BoundingSphere = (function (_super) {
    __extends(BoundingSphere, _super);
    function BoundingSphere() {
        _super.call(this);
        this._radius = 0;
        this._centerX = 0;
        this._centerY = 0;
        this._centerZ = 0;
    }
    Object.defineProperty(BoundingSphere.prototype, "radius", {
        get: function () {
            return this._radius;
        },
        enumerable: true,
        configurable: true
    });
    BoundingSphere.prototype.nullify = function () {
        _super.prototype.nullify.call(this);
        this._centerX = this._centerY = this._centerZ = 0;
        this._radius = 0;
    };
    BoundingSphere.prototype.isInFrustum = function (planes, numPlanes) {
        for (var i = 0; i < numPlanes; ++i) {
            var plane = planes[i];
            var flippedExtentX = plane.a < 0 ? -this._radius : this._radius;
            var flippedExtentY = plane.b < 0 ? -this._radius : this._radius;
            var flippedExtentZ = plane.c < 0 ? -this._radius : this._radius;
            var projDist = plane.a * (this._centerX + flippedExtentX) + plane.b * (this._centerY + flippedExtentY) + plane.c * (this._centerZ + flippedExtentZ) - plane.d;
            if (projDist < 0) {
                return false;
            }
        }
        return true;
    };
    BoundingSphere.prototype.fromSphere = function (center, radius) {
        this._centerX = center.x;
        this._centerY = center.y;
        this._centerZ = center.z;
        this._radius = radius;
        this._aabb.width = this._aabb.height = this._aabb.depth = radius * 2;
        this._aabb.x = this._centerX - radius;
        this._aabb.y = this._centerY + radius;
        this._aabb.z = this._centerZ - radius;
        this._pAabbPointsDirty = true;
    };
    BoundingSphere.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
        this._centerX = (maxX + minX) * .5;
        this._centerY = (maxY + minY) * .5;
        this._centerZ = (maxZ + minZ) * .5;
        var d = maxX - minX;
        var y = maxY - minY;
        var z = maxZ - minZ;
        if (y > d)
            d = y;
        if (z > d)
            d = z;
        this._radius = d * Math.sqrt(.5);
        _super.prototype.fromExtremes.call(this, minX, minY, minZ, maxX, maxY, maxZ);
    };
    BoundingSphere.prototype.clone = function () {
        var clone = new BoundingSphere();
        clone.fromSphere(new Vector3D(this._centerX, this._centerY, this._centerZ), this._radius);
        return clone;
    };
    BoundingSphere.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this.containsPoint(position)) {
            return 0;
        }
        var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
        var vx = direction.x, vy = direction.y, vz = direction.z;
        var rayEntryDistance;
        var a = vx * vx + vy * vy + vz * vz;
        var b = 2 * (px * vx + py * vy + pz * vz);
        var c = px * px + py * py + pz * pz - this._radius * this._radius;
        var det = b * b - 4 * a * c;
        if (det >= 0) {
            var sqrtDet = Math.sqrt(det);
            rayEntryDistance = (-b - sqrtDet) / (2 * a);
            if (rayEntryDistance >= 0) {
                targetNormal.x = px + rayEntryDistance * vx;
                targetNormal.y = py + rayEntryDistance * vy;
                targetNormal.z = pz + rayEntryDistance * vz;
                targetNormal.normalize();
                return rayEntryDistance;
            }
        }
        // ray misses sphere
        return -1;
    };
    BoundingSphere.prototype.containsPoint = function (position) {
        var px = position.x - this._centerX;
        var py = position.y - this._centerY;
        var pz = position.z - this._centerZ;
        var distance = Math.sqrt(px * px + py * py + pz * pz);
        return distance <= this._radius;
    };
    //@override
    BoundingSphere.prototype.classifyToPlane = function (plane) {
        var a = plane.a;
        var b = plane.b;
        var c = plane.c;
        var dd = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
        if (a < 0)
            a = -a;
        if (b < 0)
            b = -b;
        if (c < 0)
            c = -c;
        var rr = (a + b + c) * this._radius;
        return dd > rr ? PlaneClassification.FRONT : dd < -rr ? PlaneClassification.BACK : PlaneClassification.INTERSECT;
    };
    BoundingSphere.prototype.transformFrom = function (bounds, matrix) {
        var sphere = bounds;
        var cx = sphere._centerX;
        var cy = sphere._centerY;
        var cz = sphere._centerZ;
        var raw = new Array(16);
        matrix.copyRawDataTo(raw);
        var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
        var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
        var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
        this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
        this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
        this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
        if (m11 < 0)
            m11 = -m11;
        if (m12 < 0)
            m12 = -m12;
        if (m13 < 0)
            m13 = -m13;
        if (m21 < 0)
            m21 = -m21;
        if (m22 < 0)
            m22 = -m22;
        if (m23 < 0)
            m23 = -m23;
        if (m31 < 0)
            m31 = -m31;
        if (m32 < 0)
            m32 = -m32;
        if (m33 < 0)
            m33 = -m33;
        var r = sphere._radius;
        var rx = m11 + m12 + m13;
        var ry = m21 + m22 + m23;
        var rz = m31 + m32 + m33;
        this._radius = r * Math.sqrt(rx * rx + ry * ry + rz * rz);
        this._aabb.width = this._aabb.height = this._aabb.depth = this._radius * 2;
        this._aabb.x = this._centerX - this._radius;
        this._aabb.y = this._centerY + this._radius;
        this._aabb.z = this._centerZ - this._radius;
    };
    return BoundingSphere;
})(BoundingVolumeBase);
module.exports = BoundingSphere;


},{"awayjs-core/lib/bounds/BoundingVolumeBase":99,"awayjs-core/lib/geom/PlaneClassification":117,"awayjs-core/lib/geom/Vector3D":120}],99:[function(require,module,exports){
var Box = require("awayjs-core/lib/geom/Box");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var BoundingVolumeBase = (function () {
    function BoundingVolumeBase() {
        this._pAabbPoints = new Array();
        this._pAabbPointsDirty = true;
        this._aabb = new Box();
    }
    Object.defineProperty(BoundingVolumeBase.prototype, "aabb", {
        get: function () {
            return this._aabb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoundingVolumeBase.prototype, "aabbPoints", {
        get: function () {
            if (this._pAabbPointsDirty)
                this.pUpdateAABBPoints();
            return this._pAabbPoints;
        },
        enumerable: true,
        configurable: true
    });
    BoundingVolumeBase.prototype.nullify = function () {
        this._aabb.x = this._aabb.y = this._aabb.z = 0;
        this._aabb.width = this._aabb.height = this._aabb.depth = 0;
        this._pAabbPointsDirty = true;
    };
    BoundingVolumeBase.prototype.fromVertices = function (vertices) {
        var i;
        var len = vertices.length;
        var minX, minY, minZ;
        var maxX, maxY, maxZ;
        if (len == 0) {
            this.nullify();
            return;
        }
        var v;
        minX = maxX = vertices[i++];
        minY = maxY = vertices[i++];
        minZ = maxZ = vertices[i++];
        while (i < len) {
            v = vertices[i++];
            if (v < minX)
                minX = v;
            else if (v > maxX)
                maxX = v;
            v = vertices[i++];
            if (v < minY)
                minY = v;
            else if (v > maxY)
                maxY = v;
            v = vertices[i++];
            if (v < minZ)
                minZ = v;
            else if (v > maxZ)
                maxZ = v;
        }
        this.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
    };
    BoundingVolumeBase.prototype.fromSphere = function (center, radius) {
        this.fromExtremes(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);
    };
    BoundingVolumeBase.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
        this._aabb.x = minX;
        this._aabb.y = maxY;
        this._aabb.z = minZ;
        this._aabb.width = maxX - minX;
        this._aabb.height = maxY - minY;
        this._aabb.depth = maxZ - minZ;
        this._pAabbPointsDirty = true;
    };
    BoundingVolumeBase.prototype.isInFrustum = function (planes, numPlanes) {
        throw new AbstractMethodError();
    };
    BoundingVolumeBase.prototype.overlaps = function (bounds) {
        return this._aabb.intersects(bounds.aabb);
    };
    BoundingVolumeBase.prototype.clone = function () {
        throw new AbstractMethodError();
    };
    BoundingVolumeBase.prototype.rayIntersection = function (position, direction, targetNormal) {
        return -1;
    };
    BoundingVolumeBase.prototype.containsPoint = function (position) {
        return false;
    };
    BoundingVolumeBase.prototype.pUpdateAABBPoints = function () {
        var minX = this._aabb.x;
        var minY = this._aabb.y - this._aabb.height;
        var minZ = this._aabb.z;
        var maxX = this._aabb.x + this._aabb.width;
        var maxY = this._aabb.y;
        var maxZ = this._aabb.z + this._aabb.depth;
        this._pAabbPoints[0] = minX;
        this._pAabbPoints[1] = minY;
        this._pAabbPoints[2] = minZ;
        this._pAabbPoints[3] = maxX;
        this._pAabbPoints[4] = minY;
        this._pAabbPoints[5] = minZ;
        this._pAabbPoints[6] = minX;
        this._pAabbPoints[7] = maxY;
        this._pAabbPoints[8] = minZ;
        this._pAabbPoints[9] = maxX;
        this._pAabbPoints[10] = maxY;
        this._pAabbPoints[11] = minZ;
        this._pAabbPoints[12] = minX;
        this._pAabbPoints[13] = minY;
        this._pAabbPoints[14] = maxZ;
        this._pAabbPoints[15] = maxX;
        this._pAabbPoints[16] = minY;
        this._pAabbPoints[17] = maxZ;
        this._pAabbPoints[18] = minX;
        this._pAabbPoints[19] = maxY;
        this._pAabbPoints[20] = maxZ;
        this._pAabbPoints[21] = maxX;
        this._pAabbPoints[22] = maxY;
        this._pAabbPoints[23] = maxZ;
        this._pAabbPointsDirty = false;
    };
    BoundingVolumeBase.prototype.classifyToPlane = function (plane) {
        throw new AbstractMethodError();
    };
    BoundingVolumeBase.prototype.transformFrom = function (bounds, matrix) {
        throw new AbstractMethodError();
    };
    return BoundingVolumeBase;
})();
module.exports = BoundingVolumeBase;


},{"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/geom/Box":110}],100:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BoundingVolumeBase = require("awayjs-core/lib/bounds/BoundingVolumeBase");
var PlaneClassification = require("awayjs-core/lib/geom/PlaneClassification");
var NullBounds = (function (_super) {
    __extends(NullBounds, _super);
    function NullBounds(alwaysIn) {
        if (alwaysIn === void 0) { alwaysIn = true; }
        _super.call(this);
        this._alwaysIn = alwaysIn;
        this._aabb.width = this._aabb.height = this._aabb.depth = Number.POSITIVE_INFINITY;
        this._aabb.x = this._aabb.y = this._aabb.z = this._alwaysIn ? Number.NEGATIVE_INFINITY / 2 : Number.POSITIVE_INFINITY;
    }
    //@override
    NullBounds.prototype.clone = function () {
        return new NullBounds(this._alwaysIn);
    };
    //@override
    NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
        return this._alwaysIn;
    };
    //		//@override
    //		public fromGeometry(geometry:away.base.Geometry)
    //		{
    //		}
    //@override
    NullBounds.prototype.fromSphere = function (center, radius) {
    };
    //@override
    NullBounds.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
    };
    NullBounds.prototype.classifyToPlane = function (plane) {
        return PlaneClassification.INTERSECT;
    };
    //@override
    NullBounds.prototype.transformFrom = function (bounds, matrix) {
        this._alwaysIn = bounds._alwaysIn;
    };
    return NullBounds;
})(BoundingVolumeBase);
module.exports = NullBounds;


},{"awayjs-core/lib/bounds/BoundingVolumeBase":99,"awayjs-core/lib/geom/PlaneClassification":117}],101:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":103}],102:[function(require,module,exports){
module.exports=require(4)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/ArgumentError.js":4,"awayjs-core/lib/errors/Error":103}],103:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],104:[function(require,module,exports){
module.exports=require(6)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/PartialImplementationError.js":6,"awayjs-core/lib/errors/Error":103}],105:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
/**
 * RangeError is thrown when an index is accessed out of range of the number of
 * available indices on an Array.
 */
var RangeError = (function (_super) {
    __extends(RangeError, _super);
    /**
     * Create a new RangeError.
     *
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function RangeError(message, id) {
        if (message === void 0) { message = null; }
        if (id === void 0) { id = 0; }
        _super.call(this, message || "RangeError", id);
    }
    return RangeError;
})(Error);
module.exports = RangeError;


},{"awayjs-core/lib/errors/Error":103}],106:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":107}],107:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],108:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],109:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var ProjectionEvent = (function (_super) {
    __extends(ProjectionEvent, _super);
    function ProjectionEvent(type, projection) {
        _super.call(this, type);
        this._projection = projection;
    }
    Object.defineProperty(ProjectionEvent.prototype, "projection", {
        get: function () {
            return this._projection;
        },
        enumerable: true,
        configurable: true
    });
    ProjectionEvent.MATRIX_CHANGED = "matrixChanged";
    return ProjectionEvent;
})(Event);
module.exports = ProjectionEvent;


},{"awayjs-core/lib/events/Event":107}],110:[function(require,module,exports){
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
/**
 * A Box object is an area defined by its position, as indicated by its
 * top-left-front corner point(<i>x</i>, <i>y</i>, <i>z</i>) and by its width,
 * height and depth.
 *
 *
 * <p>The <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
 * <code>height</code> <code>depth</code> properties of the Box class are
 * independent of each other; changing the value of one property has no effect
 * on the others. However, the <code>right</code>, <code>bottom</code> and
 * <code>back</code> properties are integrally related to those six
 * properties. For example, if you change the value of the <code>right</code>
 * property, the value of the <code>width</code> property changes; if you
 * change the <code>bottom</code> property, the value of the
 * <code>height</code> property changes. </p>
 *
 * <p>The following methods and properties use Box objects:</p>
 *
 * <ul>
 *   <li>The <code>bounds</code> property of the DisplayObject class</li>
 * </ul>
 *
 * <p>You can use the <code>new Box()</code> constructor to create a
 * Box object.</p>
 *
 * <p><b>Note:</b> The Box class does not define a cubic Shape
 * display object.
 */
var Box = (function () {
    /**
     * Creates a new Box object with the top-left-front corner specified by the
     * <code>x</code>, <code>y</code> and <code>z</code> parameters and with the
     * specified <code>width</code>, <code>height</code> and <code>depth</code>
     * parameters. If you call this public without parameters, a box with
     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
     * <code>height</code> and <code>depth</code> properties set to 0 is created.
     *
     * @param x      The <i>x</i> coordinate of the top-left-front corner of the
     *               box.
     * @param y      The <i>y</i> coordinate of the top-left-front corner of the
     *               box.
     * @param z      The <i>z</i> coordinate of the top-left-front corner of the
     *               box.
     * @param width  The width of the box, in pixels.
     * @param height The height of the box, in pixels.
     * @param depth The depth of the box, in pixels.
     */
    function Box(x, y, z, width, height, depth) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (depth === void 0) { depth = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    Object.defineProperty(Box.prototype, "back", {
        /**
         * The sum of the <code>z</code> and <code>height</code> properties.
         */
        get: function () {
            return this.z + this.depth;
        },
        set: function (val) {
            this.depth = val - this.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottom", {
        /**
         * The sum of the <code>y</code> and <code>height</code> properties.
         */
        get: function () {
            return this.y + this.height;
        },
        set: function (val) {
            this.height = val - this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottomRightBack", {
        /**
         * The location of the Box object's bottom-right corner, determined by the
         * values of the <code>right</code> and <code>bottom</code> properties.
         */
        get: function () {
            if (this._bottomRightBack == null)
                this._bottomRightBack = new Vector3D();
            this._bottomRightBack.x = this.x + this.width;
            this._bottomRightBack.y = this.y + this.height;
            this._bottomRightBack.z = this.z + this.depth;
            return this._bottomRightBack;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "front", {
        /**
         * The <i>z</i> coordinate of the top-left-front corner of the box. Changing
         * the <code>front</code> property of a Box object has no effect on the
         * <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code>
         * properties. However it does affect the <code>depth</code> property,
         * whereas changing the <code>z</code> value does <i>not</i> affect the
         * <code>depth</code> property.
         *
         * <p>The value of the <code>left</code> property is equal to the value of
         * the <code>x</code> property.</p>
         */
        get: function () {
            return this.z;
        },
        set: function (val) {
            this.depth += this.z - val;
            this.z = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "left", {
        /**
         * The <i>x</i> coordinate of the top-left corner of the box. Changing the
         * <code>left</code> property of a Box object has no effect on the
         * <code>y</code> and <code>height</code> properties. However it does affect
         * the <code>width</code> property, whereas changing the <code>x</code> value
         * does <i>not</i> affect the <code>width</code> property.
         *
         * <p>The value of the <code>left</code> property is equal to the value of
         * the <code>x</code> property.</p>
         */
        get: function () {
            return this.x;
        },
        set: function (val) {
            this.width += this.x - val;
            this.x = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "right", {
        /**
         * The sum of the <code>x</code> and <code>width</code> properties.
         */
        get: function () {
            return this.x + this.width;
        },
        set: function (val) {
            this.width = val - this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "size", {
        /**
         * The size of the Box object, expressed as a Vector3D object with the
         * values of the <code>width</code>, <code>height</code> and
         * <code>depth</code> properties.
         */
        get: function () {
            if (this._size == null)
                this._size = new Vector3D();
            this._size.x = this.width;
            this._size.y = this.height;
            this._size.z = this.depth;
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "top", {
        /**
         * The <i>y</i> coordinate of the top-left-front corner of the box. Changing
         * the <code>top</code> property of a Box object has no effect on the
         * <code>x</code> and <code>width</code> properties. However it does affect
         * the <code>height</code> property, whereas changing the <code>y</code>
         * value does <i>not</i> affect the <code>height</code> property.
         *
         * <p>The value of the <code>top</code> property is equal to the value of the
         * <code>y</code> property.</p>
         */
        get: function () {
            return this.y;
        },
        set: function (val) {
            this.height += (this.y - val);
            this.y = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "topLeftFront", {
        /**
         * The location of the Box object's top-left-front corner, determined by the
         * <i>x</i>, <i>y</i> and <i>z</i> coordinates of the point.
         */
        get: function () {
            if (this._topLeftFront == null)
                this._topLeftFront = new Vector3D();
            this._topLeftFront.x = this.x;
            this._topLeftFront.y = this.y;
            this._topLeftFront.z = this.z;
            return this._topLeftFront;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new Box object with the same values for the <code>x</code>,
     * <code>y</code>, <code>z</code>, <code>width</code>, <code>height</code>
     * and <code>depth</code> properties as the original Box object.
     *
     * @return A new Box object with the same values for the <code>x</code>,
     *         <code>y</code>, <code>z</code>, <code>width</code>,
     *         <code>height</code> and <code>depth</code> properties as the
     *         original Box object.
     */
    Box.prototype.clone = function () {
        return new Box(this.x, this.y, this.z, this.width, this.height, this.depth);
    };
    /**
     * Determines whether the specified position is contained within the cubic
     * region defined by this Box object.
     *
     * @param x The <i>x</i> coordinate(horizontal component) of the position.
     * @param y The <i>y</i> coordinate(vertical component) of the position.
     * @param z The <i>z</i> coordinate(longitudinal component) of the position.
     * @return A value of <code>true</code> if the Box object contains the
     *         specified position; otherwise <code>false</code>.
     */
    Box.prototype.contains = function (x, y, z) {
        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y && this.z <= z && this.z + this.depth >= z);
    };
    /**
     * Determines whether the specified position is contained within the cubic
     * region defined by this Box object. This method is similar to the
     * <code>Box.contains()</code> method, except that it takes a Vector3D
     * object as a parameter.
     *
     * @param position The position, as represented by its <i>x</i>, <i>y</i> and
     *                 <i>z</i> coordinates.
     * @return A value of <code>true</code> if the Box object contains the
     *         specified position; otherwise <code>false</code>.
     */
    Box.prototype.containsPoint = function (position) {
        return (this.x <= position.x && this.x + this.width >= position.x && this.y <= position.y && this.y + this.height >= position.y && this.z <= position.z && this.z + this.depth >= position.z);
    };
    /**
     * Determines whether the Box object specified by the <code>box</code>
     * parameter is contained within this Box object. A Box object is said to
     * contain another if the second Box object falls entirely within the
     * boundaries of the first.
     *
     * @param box The Box object being checked.
     * @return A value of <code>true</code> if the Box object that you specify
     *         is contained by this Box object; otherwise <code>false</code>.
     */
    Box.prototype.containsRect = function (box) {
        return (this.x <= box.x && this.x + this.width >= box.x + box.width && this.y <= box.y && this.y + this.height >= box.y + box.height && this.z <= box.z && this.z + this.depth >= box.z + box.depth);
    };
    /**
     * Copies all of box data from the source Box object into the calling
     * Box object.
     *
     * @param sourceBox The Box object from which to copy the data.
     */
    Box.prototype.copyFrom = function (sourceBox) {
        //TODO
    };
    /**
     * Determines whether the object specified in the <code>toCompare</code>
     * parameter is equal to this Box object. This method compares the
     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
     * <code>height</code> and <code>depth</code> properties of an object against
     * the same properties of this Box object.
     *
     * @param toCompare The box to compare to this Box object.
     * @return A value of <code>true</code> if the object has exactly the same
     *         values for the <code>x</code>, <code>y</code>, <code>z</code>,
     *         <code>width</code>, <code>height</code> and <code>depth</code>
     *         properties as this Box object; otherwise <code>false</code>.
     */
    Box.prototype.equals = function (toCompare) {
        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && this.width == toCompare.width && this.height == toCompare.height && this.depth == toCompare.depth);
    };
    /**
     * Increases the size of the Box object by the specified amounts, in
     * pixels. The center point of the Box object stays the same, and its
     * size increases to the left and right by the <code>dx</code> value, to
     * the top and the bottom by the <code>dy</code> value, and to
     * the front and the back by the <code>dz</code> value.
     *
     * @param dx The value to be added to the left and the right of the Box
     *           object. The following equation is used to calculate the new
     *           width and position of the box:
     * @param dy The value to be added to the top and the bottom of the Box
     *           object. The following equation is used to calculate the new
     *           height and position of the box:
     * @param dz The value to be added to the front and the back of the Box
     *           object. The following equation is used to calculate the new
     *           depth and position of the box:
     */
    Box.prototype.inflate = function (dx, dy, dz) {
        this.x -= dx / 2;
        this.y -= dy / 2;
        this.z -= dz / 2;
        this.width += dx / 2;
        this.height += dy / 2;
        this.depth += dz / 2;
    };
    /**
     * Increases the size of the Box object. This method is similar to the
     * <code>Box.inflate()</code> method except it takes a Vector3D object as
     * a parameter.
     *
     * <p>The following two code examples give the same result:</p>
     *
     * @param delta The <code>x</code> property of this Vector3D object is used to
     *              increase the horizontal dimension of the Box object.
     *              The <code>y</code> property is used to increase the vertical
     *              dimension of the Box object.
     *              The <code>z</code> property is used to increase the
     *              longitudinal dimension of the Box object.
     */
    Box.prototype.inflatePoint = function (delta) {
        this.x -= delta.x / 2;
        this.y -= delta.y / 2;
        this.z -= delta.z / 2;
        this.width += delta.x / 2;
        this.height += delta.y / 2;
        this.depth += delta.z / 2;
    };
    /**
     * If the Box object specified in the <code>toIntersect</code> parameter
     * intersects with this Box object, returns the area of intersection
     * as a Box object. If the boxes do not intersect, this method returns an
     * empty Box object with its properties set to 0.
     *
     * @param toIntersect The Box object to compare against to see if it
     *                    intersects with this Box object.
     * @return A Box object that equals the area of intersection. If the
     *         boxes do not intersect, this method returns an empty Box
     *         object; that is, a box with its <code>x</code>, <code>y</code>,
     *         <code>z</code>, <code>width</code>,  <code>height</code>, and
     *         <code>depth</code> properties set to 0.
     */
    Box.prototype.intersection = function (toIntersect) {
        if (this.intersects(toIntersect)) {
            var i = new Box();
            if (this.x > toIntersect.x) {
                i.x = this.x;
                i.width = toIntersect.x - this.x + toIntersect.width;
                if (i.width > this.width)
                    i.width = this.width;
            }
            else {
                i.x = toIntersect.x;
                i.width = this.x - toIntersect.x + this.width;
                if (i.width > toIntersect.width)
                    i.width = toIntersect.width;
            }
            if (this.y > toIntersect.y) {
                i.y = this.y;
                i.height = toIntersect.y - this.y + toIntersect.height;
                if (i.height > this.height)
                    i.height = this.height;
            }
            else {
                i.y = toIntersect.y;
                i.height = this.y - toIntersect.y + this.height;
                if (i.height > toIntersect.height)
                    i.height = toIntersect.height;
            }
            if (this.z > toIntersect.z) {
                i.z = this.z;
                i.depth = toIntersect.z - this.z + toIntersect.depth;
                if (i.depth > this.depth)
                    i.depth = this.depth;
            }
            else {
                i.z = toIntersect.z;
                i.depth = this.z - toIntersect.z + this.depth;
                if (i.depth > toIntersect.depth)
                    i.depth = toIntersect.depth;
            }
            return i;
        }
        return new Box();
    };
    /**
     * Determines whether the object specified in the <code>toIntersect</code>
     * parameter intersects with this Box object. This method checks the
     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
     * <code>height</code>, and <code>depth</code> properties of the specified
     * Box object to see if it intersects with this Box object.
     *
     * @param toIntersect The Box object to compare against this Box object.
     * @return A value of <code>true</code> if the specified object intersects
     *         with this Box object; otherwise <code>false</code>.
     */
    Box.prototype.intersects = function (toIntersect) {
        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height && this.z + this.depth > toIntersect.z && this.z < toIntersect.z + toIntersect.depth);
    };
    /**
     * Determines whether or not this Box object is empty.
     *
     * @return A value of <code>true</code> if the Box object's width, height or
     *         depth is less than or equal to 0; otherwise <code>false</code>.
     */
    Box.prototype.isEmpty = function () {
        return (this.x == 0 && this.y == 0 && this.z == 0 && this.width == 0 && this.height == 0 && this.depth == 0);
    };
    /**
     * Adjusts the location of the Box object, as determined by its
     * top-left-front corner, by the specified amounts.
     *
     * @param dx Moves the <i>x</i> value of the Box object by this amount.
     * @param dy Moves the <i>y</i> value of the Box object by this amount.
     * @param dz Moves the <i>z</i> value of the Box object by this amount.
     */
    Box.prototype.offset = function (dx, dy, dz) {
        this.x += dx;
        this.y += dy;
        this.z += dz;
    };
    /**
     * Adjusts the location of the Box object using a Vector3D object as a
     * parameter. This method is similar to the <code>Box.offset()</code>
     * method, except that it takes a Vector3D object as a parameter.
     *
     * @param position A Vector3D object to use to offset this Box object.
     */
    Box.prototype.offsetPosition = function (position) {
        this.x += position.x;
        this.y += position.y;
        this.z += position.z;
    };
    /**
     * Sets all of the Box object's properties to 0. A Box object is empty if its
     * width, height or depth is less than or equal to 0.
     *
     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
     * <code>z</code>, <code>width</code>, <code>height</code>, and
     * <code>depth</code> properties to 0.</p>
     *
     */
    Box.prototype.setEmpty = function () {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.width = 0;
        this.height = 0;
        this.depth = 0;
    };
    /**
     * Sets the members of Box to the specified values
     *
     * @param xa      The <i>x</i> coordinate of the top-left-front corner of the
     *                box.
     * @param ya      The <i>y</i> coordinate of the top-left-front corner of the
     *                box.
     * @param yz      The <i>z</i> coordinate of the top-left-front corner of the
     *                box.
     * @param widtha  The width of the box, in pixels.
     * @param heighta The height of the box, in pixels.
     * @param deptha  The depth of the box, in pixels.
     */
    Box.prototype.setTo = function (xa, ya, za, widtha, heighta, deptha) {
        this.x = xa;
        this.y = ya;
        this.z = za;
        this.width = widtha;
        this.height = heighta;
        this.depth = deptha;
    };
    /**
     * Builds and returns a string that lists the horizontal, vertical and
     * longitudinal positions and the width, height and depth of the Box object.
     *
     * @return A string listing the value of each of the following properties of
     *         the Box object: <code>x</code>, <code>y</code>, <code>z</code>,
     *         <code>width</code>, <code>height</code>, and <code>depth</code>.
     */
    Box.prototype.toString = function () {
        return "[Box] (x=" + this.x + ", y=" + this.y + ", z=" + this.z + ", width=" + this.width + ", height=" + this.height + ", depth=" + this.depth + ")";
    };
    /**
     * Adds two boxes together to create a new Box object, by filling
     * in the horizontal, vertical and longitudinal space between the two boxes.
     *
     * <p><b>Note:</b> The <code>union()</code> method ignores boxes with
     * <code>0</code> as the height, width or depth value, such as: <code>var
     * box2:Box = new Box(300,300,300,50,50,0);</code></p>
     *
     * @param toUnion A Box object to add to this Box object.
     * @return A new Box object that is the union of the two boxes.
     */
    Box.prototype.union = function (toUnion) {
        var u = new Box();
        if (this.x < toUnion.x) {
            u.x = this.x;
            u.width = toUnion.x - this.x + toUnion.width;
            if (u.width < this.width)
                u.width = this.width;
        }
        else {
            u.x = toUnion.x;
            u.width = this.x - toUnion.x + this.width;
            if (u.width < toUnion.width)
                u.width = toUnion.width;
        }
        if (this.y < toUnion.y) {
            u.y = this.y;
            u.height = toUnion.y - this.y + toUnion.height;
            if (u.height < this.height)
                u.height = this.height;
        }
        else {
            u.y = toUnion.y;
            u.height = this.y - toUnion.y + this.height;
            if (u.height < toUnion.height)
                u.height = toUnion.height;
        }
        if (this.z < toUnion.z) {
            u.z = this.z;
            u.depth = toUnion.z - this.z + toUnion.depth;
            if (u.depth < this.depth)
                u.depth = this.depth;
        }
        else {
            u.z = toUnion.z;
            u.depth = this.z - toUnion.z + this.depth;
            if (u.depth < toUnion.depth)
                u.depth = toUnion.depth;
        }
        return u;
    };
    return Box;
})();
module.exports = Box;


},{"awayjs-core/lib/geom/Vector3D":120}],111:[function(require,module,exports){
/**
* MathConsts provides some commonly used mathematical constants
*/
var MathConsts = (function () {
    function MathConsts() {
    }
    /**
     * The amount to multiply with when converting radians to degrees.
     */
    MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;
    /**
     * The amount to multiply with when converting degrees to radians.
     */
    MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;
    return MathConsts;
})();
module.exports = MathConsts;


},{}],112:[function(require,module,exports){
module.exports=require(16)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Matrix.js":16,"awayjs-core/lib/errors/ArgumentError":102,"awayjs-core/lib/geom/Point":118}],113:[function(require,module,exports){
var Orientation3D = require("awayjs-core/lib/geom/Orientation3D");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var ArgumentError = require("awayjs-core/lib/errors/ArgumentError");
var Matrix3D = (function () {
    /**
     * Creates a Matrix3D object.
     */
    function Matrix3D(v) {
        if (v === void 0) { v = null; }
        if (v != null && v.length == 16)
            this.rawData = v.concat();
        else
            this.rawData = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    /**
     * Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.
     */
    Matrix3D.prototype.append = function (lhs) {
        var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
    };
    /**
     * Appends an incremental rotation to a Matrix3D object.
     */
    Matrix3D.prototype.appendRotation = function (degrees, axis) {
        var m = Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees);
        this.append(m);
    };
    /**
     * Appends an incremental scale change along the x, y, and z axes to a Matrix3D object.
     */
    Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
        this.append(new Matrix3D([xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, zScale, 0.0, 0.0, 0.0, 0.0, 1.0]));
    };
    /**
     * Appends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
     */
    Matrix3D.prototype.appendTranslation = function (x, y, z) {
        this.rawData[12] += x;
        this.rawData[13] += y;
        this.rawData[14] += z;
    };
    /**
     * Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.
     */
    Matrix3D.prototype.clone = function () {
        return new Matrix3D(this.rawData.slice(0));
    };
    /**
     * Copies a Vector3D object into specific column of the calling Matrix3D object.
     */
    Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
        switch (column) {
            case 0:
                this.rawData[0] = vector3D.x;
                this.rawData[1] = vector3D.y;
                this.rawData[2] = vector3D.z;
                this.rawData[3] = vector3D.w;
                break;
            case 1:
                this.rawData[4] = vector3D.x;
                this.rawData[5] = vector3D.y;
                this.rawData[6] = vector3D.z;
                this.rawData[7] = vector3D.w;
                break;
            case 2:
                this.rawData[8] = vector3D.x;
                this.rawData[9] = vector3D.y;
                this.rawData[10] = vector3D.z;
                this.rawData[11] = vector3D.w;
                break;
            case 3:
                this.rawData[12] = vector3D.x;
                this.rawData[13] = vector3D.y;
                this.rawData[14] = vector3D.z;
                this.rawData[15] = vector3D.w;
                break;
            default:
                throw new ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
        }
    };
    /**
     * Copies specific column of the calling Matrix3D object into the Vector3D object.
     */
    Matrix3D.prototype.copyColumnTo = function (column, vector3D) {
        switch (column) {
            case 0:
                vector3D.x = this.rawData[0];
                vector3D.y = this.rawData[1];
                vector3D.z = this.rawData[2];
                vector3D.w = this.rawData[3];
                break;
            case 1:
                vector3D.x = this.rawData[4];
                vector3D.y = this.rawData[5];
                vector3D.z = this.rawData[6];
                vector3D.w = this.rawData[7];
                break;
            case 2:
                vector3D.x = this.rawData[8];
                vector3D.y = this.rawData[9];
                vector3D.z = this.rawData[10];
                vector3D.w = this.rawData[11];
                break;
            case 3:
                vector3D.x = this.rawData[12];
                vector3D.y = this.rawData[13];
                vector3D.z = this.rawData[14];
                vector3D.w = this.rawData[15];
                break;
            default:
                throw new ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
        }
    };
    /**
     * Copies all of the matrix data from the source Matrix3D object into the calling Matrix3D object.
     */
    Matrix3D.prototype.copyFrom = function (sourceMatrix3D) {
        var len = sourceMatrix3D.rawData.length;
        for (var c = 0; c < len; c++)
            this.rawData[c] = sourceMatrix3D.rawData[c];
    };
    Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
        if (index === void 0) { index = 0; }
        if (transpose === void 0) { transpose = false; }
        if (transpose)
            this.transpose();
        var len = vector.length - index;
        for (var c = 0; c < len; c++)
            this.rawData[c] = vector[c + index];
        if (transpose)
            this.transpose();
    };
    Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
        if (index === void 0) { index = 0; }
        if (transpose === void 0) { transpose = false; }
        if (transpose)
            this.transpose();
        var len = this.rawData.length;
        for (var c = 0; c < len; c++)
            vector[c + index] = this.rawData[c];
        if (transpose)
            this.transpose();
    };
    /**
     * Copies a Vector3D object into specific row of the calling Matrix3D object.
     */
    Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
        switch (row) {
            case 0:
                this.rawData[0] = vector3D.x;
                this.rawData[4] = vector3D.y;
                this.rawData[8] = vector3D.z;
                this.rawData[12] = vector3D.w;
                break;
            case 1:
                this.rawData[1] = vector3D.x;
                this.rawData[5] = vector3D.y;
                this.rawData[9] = vector3D.z;
                this.rawData[13] = vector3D.w;
                break;
            case 2:
                this.rawData[2] = vector3D.x;
                this.rawData[6] = vector3D.y;
                this.rawData[10] = vector3D.z;
                this.rawData[14] = vector3D.w;
                break;
            case 3:
                this.rawData[3] = vector3D.x;
                this.rawData[7] = vector3D.y;
                this.rawData[11] = vector3D.z;
                this.rawData[15] = vector3D.w;
                break;
            default:
                throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
        }
    };
    /**
     * Copies specific row of the calling Matrix3D object into the Vector3D object.
     */
    Matrix3D.prototype.copyRowTo = function (row, vector3D) {
        switch (row) {
            case 0:
                vector3D.x = this.rawData[0];
                vector3D.y = this.rawData[4];
                vector3D.z = this.rawData[8];
                vector3D.w = this.rawData[12];
                break;
            case 1:
                vector3D.x = this.rawData[1];
                vector3D.y = this.rawData[5];
                vector3D.z = this.rawData[9];
                vector3D.w = this.rawData[13];
                break;
            case 2:
                vector3D.x = this.rawData[2];
                vector3D.y = this.rawData[6];
                vector3D.z = this.rawData[10];
                vector3D.w = this.rawData[14];
                break;
            case 3:
                vector3D.x = this.rawData[3];
                vector3D.y = this.rawData[7];
                vector3D.z = this.rawData[11];
                vector3D.w = this.rawData[15];
                break;
            default:
                throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
        }
    };
    /**
     * Copies this Matrix3D object into a destination Matrix3D object.
     */
    Matrix3D.prototype.copyToMatrix3D = function (dest) {
        dest.rawData = this.rawData.slice(0);
    };
    /**
     * Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector3D objects.
     */
    Matrix3D.prototype.decompose = function (orientationStyle) {
        if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
        var q;
        // Initial Tests - Not OK
        var vec = [];
        var m = this.clone();
        var mr = m.rawData;
        var pos = new Vector3D(mr[12], mr[13], mr[14]);
        mr[12] = 0;
        mr[13] = 0;
        mr[14] = 0;
        var scale = new Vector3D();
        scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
        scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
        scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
        if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0)
            scale.z = -scale.z;
        mr[0] /= scale.x;
        mr[1] /= scale.x;
        mr[2] /= scale.x;
        mr[4] /= scale.y;
        mr[5] /= scale.y;
        mr[6] /= scale.y;
        mr[8] /= scale.z;
        mr[9] /= scale.z;
        mr[10] /= scale.z;
        var rot = new Vector3D();
        switch (orientationStyle) {
            case Orientation3D.AXIS_ANGLE:
                rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
                var len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
                rot.x = (mr[6] - mr[9]) / len;
                rot.y = (mr[8] - mr[2]) / len;
                rot.z = (mr[1] - mr[4]) / len;
                break;
            case Orientation3D.QUATERNION:
                var tr = mr[0] + mr[5] + mr[10];
                if (tr > 0) {
                    rot.w = Math.sqrt(1 + tr) / 2;
                    rot.x = (mr[6] - mr[9]) / (4 * rot.w);
                    rot.y = (mr[8] - mr[2]) / (4 * rot.w);
                    rot.z = (mr[1] - mr[4]) / (4 * rot.w);
                }
                else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                    rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                    rot.w = (mr[6] - mr[9]) / (4 * rot.x);
                    rot.y = (mr[1] + mr[4]) / (4 * rot.x);
                    rot.z = (mr[8] + mr[2]) / (4 * rot.x);
                }
                else if (mr[5] > mr[10]) {
                    rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                    rot.x = (mr[1] + mr[4]) / (4 * rot.y);
                    rot.w = (mr[8] - mr[2]) / (4 * rot.y);
                    rot.z = (mr[6] + mr[9]) / (4 * rot.y);
                }
                else {
                    rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                    rot.x = (mr[8] + mr[2]) / (4 * rot.z);
                    rot.y = (mr[6] + mr[9]) / (4 * rot.z);
                    rot.w = (mr[1] - mr[4]) / (4 * rot.z);
                }
                break;
            case Orientation3D.EULER_ANGLES:
                rot.y = Math.asin(-mr[2]);
                //var cos:number = Math.cos(rot.y);
                if (mr[2] != 1 && mr[2] != -1) {
                    rot.x = Math.atan2(mr[6], mr[10]);
                    rot.z = Math.atan2(mr[1], mr[0]);
                }
                else {
                    rot.z = 0;
                    rot.x = Math.atan2(mr[4], mr[5]);
                }
                break;
        }
        vec.push(pos);
        vec.push(rot);
        vec.push(scale);
        return vec;
    };
    /**
     * Uses the transformation matrix without its translation elements to transform a Vector3D object from one space
     * coordinate to another.
     */
    Matrix3D.prototype.deltaTransformVector = function (v) {
        var x = v.x;
        var y = v.y;
        var z = v.z;
        return new Vector3D((x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8]), (x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9]), (x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10]), (x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11]));
    };
    /**
     * Converts the current matrix to an identity or unit matrix.
     */
    Matrix3D.prototype.identity = function () {
        this.rawData = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    };
    /**
     * [static] Interpolates the translation, rotation, and scale transformation of one matrix toward those of the target matrix.
     */
    Matrix3D.interpolate = function (thisMat, toMat, percent) {
        var m = new Matrix3D();
        for (var i = 0; i < 16; ++i)
            m.rawData[i] = thisMat.rawData[i] + (toMat.rawData[i] - thisMat.rawData[i]) * percent;
        return m;
    };
    /**
     * Interpolates this matrix towards the translation, rotation, and scale transformations of the target matrix.
     */
    Matrix3D.prototype.interpolateTo = function (toMat, percent) {
        for (var i = 0; i < 16; ++i)
            this.rawData[i] = this.rawData[i] + (toMat.rawData[i] - this.rawData[i]) * percent;
    };
    /**
     * Inverts the current matrix.
     */
    Matrix3D.prototype.invert = function () {
        var d = this.determinant;
        var invertable = Math.abs(d) > 0.00000000001;
        if (invertable) {
            d = 1 / d;
            var m11 = this.rawData[0];
            var m21 = this.rawData[4];
            var m31 = this.rawData[8];
            var m41 = this.rawData[12];
            var m12 = this.rawData[1];
            var m22 = this.rawData[5];
            var m32 = this.rawData[9];
            var m42 = this.rawData[13];
            var m13 = this.rawData[2];
            var m23 = this.rawData[6];
            var m33 = this.rawData[10];
            var m43 = this.rawData[14];
            var m14 = this.rawData[3];
            var m24 = this.rawData[7];
            var m34 = this.rawData[11];
            var m44 = this.rawData[15];
            this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
            this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
            this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
            this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
            this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
            this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
            this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
            this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
            this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
            this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
            this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
            this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
            this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
            this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
            this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
            this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
        }
        return invertable;
    };
    /* TODO implement pointAt
     public pointAt( pos:Vector3D, at:Vector3D = null, up:Vector3D = null )
     {
     }
     */
    /**
     * Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.
     */
    Matrix3D.prototype.prepend = function (rhs) {
        var m111 = rhs.rawData[0], m121 = rhs.rawData[4], m131 = rhs.rawData[8], m141 = rhs.rawData[12], m112 = rhs.rawData[1], m122 = rhs.rawData[5], m132 = rhs.rawData[9], m142 = rhs.rawData[13], m113 = rhs.rawData[2], m123 = rhs.rawData[6], m133 = rhs.rawData[10], m143 = rhs.rawData[14], m114 = rhs.rawData[3], m124 = rhs.rawData[7], m134 = rhs.rawData[11], m144 = rhs.rawData[15], m211 = this.rawData[0], m221 = this.rawData[4], m231 = this.rawData[8], m241 = this.rawData[12], m212 = this.rawData[1], m222 = this.rawData[5], m232 = this.rawData[9], m242 = this.rawData[13], m213 = this.rawData[2], m223 = this.rawData[6], m233 = this.rawData[10], m243 = this.rawData[14], m214 = this.rawData[3], m224 = this.rawData[7], m234 = this.rawData[11], m244 = this.rawData[15];
        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
    };
    /**
     * Prepends an incremental rotation to a Matrix3D object.
     */
    Matrix3D.prototype.prependRotation = function (degrees, axis) {
        var m = Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees);
        /*
         if ( pivot != null )
         {
         var p:Vector3D = pivot;
         m.appendTranslation( p.x, p.y, p.z );
         }
         */
        this.prepend(m);
    };
    /**
     * Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.
     */
    Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
        // Initial Tests - OK
        this.prepend(new Matrix3D([xScale, 0, 0, 0, 0, yScale, 0, 0, 0, 0, zScale, 0, 0, 0, 0, 1]));
    };
    /**
     * Prepends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
     */
    Matrix3D.prototype.prependTranslation = function (x, y, z) {
        // Initial Tests - OK
        var m = new Matrix3D();
        m.position = new Vector3D(x, y, z);
        this.prepend(m);
    };
    // TODO orientationStyle
    /**
     * Sets the transformation matrix's translation, rotation, and scale settings.
     */
    Matrix3D.prototype.recompose = function (components) {
        // Initial Tests - OK
        if (components.length < 3)
            return false;
        //components[2].x == 0 || components[2].y == 0 || components[2].z == 0) return false;
        this.identity();
        this.appendScale(components[2].x, components[2].y, components[2].z);
        var angle;
        angle = -components[1].x;
        this.append(new Matrix3D([1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 0]));
        angle = -components[1].y;
        this.append(new Matrix3D([Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 0]));
        angle = -components[1].z;
        this.append(new Matrix3D([Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]));
        this.position = components[0];
        this.rawData[15] = 1;
        return true;
    };
    Matrix3D.prototype.transformVector = function (v) {
        var x = v.x;
        var y = v.y;
        var z = v.z;
        return new Vector3D((x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12]), (x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13]), (x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14]), (x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15]));
    };
    /**
     * Uses the transformation matrix to transform a Vector of Numbers from one coordinate space to another.
     */
    Matrix3D.prototype.transformVectors = function (vin, vout) {
        // Initial Tests - OK
        var i = 0;
        var x = 0, y = 0, z = 0;
        while (i + 3 <= vin.length) {
            x = vin[i];
            y = vin[i + 1];
            z = vin[i + 2];
            vout[i] = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
            vout[i + 1] = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
            vout[i + 2] = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
            i += 3;
        }
    };
    /**
     * Converts the current Matrix3D object to a matrix where the rows and columns are swapped.
     */
    Matrix3D.prototype.transpose = function () {
        // Initial Tests - OK
        var oRawData = this.rawData.slice(0);
        this.rawData[1] = oRawData[4];
        this.rawData[2] = oRawData[8];
        this.rawData[3] = oRawData[12];
        this.rawData[4] = oRawData[1];
        this.rawData[6] = oRawData[9];
        this.rawData[7] = oRawData[13];
        this.rawData[8] = oRawData[2];
        this.rawData[9] = oRawData[6];
        this.rawData[11] = oRawData[14];
        this.rawData[12] = oRawData[3];
        this.rawData[13] = oRawData[7];
        this.rawData[14] = oRawData[11];
    };
    Matrix3D.getAxisRotation = function (x, y, z, degrees) {
        // internal class use by rotations which have been tested
        var m = new Matrix3D();
        var rad = degrees * (Math.PI / 180);
        var c = Math.cos(rad);
        var s = Math.sin(rad);
        var t = 1 - c;
        var tmp1, tmp2;
        m.rawData[0] = c + x * x * t;
        m.rawData[5] = c + y * y * t;
        m.rawData[10] = c + z * z * t;
        tmp1 = x * y * t;
        tmp2 = z * s;
        m.rawData[1] = tmp1 + tmp2;
        m.rawData[4] = tmp1 - tmp2;
        tmp1 = x * z * t;
        tmp2 = y * s;
        m.rawData[8] = tmp1 + tmp2;
        m.rawData[2] = tmp1 - tmp2;
        tmp1 = y * z * t;
        tmp2 = x * s;
        m.rawData[9] = tmp1 - tmp2;
        m.rawData[6] = tmp1 + tmp2;
        return m;
    };
    Object.defineProperty(Matrix3D.prototype, "determinant", {
        /**
         * [read-only] A Number that determines whether a matrix is invertible.
         */
        get: function () {
            return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3D.prototype, "position", {
        /**
         * A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object within the
         * transformation's frame of reference.
         */
        get: function () {
            return new Vector3D(this.rawData[12], this.rawData[13], this.rawData[14]);
        },
        set: function (value) {
            this.rawData[12] = value.x;
            this.rawData[13] = value.y;
            this.rawData[14] = value.z;
        },
        enumerable: true,
        configurable: true
    });
    Matrix3D.prototype.toFixed = function (decimalPlace) {
        var magnitude = Math.pow(10, decimalPlace);
        return "matrix3d(" + Math.round(this.rawData[0] * magnitude) / magnitude + "," + Math.round(this.rawData[1] * magnitude) / magnitude + "," + Math.round(this.rawData[2] * magnitude) / magnitude + "," + Math.round(this.rawData[3] * magnitude) / magnitude + "," + Math.round(this.rawData[4] * magnitude) / magnitude + "," + Math.round(this.rawData[5] * magnitude) / magnitude + "," + Math.round(this.rawData[6] * magnitude) / magnitude + "," + Math.round(this.rawData[7] * magnitude) / magnitude + "," + Math.round(this.rawData[8] * magnitude) / magnitude + "," + Math.round(this.rawData[9] * magnitude) / magnitude + "," + Math.round(this.rawData[10] * magnitude) / magnitude + "," + Math.round(this.rawData[11] * magnitude) / magnitude + "," + Math.round(this.rawData[12] * magnitude) / magnitude + "," + Math.round(this.rawData[13] * magnitude) / magnitude + "," + Math.round(this.rawData[14] * magnitude) / magnitude + "," + Math.round(this.rawData[15] * magnitude) / magnitude + ")";
    };
    Matrix3D.prototype.toString = function () {
        return "matrix3d(" + Math.round(this.rawData[0] * 1000) / 1000 + "," + Math.round(this.rawData[1] * 1000) / 1000 + "," + Math.round(this.rawData[2] * 1000) / 1000 + "," + Math.round(this.rawData[3] * 1000) / 1000 + "," + Math.round(this.rawData[4] * 1000) / 1000 + "," + Math.round(this.rawData[5] * 1000) / 1000 + "," + Math.round(this.rawData[6] * 1000) / 1000 + "," + Math.round(this.rawData[7] * 1000) / 1000 + "," + Math.round(this.rawData[8] * 1000) / 1000 + "," + Math.round(this.rawData[9] * 1000) / 1000 + "," + Math.round(this.rawData[10] * 1000) / 1000 + "," + Math.round(this.rawData[11] * 1000) / 1000 + "," + Math.round(this.rawData[12] * 1000) / 1000 + "," + Math.round(this.rawData[13] * 1000) / 1000 + "," + Math.round(this.rawData[14] * 1000) / 1000 + "," + Math.round(this.rawData[15] * 1000) / 1000 + ")";
    };
    return Matrix3D;
})();
module.exports = Matrix3D;


},{"awayjs-core/lib/errors/ArgumentError":102,"awayjs-core/lib/geom/Orientation3D":115,"awayjs-core/lib/geom/Vector3D":120}],114:[function(require,module,exports){
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
/**
 * away.geom.Matrix3DUtils provides additional Matrix3D functions.
 */
var Matrix3DUtils = (function () {
    function Matrix3DUtils() {
    }
    /**
     * Fills the 3d matrix object with values representing the transformation made by the given quaternion.
     *
     * @param    quarternion    The quarterion object to convert.
     */
    Matrix3DUtils.quaternion2matrix = function (quarternion, m) {
        if (m === void 0) { m = null; }
        var x = quarternion.x;
        var y = quarternion.y;
        var z = quarternion.z;
        var w = quarternion.w;
        var xx = x * x;
        var xy = x * y;
        var xz = x * z;
        var xw = x * w;
        var yy = y * y;
        var yz = y * z;
        var yw = y * w;
        var zz = z * z;
        var zw = z * w;
        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        raw[0] = 1 - 2 * (yy + zz);
        raw[1] = 2 * (xy + zw);
        raw[2] = 2 * (xz - yw);
        raw[4] = 2 * (xy - zw);
        raw[5] = 1 - 2 * (xx + zz);
        raw[6] = 2 * (yz + xw);
        raw[8] = 2 * (xz + yw);
        raw[9] = 2 * (yz - xw);
        raw[10] = 1 - 2 * (xx + yy);
        raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
        raw[15] = 1;
        if (m) {
            m.copyRawDataFrom(raw);
            return m;
        }
        else
            return new Matrix3D(raw);
    };
    /**
     * Returns a normalised <code>Vector3D</code> object representing the forward vector of the given matrix.
     * @param    m        The Matrix3D object to use to get the forward vector
     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
     * @return            The forward vector
     */
    Matrix3DUtils.getForward = function (m, v) {
        if (v === void 0) { v = null; }
        //v ||= new Vector3D(0.0, 0.0, 0.0);
        if (v === null) {
            v = new Vector3D(0.0, 0.0, 0.0);
        }
        m.copyColumnTo(2, v);
        v.normalize();
        return v;
    };
    /**
     * Returns a normalised <code>Vector3D</code> object representing the up vector of the given matrix.
     * @param    m        The Matrix3D object to use to get the up vector
     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
     * @return            The up vector
     */
    Matrix3DUtils.getUp = function (m, v) {
        //v ||= new Vector3D(0.0, 0.0, 0.0);
        if (v === void 0) { v = null; }
        if (v === null) {
            v = new Vector3D(0.0, 0.0, 0.0);
        }
        m.copyColumnTo(1, v);
        v.normalize();
        return v;
    };
    /**
     * Returns a normalised <code>Vector3D</code> object representing the right vector of the given matrix.
     * @param    m        The Matrix3D object to use to get the right vector
     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
     * @return            The right vector
     */
    Matrix3DUtils.getRight = function (m, v) {
        if (v === void 0) { v = null; }
        //v ||= new Vector3D(0.0, 0.0, 0.0);
        if (v === null) {
            v = new Vector3D(0.0, 0.0, 0.0);
        }
        m.copyColumnTo(0, v);
        v.normalize();
        return v;
    };
    /**
     * Returns a boolean value representing whether there is any significant difference between the two given 3d matrices.
     */
    Matrix3DUtils.compare = function (m1, m2) {
        var r1 = Matrix3DUtils.RAW_DATA_CONTAINER;
        var r2 = m2.rawData;
        m1.copyRawDataTo(r1);
        for (var i = 0; i < 16; ++i) {
            if (r1[i] != r2[i])
                return false;
        }
        return true;
    };
    Matrix3DUtils.lookAt = function (matrix, pos, dir, up) {
        var dirN;
        var upN;
        var lftN;
        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        lftN = dir.crossProduct(up);
        lftN.normalize();
        upN = lftN.crossProduct(dir);
        upN.normalize();
        dirN = dir.clone();
        dirN.normalize();
        raw[0] = lftN.x;
        raw[1] = upN.x;
        raw[2] = -dirN.x;
        raw[3] = 0.0;
        raw[4] = lftN.y;
        raw[5] = upN.y;
        raw[6] = -dirN.y;
        raw[7] = 0.0;
        raw[8] = lftN.z;
        raw[9] = upN.z;
        raw[10] = -dirN.z;
        raw[11] = 0.0;
        raw[12] = -lftN.dotProduct(pos);
        raw[13] = -upN.dotProduct(pos);
        raw[14] = dirN.dotProduct(pos);
        raw[15] = 1.0;
        matrix.copyRawDataFrom(raw);
    };
    Matrix3DUtils.reflection = function (plane, target) {
        if (target === void 0) { target = null; }
        if (target === null)
            target = new Matrix3D();
        var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
        var rawData = Matrix3DUtils.RAW_DATA_CONTAINER;
        var ab2 = -2 * a * b;
        var ac2 = -2 * a * c;
        var bc2 = -2 * b * c;
        // reflection matrix
        rawData[0] = 1 - 2 * a * a;
        rawData[4] = ab2;
        rawData[8] = ac2;
        rawData[12] = -2 * a * d;
        rawData[1] = ab2;
        rawData[5] = 1 - 2 * b * b;
        rawData[9] = bc2;
        rawData[13] = -2 * b * d;
        rawData[2] = ac2;
        rawData[6] = bc2;
        rawData[10] = 1 - 2 * c * c;
        rawData[14] = -2 * c * d;
        rawData[3] = 0;
        rawData[7] = 0;
        rawData[11] = 0;
        rawData[15] = 1;
        target.copyRawDataFrom(rawData);
        return target;
    };
    Matrix3DUtils.transformVector = function (matrix, vector, result) {
        if (result === void 0) { result = null; }
        if (!result)
            result = new Vector3D();
        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        matrix.copyRawDataTo(raw);
        var a = raw[0];
        var e = raw[1];
        var i = raw[2];
        var m = raw[3];
        var b = raw[4];
        var f = raw[5];
        var j = raw[6];
        var n = raw[7];
        var c = raw[8];
        var g = raw[9];
        var k = raw[10];
        var o = raw[11];
        var d = raw[12];
        var h = raw[13];
        var l = raw[14];
        var p = raw[15];
        var x = vector.x;
        var y = vector.y;
        var z = vector.z;
        result.x = a * x + b * y + c * z + d;
        result.y = e * x + f * y + g * z + h;
        result.z = i * x + j * y + k * z + l;
        result.w = m * x + n * y + o * z + p;
        return result;
    };
    Matrix3DUtils.deltaTransformVector = function (matrix, vector, result) {
        if (result === void 0) { result = null; }
        if (!result)
            result = new Vector3D();
        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        matrix.copyRawDataTo(raw);
        var a = raw[0];
        var e = raw[1];
        var i = raw[2];
        var m = raw[3];
        var b = raw[4];
        var f = raw[5];
        var j = raw[6];
        var n = raw[7];
        var c = raw[8];
        var g = raw[9];
        var k = raw[10];
        var o = raw[11];
        var x = vector.x;
        var y = vector.y;
        var z = vector.z;
        result.x = a * x + b * y + c * z;
        result.y = e * x + f * y + g * z;
        result.z = i * x + j * y + k * z;
        result.w = m * x + n * y + o * z;
        return result;
    };
    Matrix3DUtils.getTranslation = function (transform, result) {
        if (result === void 0) { result = null; }
        if (!result)
            result = new Vector3D();
        transform.copyColumnTo(3, result);
        return result;
    };
    Matrix3DUtils.deltaTransformVectors = function (matrix, vin, vout) {
        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
        matrix.copyRawDataTo(raw);
        var a = raw[0];
        var e = raw[1];
        var i = raw[2];
        var m = raw[3];
        var b = raw[4];
        var f = raw[5];
        var j = raw[6];
        var n = raw[7];
        var c = raw[8];
        var g = raw[9];
        var k = raw[10];
        var o = raw[11];
        var outIndex = 0;
        var length = vin.length;
        for (var index = 0; index < length; index += 3) {
            var x = vin[index];
            var y = vin[index + 1];
            var z = vin[index + 2];
            vout[outIndex++] = a * x + b * y + c * z;
            vout[outIndex++] = e * x + f * y + g * z;
            vout[outIndex++] = i * x + j * y + k * z;
        }
    };
    /**
     * A reference to a Vector to be used as a temporary raw data container, to prevent object creation.
     */
    Matrix3DUtils.RAW_DATA_CONTAINER = new Array(16);
    //public static RAW_DATA_CONTAINER:number[] = new Array<number>(16);
    Matrix3DUtils.CALCULATION_MATRIX = new Matrix3D();
    return Matrix3DUtils;
})();
module.exports = Matrix3DUtils;


},{"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Vector3D":120}],115:[function(require,module,exports){
/**
 * A Quaternion object which can be used to represent rotations.
 */
var Orientation3D = (function () {
    function Orientation3D() {
    }
    /**
     * The axis angle orientation uses a combination of an axis and an angle to determine the orientation.
     * @type {string}
     */
    Orientation3D.AXIS_ANGLE = "axisAngle";
    /**
     * The default orientation for decompose() and recompose() methods, defines the orientation with three separate angles of rotation for each axis.
     * @type {string}
     */
    Orientation3D.EULER_ANGLES = "eulerAngles";
    /**
     * The quaternion orientation uses complex numbers.
     * @type {string}
     */
    Orientation3D.QUATERNION = "quaternion";
    return Orientation3D;
})();
module.exports = Orientation3D;


},{}],116:[function(require,module,exports){
var PlaneClassification = require("awayjs-core/lib/geom/PlaneClassification");
var Plane3D = (function () {
    /**
     * Create a Plane3D with ABCD coefficients
     */
    function Plane3D(a, b, c, d) {
        if (a === void 0) { a = 0; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 0; }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        if (a == 0 && b == 0) {
            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
        }
        else if (b == 0 && c == 0) {
            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
        }
        else if (a == 0 && c == 0) {
            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
        }
        else {
            this._iAlignment = Plane3D.ALIGN_ANY;
        }
    }
    /**
     * Fills this Plane3D with the coefficients from 3 points in 3d space.
     * @param p0 Vector3D
     * @param p1 Vector3D
     * @param p2 Vector3D
     */
    Plane3D.prototype.fromPoints = function (p0, p1, p2) {
        var d1x = p1.x - p0.x;
        var d1y = p1.y - p0.y;
        var d1z = p1.z - p0.z;
        var d2x = p2.x - p0.x;
        var d2y = p2.y - p0.y;
        var d2z = p2.z - p0.z;
        this.a = d1y * d2z - d1z * d2y;
        this.b = d1z * d2x - d1x * d2z;
        this.c = d1x * d2y - d1y * d2x;
        this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;
        // not using epsilon, since a plane is infinite and a small incorrection can grow very large
        if (this.a == 0 && this.b == 0) {
            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
        }
        else if (this.b == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
        }
        else if (this.a == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
        }
        else {
            this._iAlignment = Plane3D.ALIGN_ANY;
        }
    };
    /**
     * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
     * @param normal Vector3D
     * @param point  Vector3D
     */
    Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
        this.a = normal.x;
        this.b = normal.y;
        this.c = normal.z;
        this.d = this.a * point.x + this.b * point.y + this.c * point.z;
        if (this.a == 0 && this.b == 0) {
            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
        }
        else if (this.b == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
        }
        else if (this.a == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
        }
        else {
            this._iAlignment = Plane3D.ALIGN_ANY;
        }
    };
    /**
     * Normalize this Plane3D
     * @return Plane3D This Plane3D.
     */
    Plane3D.prototype.normalize = function () {
        var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
        this.a *= len;
        this.b *= len;
        this.c *= len;
        this.d *= len;
        return this;
    };
    /**
     * Returns the signed distance between this Plane3D and the point p.
     * @param p Vector3D
     * @returns Number
     */
    Plane3D.prototype.distance = function (p) {
        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS) {
            return this.a * p.x - this.d;
        }
        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS) {
            return this.b * p.y - this.d;
        }
        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS) {
            return this.c * p.z - this.d;
        }
        else {
            return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
        }
    };
    /**
     * Classify a point against this Plane3D. (in front, back or intersecting)
     * @param p Vector3D
     * @return int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
     */
    Plane3D.prototype.classifyPoint = function (p, epsilon) {
        if (epsilon === void 0) { epsilon = 0.01; }
        // check NaN
        if (this.d != this.d)
            return PlaneClassification.FRONT;
        var len;
        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS)
            len = this.a * p.x - this.d;
        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS)
            len = this.b * p.y - this.d;
        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS)
            len = this.c * p.z - this.d;
        else
            len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;
        if (len < -epsilon)
            return PlaneClassification.BACK;
        else if (len > epsilon)
            return PlaneClassification.FRONT;
        else
            return PlaneClassification.INTERSECT;
    };
    Plane3D.prototype.toString = function () {
        return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
    };
    // indicates the alignment of the plane
    Plane3D.ALIGN_ANY = 0;
    Plane3D.ALIGN_XY_AXIS = 1;
    Plane3D.ALIGN_YZ_AXIS = 2;
    Plane3D.ALIGN_XZ_AXIS = 3;
    return Plane3D;
})();
module.exports = Plane3D;


},{"awayjs-core/lib/geom/PlaneClassification":117}],117:[function(require,module,exports){
var PlaneClassification = (function () {
    function PlaneClassification() {
    }
    // "back" is synonymous with "in", but used for planes (back of plane is "inside" a solid volume walled by a plane)
    PlaneClassification.BACK = 0;
    PlaneClassification.FRONT = 1;
    PlaneClassification.IN = 0;
    PlaneClassification.OUT = 1;
    PlaneClassification.INTERSECT = 2;
    return PlaneClassification;
})();
module.exports = PlaneClassification;


},{}],118:[function(require,module,exports){
module.exports=require(17)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Point.js":17}],119:[function(require,module,exports){
module.exports=require(18)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Rectangle.js":18,"awayjs-core/lib/geom/Point":118}],120:[function(require,module,exports){
module.exports=require(19)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Vector3D.js":19}],121:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],122:[function(require,module,exports){
module.exports=require(31)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/NamedAssetBase.js":31,"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/events/AssetEvent":106,"awayjs-core/lib/events/EventDispatcher":108}],123:[function(require,module,exports){
/**
 * Provides constant values for camera lens projection options use the the <code>coordinateSystem</code> property
 *
 * @see away.projections.PerspectiveLens#coordinateSystem
 */
var CoordinateSystem = (function () {
    function CoordinateSystem() {
    }
    /**
     * Default option, projects to a left-handed coordinate system
     */
    CoordinateSystem.LEFT_HANDED = "leftHanded";
    /**
     * Projects to a right-handed coordinate system
     */
    CoordinateSystem.RIGHT_HANDED = "rightHanded";
    return CoordinateSystem;
})();
module.exports = CoordinateSystem;


},{}],124:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var PerspectiveProjection = require("awayjs-core/lib/projections/PerspectiveProjection");
var ProjectionBase = require("awayjs-core/lib/projections/ProjectionBase");
var FreeMatrixProjection = (function (_super) {
    __extends(FreeMatrixProjection, _super);
    function FreeMatrixProjection() {
        _super.call(this);
        this._pMatrix.copyFrom(new PerspectiveProjection().matrix);
    }
    Object.defineProperty(FreeMatrixProjection.prototype, "near", {
        //@override
        set: function (value) {
            this._pNear = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FreeMatrixProjection.prototype, "far", {
        //@override
        set: function (value) {
            this._pFar = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FreeMatrixProjection.prototype, "iAspectRatio", {
        //@override
        set: function (value) {
            this._pAspectRatio = value;
        },
        enumerable: true,
        configurable: true
    });
    //@override
    FreeMatrixProjection.prototype.clone = function () {
        var clone = new FreeMatrixProjection();
        clone._pMatrix.copyFrom(this._pMatrix);
        clone._pNear = this._pNear;
        clone._pFar = this._pFar;
        clone._pAspectRatio = this._pAspectRatio;
        clone.pInvalidateMatrix();
        return clone;
    };
    //@override
    FreeMatrixProjection.prototype.pUpdateMatrix = function () {
        this._pMatrixInvalid = false;
    };
    return FreeMatrixProjection;
})(ProjectionBase);
module.exports = FreeMatrixProjection;


},{"awayjs-core/lib/projections/PerspectiveProjection":125,"awayjs-core/lib/projections/ProjectionBase":126}],125:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var CoordinateSystem = require("awayjs-core/lib/projections/CoordinateSystem");
var ProjectionBase = require("awayjs-core/lib/projections/ProjectionBase");
var PerspectiveProjection = (function (_super) {
    __extends(PerspectiveProjection, _super);
    function PerspectiveProjection(fieldOfView, coordinateSystem) {
        if (fieldOfView === void 0) { fieldOfView = 60; }
        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
        _super.call(this, coordinateSystem);
        this._fieldOfView = 60;
        this._focalLength = 1000;
        this._hFieldOfView = 60;
        this._hFocalLength = 1000;
        this._preserveAspectRatio = true;
        this._preserveFocalLength = false;
        this.fieldOfView = fieldOfView;
    }
    Object.defineProperty(PerspectiveProjection.prototype, "preserveAspectRatio", {
        /**
         *
         */
        get: function () {
            return this._preserveAspectRatio;
        },
        set: function (value) {
            if (this._preserveAspectRatio == value)
                return;
            this._preserveAspectRatio = value;
            if (this._preserveAspectRatio)
                this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "preserveFocalLength", {
        /**
         *
         */
        get: function () {
            return this._preserveFocalLength;
        },
        set: function (value) {
            if (this._preserveFocalLength == value)
                return;
            this._preserveFocalLength = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "fieldOfView", {
        /**
         *
         */
        get: function () {
            return this._fieldOfView;
        },
        set: function (value) {
            if (this._fieldOfView == value)
                return;
            this._fieldOfView = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "focalLength", {
        /**
         *
         */
        get: function () {
            return this._focalLength;
        },
        set: function (value) {
            if (this._focalLength == value)
                return;
            this._focalLength = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "hFieldOfView", {
        /**
         *
         */
        get: function () {
            return this._hFieldOfView;
        },
        set: function (value) {
            if (this._hFieldOfView == value)
                return;
            this._hFieldOfView = value;
            this._hFocalLength = 1 / Math.tan(this._hFieldOfView * Math.PI / 360);
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "hFocalLength", {
        /**
         *
         */
        get: function () {
            return this._hFocalLength;
        },
        set: function (value) {
            if (this._hFocalLength == value)
                return;
            this._hFocalLength = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    //@override
    PerspectiveProjection.prototype.unproject = function (nX, nY, sZ) {
        var v = new Vector3D(nX, -nY, sZ, 1.0);
        v.x *= sZ;
        v.y *= sZ;
        v = this.unprojectionMatrix.transformVector(v);
        //z is unaffected by transform
        v.z = sZ;
        return v;
    };
    //@override
    PerspectiveProjection.prototype.clone = function () {
        var clone = new PerspectiveProjection(this._fieldOfView);
        clone._pNear = this._pNear;
        clone._pFar = this._pFar;
        clone._pAspectRatio = this._pAspectRatio;
        clone._pCoordinateSystem = this._pCoordinateSystem;
        return clone;
    };
    //@override
    PerspectiveProjection.prototype.pUpdateMatrix = function () {
        var raw = [];
        if (this._preserveFocalLength) {
            if (this._preserveAspectRatio)
                this._hFocalLength = this._focalLength;
            this._fieldOfView = Math.atan(0.5 * this._pScissorRect.height / this._focalLength) * 360 / Math.PI;
            this._hFieldOfView = Math.atan(0.5 * this._pScissorRect.width / this._hFocalLength) * 360 / Math.PI;
        }
        else {
            this._focalLength = 0.5 * this._pScissorRect.height / Math.tan(this._fieldOfView * Math.PI / 360);
            if (this._preserveAspectRatio)
                this._hFocalLength = this._focalLength;
            else
                this._hFocalLength = 0.5 * this._pScissorRect.width / Math.tan(this._hFieldOfView * Math.PI / 360);
        }
        var tanMinX = -this._pOriginX / this._hFocalLength;
        var tanMaxX = (1 - this._pOriginX) / this._hFocalLength;
        var tanMinY = -this._pOriginY / this._focalLength;
        var tanMaxY = (1 - this._pOriginY) / this._focalLength;
        var left;
        var right;
        var top;
        var bottom;
        // assume scissored frustum
        var center = -((tanMinX - tanMaxX) * this._pScissorRect.x + tanMinX * this._pScissorRect.width);
        var middle = ((tanMinY - tanMaxY) * this._pScissorRect.y + tanMinY * this._pScissorRect.height);
        left = center - (tanMaxX - tanMinX) * this._pViewPort.width;
        right = center;
        top = middle;
        bottom = middle + (tanMaxY - tanMinY) * this._pViewPort.height;
        raw[0] = 2 / (right - left);
        raw[5] = 2 / (bottom - top);
        raw[8] = (right + left) / (right - left);
        raw[9] = (bottom + top) / (bottom - top);
        raw[10] = (this._pFar + this._pNear) / (this._pFar - this._pNear);
        raw[11] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
        raw[14] = -2 * this._pFar * this._pNear / (this._pFar - this._pNear);
        if (this._pCoordinateSystem == CoordinateSystem.RIGHT_HANDED)
            raw[5] = -raw[5];
        this._pMatrix.copyRawDataFrom(raw);
        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pNear * left;
        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pNear * right;
        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pNear * top;
        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pNear * bottom;
        this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._pFar * left;
        this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._pFar * right;
        this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._pFar * top;
        this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._pFar * bottom;
        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
        this._pMatrixInvalid = false;
    };
    return PerspectiveProjection;
})(ProjectionBase);
module.exports = PerspectiveProjection;


},{"awayjs-core/lib/geom/Vector3D":120,"awayjs-core/lib/projections/CoordinateSystem":123,"awayjs-core/lib/projections/ProjectionBase":126}],126:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var ProjectionEvent = require("awayjs-core/lib/events/ProjectionEvent");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var ProjectionBase = (function (_super) {
    __extends(ProjectionBase, _super);
    function ProjectionBase(coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
        _super.call(this);
        this._pMatrix = new Matrix3D();
        this._pScissorRect = new Rectangle();
        this._pViewPort = new Rectangle();
        this._pNear = 20;
        this._pFar = 3000;
        this._pAspectRatio = 1;
        this._pMatrixInvalid = true;
        this._pFrustumCorners = [];
        this._pOriginX = 0.5;
        this._pOriginY = 0.5;
        this._unprojectionInvalid = true;
        this.coordinateSystem = coordinateSystem;
    }
    Object.defineProperty(ProjectionBase.prototype, "coordinateSystem", {
        /**
         * The handedness of the coordinate system projection. The default is LEFT_HANDED.
         */
        get: function () {
            return this._pCoordinateSystem;
        },
        set: function (value) {
            if (this._pCoordinateSystem == value)
                return;
            this._pCoordinateSystem = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "frustumCorners", {
        get: function () {
            return this._pFrustumCorners;
        },
        set: function (frustumCorners) {
            this._pFrustumCorners = frustumCorners;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "matrix", {
        get: function () {
            if (this._pMatrixInvalid) {
                this.pUpdateMatrix();
                this._pMatrixInvalid = false;
            }
            return this._pMatrix;
        },
        set: function (value) {
            this._pMatrix = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "near", {
        get: function () {
            return this._pNear;
        },
        set: function (value) {
            if (value == this._pNear) {
                return;
            }
            this._pNear = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "originX", {
        get: function () {
            return this._pOriginX;
        },
        set: function (value) {
            if (this._pOriginX == value)
                return;
            this._pOriginX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "originY", {
        get: function () {
            return this._pOriginY;
        },
        set: function (value) {
            if (this._pOriginY == value)
                return;
            this._pOriginY = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "far", {
        get: function () {
            return this._pFar;
        },
        set: function (value) {
            if (value == this._pFar) {
                return;
            }
            this._pFar = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    ProjectionBase.prototype.project = function (point3d) {
        var v = this.matrix.transformVector(point3d);
        v.x = v.x / v.w;
        v.y = -v.y / v.w;
        //z is unaffected by transform
        v.z = point3d.z;
        return v;
    };
    Object.defineProperty(ProjectionBase.prototype, "unprojectionMatrix", {
        get: function () {
            if (this._unprojectionInvalid) {
                if (!this._unprojection)
                    this._unprojection = new Matrix3D();
                this._unprojection.copyFrom(this.matrix);
                this._unprojection.invert();
                this._unprojectionInvalid = false;
            }
            return this._unprojection;
        },
        enumerable: true,
        configurable: true
    });
    ProjectionBase.prototype.unproject = function (nX, nY, sZ) {
        throw new AbstractMethodError();
    };
    ProjectionBase.prototype.clone = function () {
        throw new AbstractMethodError();
    };
    Object.defineProperty(ProjectionBase.prototype, "_iAspectRatio", {
        get: function () {
            return this._pAspectRatio;
        },
        set: function (value) {
            if (this._pAspectRatio == value)
                return;
            this._pAspectRatio = value;
            this.pInvalidateMatrix();
        },
        enumerable: true,
        configurable: true
    });
    ProjectionBase.prototype.pInvalidateMatrix = function () {
        this._pMatrixInvalid = true;
        this._unprojectionInvalid = true;
        this.dispatchEvent(new ProjectionEvent(ProjectionEvent.MATRIX_CHANGED, this));
    };
    ProjectionBase.prototype.pUpdateMatrix = function () {
        throw new AbstractMethodError();
    };
    ProjectionBase.prototype._iUpdateScissorRect = function (x, y, width, height) {
        this._pScissorRect.x = x;
        this._pScissorRect.y = y;
        this._pScissorRect.width = width;
        this._pScissorRect.height = height;
        this.pInvalidateMatrix();
    };
    ProjectionBase.prototype._iUpdateViewport = function (x, y, width, height) {
        this._pViewPort.x = x;
        this._pViewPort.y = y;
        this._pViewPort.width = width;
        this._pViewPort.height = height;
        this.pInvalidateMatrix();
    };
    return ProjectionBase;
})(EventDispatcher);
module.exports = ProjectionBase;


},{"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/events/EventDispatcher":108,"awayjs-core/lib/events/ProjectionEvent":109,"awayjs-core/lib/geom/Matrix3D":113,"awayjs-core/lib/geom/Rectangle":119}],127:[function(require,module,exports){
module.exports=require(46)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/MipmapGenerator.js":46,"awayjs-core/lib/base/BitmapData":96,"awayjs-core/lib/geom/Matrix":112,"awayjs-core/lib/geom/Rectangle":119}],128:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
var Texture2DBase = require("awayjs-core/lib/textures/Texture2DBase");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var RenderTexture = (function (_super) {
    __extends(RenderTexture, _super);
    function RenderTexture(width, height) {
        _super.call(this, false);
        this._pSetSize(width, height);
    }
    Object.defineProperty(RenderTexture.prototype, "width", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._pWidth;
        },
        set: function (value) {
            if (value == this._pWidth)
                return;
            if (!TextureUtils.isDimensionValid(value))
                throw new Error("Invalid size: Width and height must be power of 2 and cannot exceed 2048");
            this.invalidateContent();
            this._pSetSize(value, this._pHeight);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "height", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._pHeight;
        },
        set: function (value) {
            if (value == this._pHeight)
                return;
            if (!TextureUtils.isDimensionValid(value))
                throw new Error("Invalid size: Width and height must be power of 2 and cannot exceed 2048");
            this.invalidateContent();
            this._pSetSize(this._pWidth, value);
        },
        enumerable: true,
        configurable: true
    });
    return RenderTexture;
})(Texture2DBase);
module.exports = RenderTexture;


},{"awayjs-core/lib/errors/Error":103,"awayjs-core/lib/textures/Texture2DBase":129,"awayjs-core/lib/utils/TextureUtils":132}],129:[function(require,module,exports){
module.exports=require(47)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/Texture2DBase.js":47,"awayjs-core/lib/errors/AbstractMethodError":101,"awayjs-core/lib/textures/MipmapGenerator":127,"awayjs-core/lib/textures/TextureProxyBase":130}],130:[function(require,module,exports){
module.exports=require(48)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/TextureProxyBase.js":48,"awayjs-core/lib/library/AssetType":121,"awayjs-core/lib/library/NamedAssetBase":122}],131:[function(require,module,exports){
module.exports=require(51)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ColorUtils.js":51}],132:[function(require,module,exports){
module.exports=require(54)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/TextureUtils.js":54}],133:[function(require,module,exports){
module.exports=require(56)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/getTimer.js":56}],134:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var URLLoaderDataFormat = require("awayjs-core/lib/net/URLLoaderDataFormat");
var URLRequest = require("awayjs-core/lib/net/URLRequest");
var ParserBase = require("awayjs-core/lib/parsers/ParserBase");
var ParserUtils = require("awayjs-core/lib/parsers/ParserUtils");
var DisplayObjectContainer = require("awayjs-display/lib/containers/DisplayObjectContainer");
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var Geometry = require("awayjs-display/lib/base/Geometry");
var Mesh = require("awayjs-display/lib/entities/Mesh");
var DefaultMaterialManager = require("awayjs-stagegl/lib/materials/utils/DefaultMaterialManager");
var SpecularBasicMethod = require("awayjs-stagegl/lib/materials/methods/SpecularBasicMethod");
var TriangleMethodMaterial = require("awayjs-stagegl/lib/materials/TriangleMethodMaterial");
var TriangleMaterialMode = require("awayjs-stagegl/lib/materials/TriangleMaterialMode");
/**
 * OBJParser provides a parser for the OBJ data type.
 */
var OBJParser = (function (_super) {
    __extends(OBJParser, _super);
    /**
     * Creates a new OBJParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function OBJParser(scale) {
        if (scale === void 0) { scale = 1; }
        _super.call(this, URLLoaderDataFormat.TEXT);
        this._mtlLibLoaded = true;
        this._activeMaterialID = "";
        this._scale = scale;
    }
    Object.defineProperty(OBJParser.prototype, "scale", {
        /**
         * Scaling factor applied directly to vertices data
         * @param value The scaling factor.
         */
        set: function (value) {
            this._scale = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    OBJParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "obj";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    OBJParser.supportsData = function (data) {
        var content = ParserUtils.toString(data);
        var hasV = false;
        var hasF = false;
        if (content) {
            hasV = content.indexOf("\nv ") != -1;
            hasF = content.indexOf("\nf ") != -1;
        }
        return hasV && hasF;
    };
    /**
     * @inheritDoc
     */
    OBJParser.prototype._iResolveDependency = function (resourceDependency) {
        if (resourceDependency.id == 'mtl') {
            var str = ParserUtils.toString(resourceDependency.data);
            this.parseMtl(str);
        }
        else {
            var asset;
            if (resourceDependency.assets.length != 1) {
                return;
            }
            asset = resourceDependency.assets[0];
            if (asset.assetType == AssetType.TEXTURE) {
                var lm = new LoadedMaterial();
                lm.materialID = resourceDependency.id;
                lm.texture = asset;
                this._materialLoaded.push(lm);
                if (this._meshes.length > 0) {
                    this.applyMaterial(lm);
                }
            }
        }
    };
    /**
     * @inheritDoc
     */
    OBJParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        if (resourceDependency.id == "mtl") {
            this._mtlLib = false;
            this._mtlLibLoaded = false;
        }
        else {
            var lm = new LoadedMaterial();
            lm.materialID = resourceDependency.id;
            this._materialLoaded.push(lm);
        }
        if (this._meshes.length > 0)
            this.applyMaterial(lm);
    };
    /**
     * @inheritDoc
     */
    OBJParser.prototype._pProceedParsing = function () {
        var line;
        var creturn = String.fromCharCode(10);
        var trunk;
        if (!this._startedParsing) {
            this._textData = this._pGetTextData();
            // Merge linebreaks that are immediately preceeded by
            // the "escape" backward slash into single lines.
            this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
        }
        if (this._textData.indexOf(creturn) == -1)
            creturn = String.fromCharCode(13);
        if (!this._startedParsing) {
            this._startedParsing = true;
            this._vertices = new Array();
            this._vertexNormals = new Array();
            this._materialIDs = new Array();
            this._materialLoaded = new Array();
            this._meshes = new Array();
            this._uvs = new Array();
            this._stringLength = this._textData.length;
            this._charIndex = this._textData.indexOf(creturn, 0);
            this._oldIndex = 0;
            this._objects = new Array();
            this._objectIndex = 0;
        }
        while (this._charIndex < this._stringLength && this._pHasTime()) {
            this._charIndex = this._textData.indexOf(creturn, this._oldIndex);
            if (this._charIndex == -1)
                this._charIndex = this._stringLength;
            line = this._textData.substring(this._oldIndex, this._charIndex);
            line = line.split('\r').join("");
            line = line.replace("  ", " ");
            trunk = line.split(" ");
            this._oldIndex = this._charIndex + 1;
            this.parseLine(trunk);
            // If whatever was parsed on this line resulted in the
            // parsing being paused to retrieve dependencies, break
            // here and do not continue parsing until un-paused.
            if (this.parsingPaused) {
                return ParserBase.MORE_TO_PARSE;
            }
        }
        if (this._charIndex >= this._stringLength) {
            if (this._mtlLib && !this._mtlLibLoaded) {
                return ParserBase.MORE_TO_PARSE;
            }
            this.translate();
            this.applyMaterials();
            return ParserBase.PARSING_DONE;
        }
        return ParserBase.MORE_TO_PARSE;
    };
    OBJParser.prototype._pStartParsing = function (frameLimit) {
        _super.prototype._pStartParsing.call(this, frameLimit);
        //create a content object for Loaders
        this._pContent = new DisplayObjectContainer();
    };
    /**
     * Parses a single line in the OBJ file.
     */
    OBJParser.prototype.parseLine = function (trunk) {
        switch (trunk[0]) {
            case "mtllib":
                this._mtlLib = true;
                this._mtlLibLoaded = false;
                this.loadMtl(trunk[1]);
                break;
            case "g":
                this.createGroup(trunk);
                break;
            case "o":
                this.createObject(trunk);
                break;
            case "usemtl":
                if (this._mtlLib) {
                    if (!trunk[1])
                        trunk[1] = "def000";
                    this._materialIDs.push(trunk[1]);
                    this._activeMaterialID = trunk[1];
                    if (this._currentGroup)
                        this._currentGroup.materialID = this._activeMaterialID;
                }
                break;
            case "v":
                this.parseVertex(trunk);
                break;
            case "vt":
                this.parseUV(trunk);
                break;
            case "vn":
                this.parseVertexNormal(trunk);
                break;
            case "f":
                this.parseFace(trunk);
        }
    };
    /**
     * Converts the parsed data into an Away3D scenegraph structure
     */
    OBJParser.prototype.translate = function () {
        for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
            var groups = this._objects[objIndex].groups;
            var numGroups = groups.length;
            var materialGroups;
            var numMaterialGroups;
            var geometry;
            var mesh;
            var m;
            var sm;
            var bmMaterial;
            for (var g = 0; g < numGroups; ++g) {
                geometry = new Geometry();
                materialGroups = groups[g].materialGroups;
                numMaterialGroups = materialGroups.length;
                for (m = 0; m < numMaterialGroups; ++m)
                    this.translateMaterialGroup(materialGroups[m], geometry);
                if (geometry.subGeometries.length == 0)
                    continue;
                // Finalize and force type-based name
                this._pFinalizeAsset(geometry); //, "");
                bmMaterial = new TriangleMethodMaterial(DefaultMaterialManager.getDefaultTexture());
                //check for multipass
                if (this.materialMode >= 2)
                    bmMaterial.materialMode = TriangleMaterialMode.MULTI_PASS;
                mesh = new Mesh(geometry, bmMaterial);
                if (this._objects[objIndex].name) {
                    // this is a full independent object ('o' tag in OBJ file)
                    mesh.name = this._objects[objIndex].name;
                }
                else if (groups[g].name) {
                    // this is a group so the sub groups contain the actual mesh object names ('g' tag in OBJ file)
                    mesh.name = groups[g].name;
                }
                else {
                    // No name stored. Use empty string which will force it
                    // to be overridden by finalizeAsset() to type default.
                    mesh.name = "";
                }
                this._meshes.push(mesh);
                if (groups[g].materialID != "")
                    bmMaterial.name = groups[g].materialID + "~" + mesh.name;
                else
                    bmMaterial.name = this._lastMtlID + "~" + mesh.name;
                if (mesh.subMeshes.length > 1) {
                    for (sm = 1; sm < mesh.subMeshes.length; ++sm)
                        mesh.subMeshes[sm].material = bmMaterial;
                }
                //add to the content property
                this._pContent.addChild(mesh);
                this._pFinalizeAsset(mesh);
            }
        }
    };
    /**
     * Translates an obj's material group to a subgeometry.
     * @param materialGroup The material group data to convert.
     * @param geometry The Geometry to contain the converted SubGeometry.
     */
    OBJParser.prototype.translateMaterialGroup = function (materialGroup, geometry) {
        var faces = materialGroup.faces;
        var face;
        var numFaces = faces.length;
        var numVerts;
        var sub;
        var vertices = new Array();
        var uvs = new Array();
        var normals = new Array();
        var indices = new Array();
        this._realIndices = [];
        this._vertexIndex = 0;
        var j;
        for (var i = 0; i < numFaces; ++i) {
            face = faces[i];
            numVerts = face.indexIds.length - 1;
            for (j = 1; j < numVerts; ++j) {
                this.translateVertexData(face, j, vertices, uvs, indices, normals);
                this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
            }
        }
        if (vertices.length > 0) {
            sub = new TriangleSubGeometry(true);
            sub.autoDeriveNormals = normals.length ? false : true;
            sub.updateIndices(indices);
            sub.updatePositions(vertices);
            sub.updateVertexNormals(normals);
            sub.updateUVs(uvs);
            geometry.addSubGeometry(sub);
        }
    };
    OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices /*uint*/, normals) {
        var index;
        var vertex;
        var vertexNormal;
        var uv;
        if (!this._realIndices[face.indexIds[vertexIndex]]) {
            index = this._vertexIndex;
            this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
            vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
            vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);
            if (face.normalIndices.length > 0) {
                vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
            }
            if (face.uvIndices.length > 0) {
                try {
                    uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                    uvs.push(uv.u, uv.v);
                }
                catch (e) {
                    switch (vertexIndex) {
                        case 0:
                            uvs.push(0, 1);
                            break;
                        case 1:
                            uvs.push(.5, 0);
                            break;
                        case 2:
                            uvs.push(1, 1);
                    }
                }
            }
        }
        else {
            index = this._realIndices[face.indexIds[vertexIndex]] - 1;
        }
        indices.push(index);
    };
    /**
     * Creates a new object group.
     * @param trunk The data block containing the object tag and its parameters
     */
    OBJParser.prototype.createObject = function (trunk) {
        this._currentGroup = null;
        this._currentMaterialGroup = null;
        this._objects.push(this._currentObject = new ObjectGroup());
        if (trunk)
            this._currentObject.name = trunk[1];
    };
    /**
     * Creates a new group.
     * @param trunk The data block containing the group tag and its parameters
     */
    OBJParser.prototype.createGroup = function (trunk) {
        if (!this._currentObject)
            this.createObject(null);
        this._currentGroup = new Group();
        this._currentGroup.materialID = this._activeMaterialID;
        if (trunk)
            this._currentGroup.name = trunk[1];
        this._currentObject.groups.push(this._currentGroup);
        this.createMaterialGroup(null);
    };
    /**
     * Creates a new material group.
     * @param trunk The data block containing the material tag and its parameters
     */
    OBJParser.prototype.createMaterialGroup = function (trunk) {
        this._currentMaterialGroup = new MaterialGroup();
        if (trunk)
            this._currentMaterialGroup.url = trunk[1];
        this._currentGroup.materialGroups.push(this._currentMaterialGroup);
    };
    /**
     * Reads the next vertex coordinates.
     * @param trunk The data block containing the vertex tag and its parameters
     */
    OBJParser.prototype.parseVertex = function (trunk) {
        //for the very rare cases of other delimiters/charcodes seen in some obj files
        var v1, v2, v3;
        if (trunk.length > 4) {
            var nTrunk = [];
            var val;
            for (var i = 1; i < trunk.length; ++i) {
                val = parseFloat(trunk[i]);
                if (!isNaN(val))
                    nTrunk.push(val);
            }
            v1 = nTrunk[0];
            v2 = nTrunk[1];
            v3 = -nTrunk[2];
            this._vertices.push(new Vertex(v1, v2, v3));
        }
        else {
            v1 = parseFloat(trunk[1]);
            v2 = parseFloat(trunk[2]);
            v3 = -parseFloat(trunk[3]);
            this._vertices.push(new Vertex(v1, v2, v3));
        }
    };
    /**
     * Reads the next uv coordinates.
     * @param trunk The data block containing the uv tag and its parameters
     */
    OBJParser.prototype.parseUV = function (trunk) {
        if (trunk.length > 3) {
            var nTrunk = [];
            var val;
            for (var i = 1; i < trunk.length; ++i) {
                val = parseFloat(trunk[i]);
                if (!isNaN(val))
                    nTrunk.push(val);
            }
            this._uvs.push(new UV(nTrunk[0], 1 - nTrunk[1]));
        }
        else {
            this._uvs.push(new UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
        }
    };
    /**
     * Reads the next vertex normal coordinates.
     * @param trunk The data block containing the vertex normal tag and its parameters
     */
    OBJParser.prototype.parseVertexNormal = function (trunk) {
        if (trunk.length > 4) {
            var nTrunk = [];
            var val;
            for (var i = 1; i < trunk.length; ++i) {
                val = parseFloat(trunk[i]);
                if (!isNaN(val))
                    nTrunk.push(val);
            }
            this._vertexNormals.push(new Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
        }
        else {
            this._vertexNormals.push(new Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
        }
    };
    /**
     * Reads the next face's indices.
     * @param trunk The data block containing the face tag and its parameters
     */
    OBJParser.prototype.parseFace = function (trunk) {
        var len = trunk.length;
        var face = new FaceData();
        if (!this._currentGroup) {
            this.createGroup(null);
        }
        var indices;
        for (var i = 1; i < len; ++i) {
            if (trunk[i] == "") {
                continue;
            }
            indices = trunk[i].split("/");
            face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));
            if (indices[1] && String(indices[1]).length > 0)
                face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));
            if (indices[2] && String(indices[2]).length > 0)
                face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));
            face.indexIds.push(trunk[i]);
        }
        this._currentMaterialGroup.faces.push(face);
    };
    /**
     * This is a hack around negative face coords
     */
    OBJParser.prototype.parseIndex = function (index, length) {
        if (index < 0)
            return index + length + 1;
        else
            return index;
    };
    OBJParser.prototype.parseMtl = function (data) {
        var materialDefinitions = data.split('newmtl');
        var lines;
        var trunk;
        var j;
        var basicSpecularMethod;
        var useSpecular;
        var useColor;
        var diffuseColor;
        var color;
        var specularColor;
        var specular;
        var alpha;
        var mapkd;
        for (var i = 0; i < materialDefinitions.length; ++i) {
            lines = (materialDefinitions[i].split('\r')).join("").split('\n');
            //lines = (materialDefinitions[i].split('\r') as Array).join("").split('\n');
            if (lines.length == 1)
                lines = materialDefinitions[i].split(String.fromCharCode(13));
            diffuseColor = color = specularColor = 0xFFFFFF;
            specular = 0;
            useSpecular = false;
            useColor = false;
            alpha = 1;
            mapkd = "";
            for (j = 0; j < lines.length; ++j) {
                lines[j] = lines[j].replace(/\s+$/, "");
                if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                    trunk = lines[j].split(" ");
                    if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
                        trunk[0] = trunk[0].substring(1, trunk[0].length);
                    if (j == 0) {
                        this._lastMtlID = trunk.join("");
                        this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                    }
                    else {
                        switch (trunk[0]) {
                            case "Ka":
                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
                                    color = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                break;
                            case "Ks":
                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                    specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                    useSpecular = true;
                                }
                                break;
                            case "Ns":
                                if (trunk[1] && !isNaN(Number(trunk[1])))
                                    specular = Number(trunk[1]) * 0.001;
                                if (specular == 0)
                                    useSpecular = false;
                                break;
                            case "Kd":
                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                    diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                    useColor = true;
                                }
                                break;
                            case "tr":
                            case "d":
                                if (trunk[1] && !isNaN(Number(trunk[1])))
                                    alpha = Number(trunk[1]);
                                break;
                            case "map_Kd":
                                mapkd = this.parseMapKdString(trunk);
                                mapkd = mapkd.replace(/\\/g, "/");
                        }
                    }
                }
            }
            if (mapkd != "") {
                if (useSpecular) {
                    basicSpecularMethod = new SpecularBasicMethod();
                    basicSpecularMethod.specularColor = specularColor;
                    basicSpecularMethod.specular = specular;
                    var specularData = new SpecularData();
                    specularData.alpha = alpha;
                    specularData.basicSpecularMethod = basicSpecularMethod;
                    specularData.materialID = this._lastMtlID;
                    if (!this._materialSpecularData)
                        this._materialSpecularData = new Array();
                    this._materialSpecularData.push(specularData);
                }
                this._pAddDependency(this._lastMtlID, new URLRequest(mapkd));
            }
            else if (useColor && !isNaN(color)) {
                var lm = new LoadedMaterial();
                lm.materialID = this._lastMtlID;
                if (alpha == 0)
                    console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", mesh(es) using it will be invisible!");
                var cm;
                if (this.materialMode < 2) {
                    cm = new TriangleMethodMaterial(color);
                    var colorMat = cm;
                    colorMat.alpha = alpha;
                    colorMat.diffuseColor = diffuseColor;
                    colorMat.repeat = true;
                    if (useSpecular) {
                        colorMat.specularColor = specularColor;
                        colorMat.specular = specular;
                    }
                }
                else {
                    cm = new TriangleMethodMaterial(color);
                    cm.materialMode = TriangleMaterialMode.MULTI_PASS;
                    var colorMultiMat = cm;
                    colorMultiMat.diffuseColor = diffuseColor;
                    colorMultiMat.repeat = true;
                    if (useSpecular) {
                        colorMultiMat.specularColor = specularColor;
                        colorMultiMat.specular = specular;
                    }
                }
                lm.cm = cm;
                this._materialLoaded.push(lm);
                if (this._meshes.length > 0)
                    this.applyMaterial(lm);
            }
        }
        this._mtlLibLoaded = true;
    };
    OBJParser.prototype.parseMapKdString = function (trunk) {
        var url = "";
        var i;
        var breakflag;
        for (i = 1; i < trunk.length;) {
            switch (trunk[i]) {
                case "-blendu":
                case "-blendv":
                case "-cc":
                case "-clamp":
                case "-texres":
                    i += 2; //Skip ahead 1 attribute
                    break;
                case "-mm":
                    i += 3; //Skip ahead 2 attributes
                    break;
                case "-o":
                case "-s":
                case "-t":
                    i += 4; //Skip ahead 3 attributes
                    continue;
                default:
                    breakflag = true;
                    break;
            }
            if (breakflag)
                break;
        }
        for (i; i < trunk.length; i++) {
            url += trunk[i];
            url += " ";
        }
        //Remove the extraneous space and/or newline from the right side
        url = url.replace(/\s+$/, "");
        return url;
    };
    OBJParser.prototype.loadMtl = function (mtlurl) {
        // Add raw-data dependency to queue and load dependencies now,
        // which will pause the parsing in the meantime.
        this._pAddDependency('mtl', new URLRequest(mtlurl), true);
        this._pPauseAndRetrieveDependencies(); //
    };
    OBJParser.prototype.applyMaterial = function (lm) {
        var decomposeID;
        var mesh;
        var tm;
        var j;
        var specularData;
        for (var i = 0; i < this._meshes.length; ++i) {
            mesh = this._meshes[i];
            decomposeID = mesh.material.name.split("~");
            if (decomposeID[0] == lm.materialID) {
                if (lm.cm) {
                    if (mesh.material)
                        mesh.material = null;
                    mesh.material = lm.cm;
                }
                else if (lm.texture) {
                    if (this.materialMode < 2) {
                        tm = mesh.material;
                        tm.texture = lm.texture;
                        tm.color = lm.color;
                        tm.alpha = lm.alpha;
                        tm.repeat = true;
                        if (lm.specularMethod) {
                            // By setting the specularMethod property to null before assigning
                            // the actual method instance, we avoid having the properties of
                            // the new method being overridden with the settings from the old
                            // one, which is default behavior of the setter.
                            tm.specularMethod = null;
                            tm.specularMethod = lm.specularMethod;
                        }
                        else if (this._materialSpecularData) {
                            for (j = 0; j < this._materialSpecularData.length; ++j) {
                                specularData = this._materialSpecularData[j];
                                if (specularData.materialID == lm.materialID) {
                                    tm.specularMethod = null; // Prevent property overwrite (see above)
                                    tm.specularMethod = specularData.basicSpecularMethod;
                                    tm.color = specularData.color;
                                    tm.alpha = specularData.alpha;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        tm = mesh.material;
                        tm.materialMode = TriangleMaterialMode.MULTI_PASS;
                        tm.texture = lm.texture;
                        tm.color = lm.color;
                        tm.repeat = true;
                        if (lm.specularMethod) {
                            // By setting the specularMethod property to null before assigning
                            // the actual method instance, we avoid having the properties of
                            // the new method being overridden with the settings from the old
                            // one, which is default behavior of the setter.
                            tm.specularMethod = null;
                            tm.specularMethod = lm.specularMethod;
                        }
                        else if (this._materialSpecularData) {
                            for (j = 0; j < this._materialSpecularData.length; ++j) {
                                specularData = this._materialSpecularData[j];
                                if (specularData.materialID == lm.materialID) {
                                    tm.specularMethod = null; // Prevent property overwrite (see above)
                                    tm.specularMethod = specularData.basicSpecularMethod;
                                    tm.color = specularData.color;
                                    break;
                                }
                            }
                        }
                    }
                }
                mesh.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                this._meshes.splice(i, 1);
                --i;
            }
        }
        if (lm.cm || tm)
            this._pFinalizeAsset(lm.cm || tm);
    };
    OBJParser.prototype.applyMaterials = function () {
        if (this._materialLoaded.length == 0)
            return;
        for (var i = 0; i < this._materialLoaded.length; ++i)
            this.applyMaterial(this._materialLoaded[i]);
    };
    return OBJParser;
})(ParserBase);
var ObjectGroup = (function () {
    function ObjectGroup() {
        this.groups = new Array();
    }
    return ObjectGroup;
})();
var Group = (function () {
    function Group() {
        this.materialGroups = new Array();
    }
    return Group;
})();
var MaterialGroup = (function () {
    function MaterialGroup() {
        this.faces = new Array();
    }
    return MaterialGroup;
})();
var SpecularData = (function () {
    function SpecularData() {
        this.color = 0xFFFFFF;
        this.alpha = 1;
    }
    return SpecularData;
})();
var LoadedMaterial = (function () {
    function LoadedMaterial() {
        this.color = 0xFFFFFF;
        this.alpha = 1;
    }
    return LoadedMaterial;
})();
var FaceData = (function () {
    function FaceData() {
        this.vertexIndices = new Array();
        this.uvIndices = new Array();
        this.normalIndices = new Array();
        this.indexIds = new Array(); // used for real index lookups
    }
    return FaceData;
})();
/**
* Texture coordinates value object.
*/
var UV = (function () {
    /**
     * Creates a new <code>UV</code> object.
     *
     * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
     * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
     */
    function UV(u, v) {
        if (u === void 0) { u = 0; }
        if (v === void 0) { v = 0; }
        this._u = u;
        this._v = v;
    }
    Object.defineProperty(UV.prototype, "v", {
        /**
         * Defines the vertical coordinate of the texture value.
         */
        get: function () {
            return this._v;
        },
        set: function (value) {
            this._v = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UV.prototype, "u", {
        /**
         * Defines the horizontal coordinate of the texture value.
         */
        get: function () {
            return this._u;
        },
        set: function (value) {
            this._u = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new UV value Object
     */
    UV.prototype.clone = function () {
        return new UV(this._u, this._v);
    };
    /**
     * returns the value object as a string for trace/debug purpose
     */
    UV.prototype.toString = function () {
        return this._u + "," + this._v;
    };
    return UV;
})();
var Vertex = (function () {
    /**
     * Creates a new <code>Vertex</code> value object.
     *
     * @param    x            [optional]    The x value. Defaults to 0.
     * @param    y            [optional]    The y value. Defaults to 0.
     * @param    z            [optional]    The z value. Defaults to 0.
     * @param    index        [optional]    The index value. Defaults is NaN.
     */
    function Vertex(x, y, z, index) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (index === void 0) { index = 0; }
        this._x = x;
        this._y = y;
        this._z = z;
        this._index = index;
    }
    Object.defineProperty(Vertex.prototype, "index", {
        get: function () {
            return this._index;
        },
        /**
         * To define/store the index of value object
         * @param    ind        The index
         */
        set: function (ind) {
            this._index = ind;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "x", {
        /**
         * To define/store the x value of the value object
         * @param    value        The x value
         */
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "y", {
        /**
         * To define/store the y value of the value object
         * @param    value        The y value
         */
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "z", {
        /**
         * To define/store the z value of the value object
         * @param    value        The z value
         */
        get: function () {
            return this._z;
        },
        set: function (value) {
            this._z = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new Vertex value Object
     */
    Vertex.prototype.clone = function () {
        return new Vertex(this._x, this._y, this._z);
    };
    return Vertex;
})();
module.exports = OBJParser;


},{"awayjs-core/lib/library/AssetType":142,"awayjs-core/lib/net/URLLoaderDataFormat":143,"awayjs-core/lib/net/URLRequest":144,"awayjs-core/lib/parsers/ParserBase":146,"awayjs-core/lib/parsers/ParserUtils":147,"awayjs-display/lib/base/Geometry":156,"awayjs-display/lib/base/TriangleSubGeometry":161,"awayjs-display/lib/containers/DisplayObjectContainer":163,"awayjs-display/lib/entities/Mesh":164,"awayjs-stagegl/lib/materials/TriangleMaterialMode":206,"awayjs-stagegl/lib/materials/TriangleMethodMaterial":207,"awayjs-stagegl/lib/materials/methods/SpecularBasicMethod":224,"awayjs-stagegl/lib/materials/utils/DefaultMaterialManager":230}],135:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":136}],136:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],137:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":138}],138:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],139:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],140:[function(require,module,exports){
module.exports=require(13)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/ParserEvent.js":13,"awayjs-core/lib/events/Event":138}],141:[function(require,module,exports){
module.exports=require(15)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/TimerEvent.js":15,"awayjs-core/lib/events/Event":138}],142:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],143:[function(require,module,exports){
module.exports=require(34)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/net/URLLoaderDataFormat.js":34}],144:[function(require,module,exports){
module.exports=require(35)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/net/URLRequest.js":35,"awayjs-core/lib/net/URLRequestMethod":145}],145:[function(require,module,exports){
module.exports=require(36)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/net/URLRequestMethod.js":36}],146:[function(require,module,exports){
module.exports=require(39)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/parsers/ParserBase.js":39,"awayjs-core/lib/errors/AbstractMethodError":135,"awayjs-core/lib/events/AssetEvent":137,"awayjs-core/lib/events/EventDispatcher":139,"awayjs-core/lib/events/ParserEvent":140,"awayjs-core/lib/events/TimerEvent":141,"awayjs-core/lib/parsers/ParserUtils":147,"awayjs-core/lib/parsers/ResourceDependency":148,"awayjs-core/lib/utils/TextureUtils":151,"awayjs-core/lib/utils/Timer":152,"awayjs-core/lib/utils/getTimer":153}],147:[function(require,module,exports){
module.exports=require(40)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/parsers/ParserUtils.js":40,"awayjs-core/lib/utils/ByteArray":149}],148:[function(require,module,exports){
module.exports=require(41)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/parsers/ResourceDependency.js":41}],149:[function(require,module,exports){
module.exports=require(49)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ByteArray.js":49,"awayjs-core/lib/utils/ByteArrayBase":150}],150:[function(require,module,exports){
module.exports=require(50)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ByteArrayBase.js":50,"awayjs-core/lib/errors/AbstractMethodError":135}],151:[function(require,module,exports){
module.exports=require(54)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/TextureUtils.js":54}],152:[function(require,module,exports){
module.exports=require(55)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/Timer.js":55,"awayjs-core/lib/errors/Error":136,"awayjs-core/lib/events/EventDispatcher":139,"awayjs-core/lib/events/TimerEvent":141}],153:[function(require,module,exports){
module.exports=require(56)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/getTimer.js":56}],154:[function(require,module,exports){
module.exports=require(57)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/AlignmentMode.js":57}],155:[function(require,module,exports){
module.exports=require(58)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/DisplayObject.js":58,"awayjs-core/lib/bounds/AxisAlignedBoundingBox":172,"awayjs-core/lib/errors/AbstractMethodError":174,"awayjs-core/lib/geom/MathConsts":183,"awayjs-core/lib/geom/Matrix3D":184,"awayjs-core/lib/geom/Matrix3DUtils":185,"awayjs-core/lib/geom/Point":188,"awayjs-core/lib/geom/Vector3D":189,"awayjs-core/lib/library/NamedAssetBase":191,"awayjs-display/lib/base/AlignmentMode":154,"awayjs-display/lib/base/OrientationMode":157,"awayjs-display/lib/base/Transform":160,"awayjs-display/lib/events/DisplayObjectEvent":165,"awayjs-display/lib/events/SceneEvent":167,"awayjs-display/lib/pick/PickingCollisionVO":171}],156:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var GeometryEvent = require("awayjs-display/lib/events/GeometryEvent");
/**
 *
 * Geometry is a collection of SubGeometries, each of which contain the actual geometrical data such as vertices,
 * normals, uvs, etc. It also contains a reference to an animation class, which defines how the geometry moves.
 * A Geometry object is assigned to a Mesh, a scene graph occurence of the geometry, which in turn assigns
 * the SubGeometries to its respective TriangleSubMesh objects.
 *
 *
 *
 * @see away.core.base.SubGeometry
 * @see away.entities.Mesh
 *
 * @class Geometry
 */
var Geometry = (function (_super) {
    __extends(Geometry, _super);
    /**
     * Creates a new Geometry object.
     */
    function Geometry() {
        _super.call(this);
        this._subGeometries = new Array();
    }
    Object.defineProperty(Geometry.prototype, "assetType", {
        get: function () {
            return AssetType.GEOMETRY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "subGeometries", {
        /**
         * A collection of TriangleSubGeometry objects, each of which contain geometrical data such as vertices, normals, etc.
         */
        get: function () {
            return this._subGeometries;
        },
        enumerable: true,
        configurable: true
    });
    Geometry.prototype.getSubGeometries = function () {
        return this._subGeometries;
    };
    Geometry.prototype.applyTransformation = function (transform) {
        var len = this._subGeometries.length;
        for (var i = 0; i < len; ++i)
            this._subGeometries[i].applyTransformation(transform);
    };
    /**
     * Adds a new TriangleSubGeometry object to the list.
     * @param subGeometry The TriangleSubGeometry object to be added.
     */
    Geometry.prototype.addSubGeometry = function (subGeometry) {
        this._subGeometries.push(subGeometry);
        subGeometry.parentGeometry = this;
        if (this.hasEventListener(GeometryEvent.SUB_GEOMETRY_ADDED))
            this.dispatchEvent(new GeometryEvent(GeometryEvent.SUB_GEOMETRY_ADDED, subGeometry));
        this.iInvalidateBounds(subGeometry);
    };
    /**
     * Removes a new TriangleSubGeometry object from the list.
     * @param subGeometry The TriangleSubGeometry object to be removed.
     */
    Geometry.prototype.removeSubGeometry = function (subGeometry) {
        this._subGeometries.splice(this._subGeometries.indexOf(subGeometry), 1);
        subGeometry.parentGeometry = null;
        if (this.hasEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED))
            this.dispatchEvent(new GeometryEvent(GeometryEvent.SUB_GEOMETRY_REMOVED, subGeometry));
        this.iInvalidateBounds(subGeometry);
    };
    /**
     * Clones the geometry.
     * @return An exact duplicate of the current Geometry object.
     */
    Geometry.prototype.clone = function () {
        var clone = new Geometry();
        var len = this._subGeometries.length;
        for (var i = 0; i < len; ++i)
            clone.addSubGeometry(this._subGeometries[i].clone());
        return clone;
    };
    /**
     * Scales the geometry.
     * @param scale The amount by which to scale.
     */
    Geometry.prototype.scale = function (scale) {
        var numSubGeoms = this._subGeometries.length;
        for (var i = 0; i < numSubGeoms; ++i)
            this._subGeometries[i].scale(scale);
    };
    /**
     * Clears all resources used by the Geometry object, including SubGeometries.
     */
    Geometry.prototype.dispose = function () {
        var numSubGeoms = this._subGeometries.length;
        for (var i = 0; i < numSubGeoms; ++i) {
            var subGeom = this._subGeometries[0];
            this.removeSubGeometry(subGeom);
            subGeom.dispose();
        }
    };
    /**
     * Scales the uv coordinates (tiling)
     * @param scaleU The amount by which to scale on the u axis. Default is 1;
     * @param scaleV The amount by which to scale on the v axis. Default is 1;
     */
    Geometry.prototype.scaleUV = function (scaleU, scaleV) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
        var numSubGeoms = this._subGeometries.length;
        for (var i = 0; i < numSubGeoms; ++i)
            this._subGeometries[i].scaleUV(scaleU, scaleV);
    };
    Geometry.prototype.iInvalidateBounds = function (subGeom) {
        if (this.hasEventListener(GeometryEvent.BOUNDS_INVALID))
            this.dispatchEvent(new GeometryEvent(GeometryEvent.BOUNDS_INVALID, subGeom));
    };
    return Geometry;
})(NamedAssetBase);
module.exports = Geometry;


},{"awayjs-core/lib/library/AssetType":190,"awayjs-core/lib/library/NamedAssetBase":191,"awayjs-display/lib/events/GeometryEvent":166}],157:[function(require,module,exports){
module.exports=require(60)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/OrientationMode.js":60}],158:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var SubGeometryEvent = require("awayjs-display/lib/events/SubGeometryEvent");
/**
 * @class away.base.TriangleSubGeometry
 */
var SubGeometryBase = (function (_super) {
    __extends(SubGeometryBase, _super);
    /**
     *
     */
    function SubGeometryBase(concatenatedArrays) {
        _super.call(this);
        this._pStrideOffsetDirty = true;
        this._pConcatenateArrays = true;
        this._pStride = new Object();
        this._pOffset = new Object();
        this._pConcatenateArrays = concatenatedArrays;
    }
    SubGeometryBase.prototype._pUpdateStrideOffset = function () {
        throw new AbstractMethodError();
    };
    Object.defineProperty(SubGeometryBase.prototype, "subMeshClass", {
        get: function () {
            return this._pSubMeshClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubGeometryBase.prototype, "concatenateArrays", {
        /**
         *
         */
        get: function () {
            return this._pConcatenateArrays;
        },
        set: function (value) {
            if (this._pConcatenateArrays == value)
                return;
            this._pConcatenateArrays = value;
            this._pStrideOffsetDirty = true;
            if (value)
                this._pNotifyVerticesUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubGeometryBase.prototype, "indices", {
        /**
         * The raw index data that define the faces.
         */
        get: function () {
            return this._pIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubGeometryBase.prototype, "vertices", {
        /**
         *
         */
        get: function () {
            this.updateVertices();
            return this._pVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubGeometryBase.prototype, "numTriangles", {
        /**
         * The total amount of triangles in the TriangleSubGeometry.
         */
        get: function () {
            return this._numTriangles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubGeometryBase.prototype, "numVertices", {
        get: function () {
            return this._pNumVertices;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    SubGeometryBase.prototype.getStride = function (dataType) {
        if (this._pStrideOffsetDirty)
            this._pUpdateStrideOffset();
        return this._pStride[dataType];
    };
    /**
     *
     */
    SubGeometryBase.prototype.getOffset = function (dataType) {
        if (this._pStrideOffsetDirty)
            this._pUpdateStrideOffset();
        return this._pOffset[dataType];
    };
    SubGeometryBase.prototype.updateVertices = function () {
        throw new AbstractMethodError();
    };
    /**
     *
     */
    SubGeometryBase.prototype.dispose = function () {
        this._pIndices = null;
        this._pVertices = null;
    };
    /**
     * Updates the face indices of the TriangleSubGeometry.
     *
     * @param indices The face indices to upload.
     */
    SubGeometryBase.prototype.updateIndices = function (indices) {
        this._pIndices = indices;
        this._numIndices = indices.length;
        this._numTriangles = this._numIndices / 3;
        this.notifyIndicesUpdate();
    };
    /**
     * @protected
     */
    SubGeometryBase.prototype.pInvalidateBounds = function () {
        if (this.parentGeometry)
            this.parentGeometry.iInvalidateBounds(this);
    };
    /**
     * Clones the current object
     * @return An exact duplicate of the current object.
     */
    SubGeometryBase.prototype.clone = function () {
        throw new AbstractMethodError();
    };
    SubGeometryBase.prototype.applyTransformation = function (transform) {
    };
    /**
     * Scales the geometry.
     * @param scale The amount by which to scale.
     */
    SubGeometryBase.prototype.scale = function (scale) {
    };
    SubGeometryBase.prototype.scaleUV = function (scaleU, scaleV) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
    };
    SubGeometryBase.prototype.getBoundingPositions = function () {
        throw new AbstractMethodError();
    };
    SubGeometryBase.prototype.notifyIndicesUpdate = function () {
        if (!this._indicesUpdated)
            this._indicesUpdated = new SubGeometryEvent(SubGeometryEvent.INDICES_UPDATED);
        this.dispatchEvent(this._indicesUpdated);
    };
    SubGeometryBase.prototype._pNotifyVerticesUpdate = function () {
        throw new AbstractMethodError();
    };
    SubGeometryBase.VERTEX_DATA = "vertices";
    return SubGeometryBase;
})(NamedAssetBase);
module.exports = SubGeometryBase;


},{"awayjs-core/lib/errors/AbstractMethodError":174,"awayjs-core/lib/library/NamedAssetBase":191,"awayjs-display/lib/events/SubGeometryEvent":168}],159:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
/**
 * SubMeshBase wraps a TriangleSubGeometry as a scene graph instantiation. A SubMeshBase is owned by a Mesh object.
 *
 *
 * @see away.base.TriangleSubGeometry
 * @see away.entities.Mesh
 *
 * @class away.base.SubMeshBase
 */
var SubMeshBase = (function (_super) {
    __extends(SubMeshBase, _super);
    /**
     * Creates a new SubMeshBase object
     */
    function SubMeshBase() {
        _super.call(this);
        this._iIndex = 0;
        this._renderables = new Array();
    }
    Object.defineProperty(SubMeshBase.prototype, "animator", {
        //TODO test shader picking
        //		public get shaderPickingDetails():boolean
        //		{
        //
        //			return this.sourceEntity.shaderPickingDetails;
        //		}
        /**
         * The animator object that provides the state for the TriangleSubMesh's animation.
         */
        get: function () {
            return this._pParentMesh.animator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubMeshBase.prototype, "material", {
        /**
         * The material used to render the current TriangleSubMesh. If set to null, its parent Mesh's material will be used instead.
         */
        get: function () {
            return this._material || this._pParentMesh.material;
        },
        set: function (value) {
            if (this.material)
                this.material.iRemoveOwner(this);
            this._material = value;
            if (this.material)
                this.material.iAddOwner(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubMeshBase.prototype, "sceneTransform", {
        /**
         * The scene transform object that transforms from model to world space.
         */
        get: function () {
            return this._pParentMesh.sceneTransform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubMeshBase.prototype, "parentMesh", {
        /**
         * The entity that that initially provided the IRenderable to the render pipeline (ie: the owning Mesh object).
         */
        get: function () {
            return this._pParentMesh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubMeshBase.prototype, "uvTransform", {
        /**
         *
         */
        get: function () {
            return this._uvTransform || this._pParentMesh.uvTransform;
        },
        set: function (value) {
            this._uvTransform = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    SubMeshBase.prototype.dispose = function () {
        this.material = null;
        var len = this._renderables.length;
        for (var i = 0; i < len; i++)
            this._renderables[i].dispose();
    };
    /**
     *
     * @param camera
     * @returns {away.geom.Matrix3D}
     */
    SubMeshBase.prototype.getRenderSceneTransform = function (camera) {
        return this._pParentMesh.getRenderSceneTransform(camera);
    };
    SubMeshBase.prototype._iAddRenderable = function (renderable) {
        this._renderables.push(renderable);
        return renderable;
    };
    SubMeshBase.prototype._iRemoveRenderable = function (renderable) {
        var index = this._renderables.indexOf(renderable);
        this._renderables.splice(index, 1);
        return renderable;
    };
    SubMeshBase.prototype._iInvalidateRenderableGeometry = function () {
        var len = this._renderables.length;
        for (var i = 0; i < len; i++)
            this._renderables[i].invalidateGeometry();
    };
    SubMeshBase.prototype._iCollectRenderable = function (renderer) {
        throw new AbstractMethodError();
    };
    SubMeshBase.prototype._iGetExplicitMaterial = function () {
        return this._material;
    };
    return SubMeshBase;
})(NamedAssetBase);
module.exports = SubMeshBase;


},{"awayjs-core/lib/errors/AbstractMethodError":174,"awayjs-core/lib/library/NamedAssetBase":191}],160:[function(require,module,exports){
module.exports=require(61)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/Transform.js":61,"awayjs-core/lib/geom/Matrix3D":184,"awayjs-core/lib/geom/Matrix3DUtils":185,"awayjs-core/lib/geom/Vector3D":189}],161:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var SubGeometryBase = require("awayjs-display/lib/base/SubGeometryBase");
var TriangleSubMesh = require("awayjs-display/lib/base/TriangleSubMesh");
var SubGeometryEvent = require("awayjs-display/lib/events/SubGeometryEvent");
/**
 * @class away.base.TriangleSubGeometry
 */
var TriangleSubGeometry = (function (_super) {
    __extends(TriangleSubGeometry, _super);
    /**
     *
     */
    function TriangleSubGeometry(concatenatedArrays) {
        _super.call(this, concatenatedArrays);
        this._positionsDirty = true;
        this._faceNormalsDirty = true;
        this._faceTangentsDirty = true;
        this._vertexNormalsDirty = true;
        this._vertexTangentsDirty = true;
        this._uvsDirty = true;
        this._secondaryUVsDirty = true;
        this._jointIndicesDirty = true;
        this._jointWeightsDirty = true;
        this._concatenateArrays = true;
        this._autoDeriveNormals = true;
        this._autoDeriveTangents = true;
        this._autoDeriveUVs = false;
        this._useFaceWeights = false;
        this._scaleU = 1;
        this._scaleV = 1;
        this._pSubMeshClass = TriangleSubMesh;
    }
    Object.defineProperty(TriangleSubGeometry.prototype, "scaleU", {
        /**
         *
         */
        get: function () {
            return this._scaleU;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "scaleV", {
        /**
         *
         */
        get: function () {
            return this._scaleV;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "useCondensedIndices", {
        /**
         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
         * by condensing the number of joint index values required per mesh. Only applicable to
         * skeleton animations that utilise more than one mesh object. Defaults to false.
         */
        get: function () {
            return this._useCondensedIndices;
        },
        set: function (value) {
            if (this._useCondensedIndices == value)
                return;
            this._useCondensedIndices = value;
            this.notifyJointIndicesUpdate();
        },
        enumerable: true,
        configurable: true
    });
    TriangleSubGeometry.prototype._pUpdateStrideOffset = function () {
        if (this._concatenateArrays) {
            this._pOffset[TriangleSubGeometry.VERTEX_DATA] = 0;
            //always have positions
            this._pOffset[TriangleSubGeometry.POSITION_DATA] = 0;
            var stride = 3;
            if (this._vertexNormals != null) {
                this._pOffset[TriangleSubGeometry.NORMAL_DATA] = stride;
                stride += 3;
            }
            if (this._vertexTangents != null) {
                this._pOffset[TriangleSubGeometry.TANGENT_DATA] = stride;
                stride += 3;
            }
            if (this._uvs != null) {
                this._pOffset[TriangleSubGeometry.UV_DATA] = stride;
                stride += 2;
            }
            if (this._secondaryUVs != null) {
                this._pOffset[TriangleSubGeometry.SECONDARY_UV_DATA] = stride;
                stride += 2;
            }
            if (this._jointIndices != null) {
                this._pOffset[TriangleSubGeometry.JOINT_INDEX_DATA] = stride;
                stride += this._jointsPerVertex;
            }
            if (this._jointWeights != null) {
                this._pOffset[TriangleSubGeometry.JOINT_WEIGHT_DATA] = stride;
                stride += this._jointsPerVertex;
            }
            this._pStride[TriangleSubGeometry.VERTEX_DATA] = stride;
            this._pStride[TriangleSubGeometry.POSITION_DATA] = stride;
            this._pStride[TriangleSubGeometry.NORMAL_DATA] = stride;
            this._pStride[TriangleSubGeometry.TANGENT_DATA] = stride;
            this._pStride[TriangleSubGeometry.UV_DATA] = stride;
            this._pStride[TriangleSubGeometry.SECONDARY_UV_DATA] = stride;
            this._pStride[TriangleSubGeometry.JOINT_INDEX_DATA] = stride;
            this._pStride[TriangleSubGeometry.JOINT_WEIGHT_DATA] = stride;
            var len = this._pNumVertices * stride;
            if (this._pVertices == null)
                this._pVertices = new Array(len);
            else if (this._pVertices.length != len)
                this._pVertices.length = len;
        }
        else {
            this._pOffset[TriangleSubGeometry.POSITION_DATA] = 0;
            this._pOffset[TriangleSubGeometry.NORMAL_DATA] = 0;
            this._pOffset[TriangleSubGeometry.TANGENT_DATA] = 0;
            this._pOffset[TriangleSubGeometry.UV_DATA] = 0;
            this._pOffset[TriangleSubGeometry.SECONDARY_UV_DATA] = 0;
            this._pOffset[TriangleSubGeometry.JOINT_INDEX_DATA] = 0;
            this._pOffset[TriangleSubGeometry.JOINT_WEIGHT_DATA] = 0;
            this._pStride[TriangleSubGeometry.POSITION_DATA] = 3;
            this._pStride[TriangleSubGeometry.NORMAL_DATA] = 3;
            this._pStride[TriangleSubGeometry.TANGENT_DATA] = 3;
            this._pStride[TriangleSubGeometry.UV_DATA] = 2;
            this._pStride[TriangleSubGeometry.SECONDARY_UV_DATA] = 2;
            this._pStride[TriangleSubGeometry.JOINT_INDEX_DATA] = this._jointsPerVertex;
            this._pStride[TriangleSubGeometry.JOINT_WEIGHT_DATA] = this._jointsPerVertex;
        }
        this._pStrideOffsetDirty = false;
    };
    Object.defineProperty(TriangleSubGeometry.prototype, "jointsPerVertex", {
        /**
         *
         */
        get: function () {
            return this._jointsPerVertex;
        },
        set: function (value) {
            if (this._jointsPerVertex == value)
                return;
            this._jointsPerVertex = value;
            this._pStrideOffsetDirty = true;
            if (this._pConcatenateArrays)
                this._pNotifyVerticesUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "autoDeriveUVs", {
        /**
         * Defines whether a UV buffer should be automatically generated to contain dummy UV coordinates.
         * Set to true if a geometry lacks UV data but uses a material that requires it, or leave as false
         * in cases where UV data is explicitly defined or the material does not require UV data.
         */
        get: function () {
            return this._autoDeriveUVs;
        },
        set: function (value) {
            if (this._autoDeriveUVs == value)
                return;
            this._autoDeriveUVs = value;
            if (value)
                this.notifyUVsUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "autoDeriveNormals", {
        /**
         * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
         * explicitly.
         */
        get: function () {
            return this._autoDeriveNormals;
        },
        set: function (value) {
            if (this._autoDeriveNormals == value)
                return;
            this._autoDeriveNormals = value;
            if (value)
                this.notifyNormalsUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "autoDeriveTangents", {
        /**
         * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
         * explicitly.
         */
        get: function () {
            return this._autoDeriveTangents;
        },
        set: function (value) {
            if (this._autoDeriveTangents == value)
                return;
            this._autoDeriveTangents = value;
            if (value)
                this.notifyTangentsUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "vertices", {
        /**
         *
         */
        get: function () {
            if (this._positionsDirty)
                this.updatePositions(this._positions);
            if (this._vertexNormalsDirty)
                this.updateVertexNormals(this._vertexNormals);
            if (this._vertexTangentsDirty)
                this.updateVertexTangents(this._vertexTangents);
            if (this._uvsDirty)
                this.updateUVs(this._uvs);
            if (this._secondaryUVsDirty)
                this.updateSecondaryUVs(this._secondaryUVs);
            if (this._jointIndicesDirty)
                this.updateJointIndices(this._jointIndices);
            if (this._jointWeightsDirty)
                this.updateJointWeights(this._jointWeights);
            return this._pVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "positions", {
        /**
         *
         */
        get: function () {
            if (this._positionsDirty)
                this.updatePositions(this._positions);
            return this._positions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "vertexNormals", {
        /**
         *
         */
        get: function () {
            if (this._vertexNormalsDirty)
                this.updateVertexNormals(this._vertexNormals);
            return this._vertexNormals;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "vertexTangents", {
        /**
         *
         */
        get: function () {
            if (this._vertexTangentsDirty)
                this.updateVertexTangents(this._vertexTangents);
            return this._vertexTangents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "faceNormals", {
        /**
         * The raw data of the face normals, in the same order as the faces are listed in the index list.
         */
        get: function () {
            if (this._faceNormalsDirty)
                this.updateFaceNormals();
            return this._faceNormals;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "faceTangents", {
        /**
         * The raw data of the face tangets, in the same order as the faces are listed in the index list.
         */
        get: function () {
            if (this._faceTangentsDirty)
                this.updateFaceTangents();
            return this._faceTangents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "uvs", {
        /**
         *
         */
        get: function () {
            if (this._uvsDirty)
                this.updateUVs(this._uvs);
            return this._uvs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "secondaryUVs", {
        /**
         *
         */
        get: function () {
            if (this._secondaryUVsDirty)
                this.updateSecondaryUVs(this._secondaryUVs);
            return this._secondaryUVs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "jointIndices", {
        /**
         *
         */
        get: function () {
            if (this._jointIndicesDirty)
                this.updateJointIndices(this._jointIndices);
            if (this._useCondensedIndices)
                return this._condensedJointIndices;
            return this._jointIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "jointWeights", {
        /**
         *
         */
        get: function () {
            if (this._jointWeightsDirty)
                this.updateJointWeights(this._jointWeights);
            return this._jointWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "useFaceWeights", {
        /**
         * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
         */
        get: function () {
            return this._useFaceWeights;
        },
        set: function (value) {
            if (this._useFaceWeights == value)
                return;
            this._useFaceWeights = value;
            if (this._autoDeriveNormals)
                this.notifyNormalsUpdate();
            if (this._autoDeriveTangents)
                this.notifyTangentsUpdate();
            this._faceNormalsDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "numCondensedJoints", {
        get: function () {
            if (this._jointIndicesDirty)
                this.updateJointIndices(this._jointIndices);
            return this._numCondensedJoints;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubGeometry.prototype, "condensedIndexLookUp", {
        get: function () {
            if (this._jointIndicesDirty)
                this.updateJointIndices(this._jointIndices);
            return this._condensedIndexLookUp;
        },
        enumerable: true,
        configurable: true
    });
    TriangleSubGeometry.prototype.getBoundingPositions = function () {
        if (this._positionsDirty)
            this.updatePositions(this._positions);
        return this._positions;
    };
    /**
     *
     */
    TriangleSubGeometry.prototype.updatePositions = function (values) {
        var i;
        var index;
        var stride;
        var positions;
        this._positions = values;
        if (this._positions == null)
            this._positions = new Array();
        this._pNumVertices = this._positions.length / 3;
        if (this._concatenateArrays) {
            var len = this._pNumVertices * this.getStride(TriangleSubGeometry.VERTEX_DATA);
            if (this._pVertices == null)
                this._pVertices = new Array(len);
            else if (this._pVertices.length != len)
                this._pVertices.length = len;
            i = 0;
            index = this.getOffset(TriangleSubGeometry.POSITION_DATA);
            stride = this.getStride(TriangleSubGeometry.POSITION_DATA);
            positions = this._pVertices;
            while (i < values.length) {
                positions[index] = values[i++];
                positions[index + 1] = values[i++];
                positions[index + 2] = values[i++];
                index += stride;
            }
        }
        if (this._autoDeriveNormals)
            this.notifyNormalsUpdate();
        if (this._autoDeriveTangents)
            this.notifyTangentsUpdate();
        if (this._autoDeriveUVs)
            this.notifyUVsUpdate();
        this.pInvalidateBounds();
        this.notifyPositionsUpdate();
        this._positionsDirty = false;
    };
    /**
     * Updates the vertex normals based on the geometry.
     */
    TriangleSubGeometry.prototype.updateVertexNormals = function (values) {
        var i;
        var index;
        var offset;
        var stride;
        var normals;
        if (!this._autoDeriveNormals) {
            if ((this._vertexNormals == null || values == null) && (this._vertexNormals != null || values != null)) {
                if (this._concatenateArrays)
                    this._pNotifyVerticesUpdate();
                else
                    this._pStrideOffsetDirty = true;
            }
            this._vertexNormals = values;
            if (values != null && this._concatenateArrays) {
                i = 0;
                index = this.getOffset(TriangleSubGeometry.NORMAL_DATA);
                stride = this.getStride(TriangleSubGeometry.NORMAL_DATA);
                normals = this._pVertices;
                while (i < values.length) {
                    normals[index] = values[i++];
                    normals[index + 1] = values[i++];
                    normals[index + 2] = values[i++];
                    index += stride;
                }
            }
        }
        else {
            if (this._vertexNormals == null) {
                this._vertexNormals = new Array(this._positions.length);
                if (this._concatenateArrays)
                    this._pNotifyVerticesUpdate();
                else
                    this._pStrideOffsetDirty = true;
            }
            if (this._faceNormalsDirty)
                this.updateFaceNormals();
            offset = this.getOffset(TriangleSubGeometry.NORMAL_DATA);
            stride = this.getStride(TriangleSubGeometry.NORMAL_DATA);
            //autoderived normals
            normals = this._concatenateArrays ? this._pVertices : this._vertexNormals;
            var f1 = 0;
            var f2 = 1;
            var f3 = 2;
            index = offset;
            //clear normal values
            var lenV = normals.length;
            while (index < lenV) {
                normals[index] = 0;
                normals[index + 1] = 0;
                normals[index + 2] = 0;
                index += stride;
            }
            var k = 0;
            var lenI = this._pIndices.length;
            var weight;
            i = 0;
            while (i < lenI) {
                weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                index = offset + this._pIndices[i++] * stride;
                normals[index] += this._faceNormals[f1] * weight;
                normals[index + 1] += this._faceNormals[f2] * weight;
                normals[index + 2] += this._faceNormals[f3] * weight;
                index = offset + this._pIndices[i++] * stride;
                normals[index] += this._faceNormals[f1] * weight;
                normals[index + 1] += this._faceNormals[f2] * weight;
                normals[index + 2] += this._faceNormals[f3] * weight;
                index = offset + this._pIndices[i++] * stride;
                normals[index] += this._faceNormals[f1] * weight;
                normals[index + 1] += this._faceNormals[f2] * weight;
                normals[index + 2] += this._faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = 0;
            index = offset;
            while (index < lenV) {
                var vx = normals[index];
                var vy = normals[index + 1];
                var vz = normals[index + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                if (this._concatenateArrays) {
                    this._vertexNormals[i++] = normals[index] = vx * d;
                    this._vertexNormals[i++] = normals[index + 1] = vy * d;
                    this._vertexNormals[i++] = normals[index + 2] = vz * d;
                }
                else {
                    normals[index] = vx * d;
                    normals[index + 1] = vy * d;
                    normals[index + 2] = vz * d;
                }
                index += stride;
            }
        }
        this.notifyNormalsUpdate();
        this._vertexNormalsDirty = false;
    };
    /**
     * Updates the vertex tangents based on the geometry.
     */
    TriangleSubGeometry.prototype.updateVertexTangents = function (values) {
        var i;
        var index;
        var offset;
        var stride;
        var tangents;
        if (!this._autoDeriveTangents) {
            if ((this._vertexTangents == null || values == null) && (this._vertexTangents != null || values != null)) {
                if (this._concatenateArrays)
                    this._pNotifyVerticesUpdate();
                else
                    this._pStrideOffsetDirty = true;
            }
            this._vertexTangents = values;
            if (values != null && this._concatenateArrays) {
                i = 0;
                index = this.getOffset(TriangleSubGeometry.TANGENT_DATA);
                stride = this.getStride(TriangleSubGeometry.TANGENT_DATA);
                tangents = this._pVertices;
                while (i < values.length) {
                    tangents[index] = values[i++];
                    tangents[index + 1] = values[i++];
                    tangents[index + 2] = values[i++];
                    index += stride;
                }
            }
        }
        else {
            if (this._vertexTangents == null) {
                this._vertexTangents = new Array(this._positions.length);
                if (this._concatenateArrays)
                    this._pNotifyVerticesUpdate();
                else
                    this._pStrideOffsetDirty = true;
            }
            if (this._faceTangentsDirty)
                this.updateFaceTangents();
            offset = this.getOffset(TriangleSubGeometry.TANGENT_DATA);
            stride = this.getStride(TriangleSubGeometry.TANGENT_DATA);
            //autoderived tangents
            tangents = this._concatenateArrays ? this._pVertices : this._vertexTangents;
            index = offset;
            //clear tangent values
            var lenV = tangents.length;
            while (index < lenV) {
                tangents[index] = 0;
                tangents[index + 1] = 0;
                tangents[index + 2] = 0;
                index += stride;
            }
            var k = 0;
            var weight;
            var f1 = 0;
            var f2 = 1;
            var f3 = 2;
            i = 0;
            //collect face tangents
            var lenI = this._pIndices.length;
            while (i < lenI) {
                weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                index = offset + this._pIndices[i++] * stride;
                tangents[index++] += this._faceTangents[f1] * weight;
                tangents[index++] += this._faceTangents[f2] * weight;
                tangents[index] += this._faceTangents[f3] * weight;
                index = offset + this._pIndices[i++] * stride;
                tangents[index++] += this._faceTangents[f1] * weight;
                tangents[index++] += this._faceTangents[f2] * weight;
                tangents[index] += this._faceTangents[f3] * weight;
                index = offset + this._pIndices[i++] * stride;
                tangents[index++] += this._faceTangents[f1] * weight;
                tangents[index++] += this._faceTangents[f2] * weight;
                tangents[index] += this._faceTangents[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = 0;
            index = offset;
            while (index < lenV) {
                var vx = tangents[index];
                var vy = tangents[index + 1];
                var vz = tangents[index + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                if (this._concatenateArrays) {
                    this._vertexTangents[i++] = tangents[index] = vx * d;
                    this._vertexTangents[i++] = tangents[index + 1] = vy * d;
                    this._vertexTangents[i++] = tangents[index + 2] = vz * d;
                }
                else {
                    tangents[index] = vx * d;
                    tangents[index + 1] = vy * d;
                    tangents[index + 2] = vz * d;
                }
                index += stride;
            }
        }
        this.notifyTangentsUpdate();
        this._vertexTangentsDirty = false;
    };
    /**
     * Updates the uvs based on the geometry.
     */
    TriangleSubGeometry.prototype.updateUVs = function (values) {
        var i;
        var index;
        var offset;
        var stride;
        var uvs;
        if (!this._autoDeriveUVs) {
            if ((this._uvs == null || values == null) && (this._uvs != null || values != null)) {
                if (this._concatenateArrays)
                    this._pNotifyVerticesUpdate();
                else
                    this._pStrideOffsetDirty = true;
            }
            this._uvs = values;
            if (values != null && this._concatenateArrays) {
                i = 0;
                index = this.getOffset(TriangleSubGeometry.UV_DATA);
                stride = this.getStride(TriangleSubGeometry.UV_DATA);
                uvs = this._pVertices;
                while (i < values.length) {
                    uvs[index] = values[i++];
                    uvs[index + 1] = values[i++];
                    index += stride;
                }
            }
        }
        else {
            if (this._uvs == null) {
                this._uvs = new Array(this._positions.length * 2 / 3);
                if (this._concatenateArrays)
                    this._pNotifyVerticesUpdate();
                else
                    this._pStrideOffsetDirty = true;
            }
            offset = this.getOffset(TriangleSubGeometry.UV_DATA);
            stride = this.getStride(TriangleSubGeometry.UV_DATA);
            //autoderived uvs
            uvs = this._concatenateArrays ? this._pVertices : this._uvs;
            i = 0;
            index = offset;
            var uvIdx = 0;
            //clear uv values
            var lenV = uvs.length;
            while (index < lenV) {
                if (this._concatenateArrays) {
                    this._uvs[i++] = uvs[index] = uvIdx * .5;
                    this._uvs[i++] = uvs[index + 1] = 1.0 - (uvIdx & 1);
                }
                else {
                    uvs[index] = uvIdx * .5;
                    uvs[index + 1] = 1.0 - (uvIdx & 1);
                }
                if (++uvIdx == 3)
                    uvIdx = 0;
                index += stride;
            }
        }
        if (this._autoDeriveTangents)
            this.notifyTangentsUpdate();
        this.notifyUVsUpdate();
        this._uvsDirty = false;
    };
    /**
     * Updates the secondary uvs based on the geometry.
     */
    TriangleSubGeometry.prototype.updateSecondaryUVs = function (values) {
        var i;
        var index;
        var offset;
        var stride;
        var uvs;
        if (this._concatenateArrays && (this._secondaryUVs == null || values == null) && (this._secondaryUVs != null || values != null))
            this._pNotifyVerticesUpdate();
        this._secondaryUVs = values;
        if (values != null && this._concatenateArrays) {
            offset = this.getOffset(TriangleSubGeometry.SECONDARY_UV_DATA);
            stride = this.getStride(TriangleSubGeometry.SECONDARY_UV_DATA);
            i = 0;
            index = offset;
            uvs = this._pVertices;
            while (i < values.length) {
                uvs[index] = values[i++];
                uvs[index + 1] = values[i++];
                index += stride;
            }
        }
        this.notifySecondaryUVsUpdate();
        this._secondaryUVsDirty = false;
    };
    /**
     * Updates the joint indices
     */
    TriangleSubGeometry.prototype.updateJointIndices = function (values) {
        var i;
        var j;
        var index;
        var offset;
        var stride;
        var jointIndices;
        if (this._concatenateArrays && (this._jointIndices == null || values == null) && (this._jointIndices != null || values != null))
            this._pNotifyVerticesUpdate();
        this._jointIndices = values;
        if (values != null) {
            offset = this.getOffset(TriangleSubGeometry.JOINT_INDEX_DATA);
            stride = this.getStride(TriangleSubGeometry.JOINT_INDEX_DATA);
            if (this._useCondensedIndices) {
                i = 0;
                j = 0;
                index = offset;
                jointIndices = this._concatenateArrays ? this._pVertices : this._condensedJointIndices;
                var oldIndex;
                var newIndex = 0;
                var dic = new Object();
                if (!this._concatenateArrays)
                    this._condensedJointIndices = new Array(values.length);
                this._condensedIndexLookUp = new Array();
                while (i < values.length) {
                    for (j = 0; j < this._jointsPerVertex; j++) {
                        oldIndex = values[i++];
                        // if we encounter a new index, assign it a new condensed index
                        if (dic[oldIndex] == undefined) {
                            dic[oldIndex] = newIndex * 3; //3 required for the three vectors that store the matrix
                            this._condensedIndexLookUp[newIndex++] = oldIndex;
                        }
                        jointIndices[index + j] = dic[oldIndex];
                    }
                    index += stride;
                }
                this._numCondensedJoints = newIndex;
            }
            else if (this._concatenateArrays) {
                i = 0;
                index = offset;
                jointIndices = this._pVertices;
                while (i < values.length) {
                    j = 0;
                    while (j < this._jointsPerVertex)
                        jointIndices[index + j++] = values[i++];
                    index += stride;
                }
            }
        }
        this.notifyJointIndicesUpdate();
        this._jointIndicesDirty = false;
    };
    /**
     * Updates the joint weights.
     */
    TriangleSubGeometry.prototype.updateJointWeights = function (values) {
        var i;
        var j;
        var index;
        var offset;
        var stride;
        var jointWeights;
        if (this._concatenateArrays && (this._jointWeights == null || values == null) && (this._jointWeights != null || values != null))
            this._pNotifyVerticesUpdate();
        this._jointWeights = values;
        if (values != null && this._concatenateArrays) {
            offset = this.getOffset(TriangleSubGeometry.JOINT_WEIGHT_DATA);
            stride = this.getStride(TriangleSubGeometry.JOINT_WEIGHT_DATA);
            i = 0;
            index = offset;
            jointWeights = this._pVertices;
            while (i < values.length) {
                j = 0;
                while (j < this._jointsPerVertex)
                    jointWeights[index + j++] = values[i++];
                index += stride;
            }
        }
        this.notifyJointWeightsUpdate();
        this._jointWeightsDirty = false;
    };
    /**
     *
     */
    TriangleSubGeometry.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._positions = null;
        this._vertexNormals = null;
        this._vertexTangents = null;
        this._uvs = null;
        this._secondaryUVs = null;
        this._jointIndices = null;
        this._jointWeights = null;
        this._faceNormals = null;
        this._faceWeights = null;
        this._faceTangents = null;
    };
    /**
     * Updates the face indices of the TriangleSubGeometry.
     *
     * @param indices The face indices to upload.
     */
    TriangleSubGeometry.prototype.updateIndices = function (indices) {
        _super.prototype.updateIndices.call(this, indices);
        this._faceNormalsDirty = true;
        if (this._autoDeriveNormals)
            this._vertexNormalsDirty = true;
        if (this._autoDeriveTangents)
            this._vertexTangentsDirty = true;
        if (this._autoDeriveUVs)
            this._uvsDirty = true;
    };
    /**
     * Clones the current object
     * @return An exact duplicate of the current object.
     */
    TriangleSubGeometry.prototype.clone = function () {
        var clone = new TriangleSubGeometry(this._concatenateArrays);
        clone.updateIndices(this._pIndices.concat());
        clone.updatePositions(this._positions.concat());
        if (this._vertexNormals && !this._autoDeriveNormals)
            clone.updateVertexNormals(this._vertexNormals.concat());
        else
            clone.updateVertexNormals(null);
        if (this._uvs && !this._autoDeriveUVs)
            clone.updateUVs(this._uvs.concat());
        else
            clone.updateUVs(null);
        if (this._vertexTangents && !this._autoDeriveTangents)
            clone.updateVertexTangents(this._vertexTangents.concat());
        else
            clone.updateVertexTangents(null);
        if (this._secondaryUVs)
            clone.updateSecondaryUVs(this._secondaryUVs.concat());
        if (this._jointIndices) {
            clone.jointsPerVertex = this._jointsPerVertex;
            clone.updateJointIndices(this._jointIndices.concat());
        }
        if (this._jointWeights)
            clone.updateJointWeights(this._jointWeights.concat());
        return clone;
    };
    TriangleSubGeometry.prototype.scaleUV = function (scaleU, scaleV) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
        var index;
        var offset;
        var stride;
        var uvs;
        uvs = this._uvs;
        var ratioU = scaleU / this._scaleU;
        var ratioV = scaleV / this._scaleV;
        this._scaleU = scaleU;
        this._scaleV = scaleV;
        var len = uvs.length;
        offset = 0;
        stride = 2;
        index = offset;
        while (index < len) {
            uvs[index] *= ratioU;
            uvs[index + 1] *= ratioV;
            index += stride;
        }
        this.notifyUVsUpdate();
    };
    /**
     * Scales the geometry.
     * @param scale The amount by which to scale.
     */
    TriangleSubGeometry.prototype.scale = function (scale) {
        var i;
        var index;
        var offset;
        var stride;
        var positions;
        positions = this._positions;
        var len = positions.length;
        offset = 0;
        stride = 3;
        i = 0;
        index = offset;
        while (i < len) {
            positions[index] *= scale;
            positions[index + 1] *= scale;
            positions[index + 2] *= scale;
            i += 3;
            index += stride;
        }
        this.notifyPositionsUpdate();
    };
    TriangleSubGeometry.prototype.applyTransformation = function (transform) {
        var positions;
        var normals;
        var tangents;
        if (this._concatenateArrays) {
            positions = this._pVertices;
            normals = this._pVertices;
            tangents = this._pVertices;
        }
        else {
            positions = this._positions;
            normals = this._vertexNormals;
            tangents = this._vertexTangents;
        }
        var len = this._positions.length / 3;
        var i;
        var i1;
        var i2;
        var vector = new Vector3D();
        var bakeNormals = this._vertexNormals != null;
        var bakeTangents = this._vertexTangents != null;
        var invTranspose;
        if (bakeNormals || bakeTangents) {
            invTranspose = transform.clone();
            invTranspose.invert();
            invTranspose.transpose();
        }
        var vi0 = this.getOffset(TriangleSubGeometry.POSITION_DATA);
        var ni0 = this.getOffset(TriangleSubGeometry.NORMAL_DATA);
        var ti0 = this.getOffset(TriangleSubGeometry.TANGENT_DATA);
        var vStride = this.getStride(TriangleSubGeometry.POSITION_DATA);
        var nStride = this.getStride(TriangleSubGeometry.NORMAL_DATA);
        var tStride = this.getStride(TriangleSubGeometry.TANGENT_DATA);
        for (i = 0; i < len; ++i) {
            i1 = vi0 + 1;
            i2 = vi0 + 2;
            // bake position
            vector.x = positions[vi0];
            vector.y = positions[i1];
            vector.z = positions[i2];
            vector = transform.transformVector(vector);
            positions[vi0] = vector.x;
            positions[i1] = vector.y;
            positions[i2] = vector.z;
            vi0 += vStride;
            // bake normal
            if (bakeNormals) {
                i1 = ni0 + 1;
                i2 = ni0 + 2;
                vector.x = normals[ni0];
                vector.y = normals[i1];
                vector.z = normals[i2];
                vector = invTranspose.deltaTransformVector(vector);
                vector.normalize();
                normals[ni0] = vector.x;
                normals[i1] = vector.y;
                normals[i2] = vector.z;
                ni0 += nStride;
            }
            // bake tangent
            if (bakeTangents) {
                i1 = ti0 + 1;
                i2 = ti0 + 2;
                vector.x = tangents[ti0];
                vector.y = tangents[i1];
                vector.z = tangents[i2];
                vector = invTranspose.deltaTransformVector(vector);
                vector.normalize();
                tangents[ti0] = vector.x;
                tangents[i1] = vector.y;
                tangents[i2] = vector.z;
                ti0 += tStride;
            }
        }
        this.notifyPositionsUpdate();
        this.notifyNormalsUpdate();
        this.notifyTangentsUpdate();
    };
    /**
     * Updates the tangents for each face.
     */
    TriangleSubGeometry.prototype.updateFaceTangents = function () {
        var i = 0;
        var index1;
        var index2;
        var index3;
        var vi;
        var v0;
        var dv1;
        var dv2;
        var denom;
        var x0, y0, z0;
        var dx1, dy1, dz1;
        var dx2, dy2, dz2;
        var cx, cy, cz;
        var positions = this._positions;
        var uvs = this._uvs;
        var len = this._pIndices.length;
        if (this._faceTangents == null)
            this._faceTangents = new Array(len);
        while (i < len) {
            index1 = this._pIndices[i];
            index2 = this._pIndices[i + 1];
            index3 = this._pIndices[i + 2];
            v0 = uvs[index1 * 2 + 1];
            dv1 = uvs[index2 * 2 + 1] - v0;
            dv2 = uvs[index3 * 2 + 1] - v0;
            vi = index1 * 3;
            x0 = positions[vi];
            y0 = positions[vi + 1];
            z0 = positions[vi + 2];
            vi = index2 * 3;
            dx1 = positions[vi] - x0;
            dy1 = positions[vi + 1] - y0;
            dz1 = positions[vi + 2] - z0;
            vi = index3 * 3;
            dx2 = positions[vi] - x0;
            dy2 = positions[vi + 1] - y0;
            dz2 = positions[vi + 2] - z0;
            cx = dv2 * dx1 - dv1 * dx2;
            cy = dv2 * dy1 - dv1 * dy2;
            cz = dv2 * dz1 - dv1 * dz2;
            denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
            this._faceTangents[i++] = denom * cx;
            this._faceTangents[i++] = denom * cy;
            this._faceTangents[i++] = denom * cz;
        }
        this._faceTangentsDirty = false;
    };
    /**
     * Updates the normals for each face.
     */
    TriangleSubGeometry.prototype.updateFaceNormals = function () {
        var i = 0;
        var j = 0;
        var k = 0;
        var index;
        var offset;
        var stride;
        var x1, x2, x3;
        var y1, y2, y3;
        var z1, z2, z3;
        var dx1, dy1, dz1;
        var dx2, dy2, dz2;
        var cx, cy, cz;
        var d;
        var positions = this._positions;
        var len = this._pIndices.length;
        if (this._faceNormals == null)
            this._faceNormals = new Array(len);
        if (this._useFaceWeights && this._faceWeights == null)
            this._faceWeights = new Array(len / 3);
        while (i < len) {
            index = this._pIndices[i++] * 3;
            x1 = positions[index];
            y1 = positions[index + 1];
            z1 = positions[index + 2];
            index = this._pIndices[i++] * 3;
            x2 = positions[index];
            y2 = positions[index + 1];
            z2 = positions[index + 2];
            index = this._pIndices[i++] * 3;
            x3 = positions[index];
            y3 = positions[index + 1];
            z3 = positions[index + 2];
            dx1 = x3 - x1;
            dy1 = y3 - y1;
            dz1 = z3 - z1;
            dx2 = x2 - x1;
            dy2 = y2 - y1;
            dz2 = z2 - z1;
            cx = dz1 * dy2 - dy1 * dz2;
            cy = dx1 * dz2 - dz1 * dx2;
            cz = dy1 * dx2 - dx1 * dy2;
            d = Math.sqrt(cx * cx + cy * cy + cz * cz);
            // length of cross product = 2*triangle area
            if (this._useFaceWeights) {
                var w = d * 10000;
                if (w < 1)
                    w = 1;
                this._faceWeights[k++] = w;
            }
            d = 1 / d;
            this._faceNormals[j++] = cx * d;
            this._faceNormals[j++] = cy * d;
            this._faceNormals[j++] = cz * d;
        }
        this._faceNormalsDirty = false;
    };
    TriangleSubGeometry.prototype._pNotifyVerticesUpdate = function () {
        this._pStrideOffsetDirty = true;
        this.notifyPositionsUpdate();
        this.notifyNormalsUpdate();
        this.notifyTangentsUpdate();
        this.notifyUVsUpdate();
        this.notifySecondaryUVsUpdate();
        this.notifyJointIndicesUpdate();
        this.notifyJointWeightsUpdate();
    };
    TriangleSubGeometry.prototype.notifyPositionsUpdate = function () {
        if (this._positionsDirty)
            return;
        this._positionsDirty = true;
        if (!this._positionsUpdated)
            this._positionsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.POSITION_DATA);
        this.dispatchEvent(this._positionsUpdated);
    };
    TriangleSubGeometry.prototype.notifyNormalsUpdate = function () {
        if (this._vertexNormalsDirty)
            return;
        this._vertexNormalsDirty = true;
        if (!this._normalsUpdated)
            this._normalsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.NORMAL_DATA);
        this.dispatchEvent(this._normalsUpdated);
    };
    TriangleSubGeometry.prototype.notifyTangentsUpdate = function () {
        if (this._vertexTangentsDirty)
            return;
        this._vertexTangentsDirty = true;
        if (!this._tangentsUpdated)
            this._tangentsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.TANGENT_DATA);
        this.dispatchEvent(this._tangentsUpdated);
    };
    TriangleSubGeometry.prototype.notifyUVsUpdate = function () {
        if (this._uvsDirty)
            return;
        this._uvsDirty = true;
        if (!this._uvsUpdated)
            this._uvsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.UV_DATA);
        this.dispatchEvent(this._uvsUpdated);
    };
    TriangleSubGeometry.prototype.notifySecondaryUVsUpdate = function () {
        if (this._secondaryUVsDirty)
            return;
        this._secondaryUVsDirty = true;
        if (!this._secondaryUVsUpdated)
            this._secondaryUVsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.SECONDARY_UV_DATA);
        this.dispatchEvent(this._secondaryUVsUpdated);
    };
    TriangleSubGeometry.prototype.notifyJointIndicesUpdate = function () {
        if (this._jointIndicesDirty)
            return;
        this._jointIndicesDirty = true;
        if (!this._jointIndicesUpdated)
            this._jointIndicesUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.JOINT_INDEX_DATA);
        this.dispatchEvent(this._jointIndicesUpdated);
    };
    TriangleSubGeometry.prototype.notifyJointWeightsUpdate = function () {
        if (this._jointWeightsDirty)
            return;
        this._jointWeightsDirty = true;
        if (!this._jointWeightsUpdated)
            this._jointWeightsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.JOINT_WEIGHT_DATA);
        this.dispatchEvent(this._jointWeightsUpdated);
    };
    TriangleSubGeometry.POSITION_DATA = "positions";
    TriangleSubGeometry.NORMAL_DATA = "vertexNormals";
    TriangleSubGeometry.TANGENT_DATA = "vertexTangents";
    TriangleSubGeometry.UV_DATA = "uvs";
    TriangleSubGeometry.SECONDARY_UV_DATA = "secondaryUVs";
    TriangleSubGeometry.JOINT_INDEX_DATA = "jointIndices";
    TriangleSubGeometry.JOINT_WEIGHT_DATA = "jointWeights";
    //TODO - move these to StageGL
    TriangleSubGeometry.POSITION_FORMAT = "float3";
    TriangleSubGeometry.NORMAL_FORMAT = "float3";
    TriangleSubGeometry.TANGENT_FORMAT = "float3";
    TriangleSubGeometry.UV_FORMAT = "float2";
    TriangleSubGeometry.SECONDARY_UV_FORMAT = "float2";
    return TriangleSubGeometry;
})(SubGeometryBase);
module.exports = TriangleSubGeometry;


},{"awayjs-core/lib/geom/Vector3D":189,"awayjs-display/lib/base/SubGeometryBase":158,"awayjs-display/lib/base/TriangleSubMesh":162,"awayjs-display/lib/events/SubGeometryEvent":168}],162:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var SubMeshBase = require("awayjs-display/lib/base/SubMeshBase");
/**
 * TriangleSubMesh wraps a TriangleSubGeometry as a scene graph instantiation. A TriangleSubMesh is owned by a Mesh object.
 *
 *
 * @see away.base.TriangleSubGeometry
 * @see away.entities.Mesh
 *
 * @class away.base.TriangleSubMesh
 */
var TriangleSubMesh = (function (_super) {
    __extends(TriangleSubMesh, _super);
    /**
     * Creates a new TriangleSubMesh object
     * @param subGeometry The TriangleSubGeometry object which provides the geometry data for this TriangleSubMesh.
     * @param parentMesh The Mesh object to which this TriangleSubMesh belongs.
     * @param material An optional material used to render this TriangleSubMesh.
     */
    function TriangleSubMesh(subGeometry, parentMesh, material) {
        if (material === void 0) { material = null; }
        _super.call(this);
        this._pParentMesh = parentMesh;
        this._subGeometry = subGeometry;
        this.material = material;
    }
    Object.defineProperty(TriangleSubMesh.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return AssetType.TRIANGLE_SUB_MESH;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleSubMesh.prototype, "subGeometry", {
        /**
         * The TriangleSubGeometry object which provides the geometry data for this TriangleSubMesh.
         */
        get: function () {
            return this._subGeometry;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    TriangleSubMesh.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    TriangleSubMesh.prototype._iCollectRenderable = function (renderer) {
        renderer.applyTriangleSubMesh(this);
    };
    return TriangleSubMesh;
})(SubMeshBase);
module.exports = TriangleSubMesh;


},{"awayjs-core/lib/library/AssetType":190,"awayjs-display/lib/base/SubMeshBase":159}],163:[function(require,module,exports){
module.exports=require(62)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/containers/DisplayObjectContainer.js":62,"awayjs-core/lib/errors/ArgumentError":175,"awayjs-core/lib/errors/Error":176,"awayjs-core/lib/errors/RangeError":178,"awayjs-core/lib/library/AssetType":190,"awayjs-display/lib/base/DisplayObject":155}],164:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var Geometry = require("awayjs-display/lib/base/Geometry");
var DisplayObjectContainer = require("awayjs-display/lib/containers/DisplayObjectContainer");
var EntityNode = require("awayjs-display/lib/partition/EntityNode");
var GeometryEvent = require("awayjs-display/lib/events/GeometryEvent");
/**
 * Mesh is an instance of a Geometry, augmenting it with a presence in the scene graph, a material, and an animation
 * state. It consists out of SubMeshes, which in turn correspond to SubGeometries. SubMeshes allow different parts
 * of the geometry to be assigned different materials.
 */
var Mesh = (function (_super) {
    __extends(Mesh, _super);
    /**
     * Create a new Mesh object.
     *
     * @param geometry                    The geometry used by the mesh that provides it with its shape.
     * @param material    [optional]        The material with which to render the Mesh.
     */
    function Mesh(geometry, material) {
        var _this = this;
        if (material === void 0) { material = null; }
        _super.call(this);
        this._castsShadows = true;
        this._shareAnimationGeometry = true;
        this._pIsEntity = true;
        this._subMeshes = new Array();
        this._onGeometryBoundsInvalidDelegate = function (event) { return _this.onGeometryBoundsInvalid(event); };
        this._onSubGeometryAddedDelegate = function (event) { return _this.onSubGeometryAdded(event); };
        this._onSubGeometryRemovedDelegate = function (event) { return _this.onSubGeometryRemoved(event); };
        //this should never happen, but if people insist on trying to create their meshes before they have geometry to fill it, it becomes necessary
        this.geometry = geometry || new Geometry();
        this.material = material;
    }
    Object.defineProperty(Mesh.prototype, "animator", {
        /**
         * Defines the animator of the mesh. Act on the mesh's geometry.  Default value is <code>null</code>.
         */
        get: function () {
            return this._animator;
        },
        set: function (value) {
            if (this._animator)
                this._animator.removeOwner(this);
            this._animator = value;
            var len = this._subMeshes.length;
            var subMesh;
            for (var i = 0; i < len; ++i) {
                subMesh = this._subMeshes[i];
                // cause material to be unregistered and registered again to work with the new animation type (if possible)
                if (subMesh.material) {
                    subMesh.material.iRemoveOwner(subMesh);
                    subMesh.material.iAddOwner(subMesh);
                }
                //invalidate any existing renderables in case they need to pull new geometry
                subMesh._iInvalidateRenderableGeometry();
            }
            if (this._animator)
                this._animator.addOwner(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return AssetType.MESH;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "castsShadows", {
        /**
         * Indicates whether or not the Mesh can cast shadows. Default value is <code>true</code>.
         */
        get: function () {
            return this._castsShadows;
        },
        set: function (value) {
            this._castsShadows = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "geometry", {
        /**
         * The geometry used by the mesh that provides it with its shape.
         */
        get: function () {
            if (this._iSourcePrefab)
                this._iSourcePrefab._iValidate();
            return this._geometry;
        },
        set: function (value) {
            var i;
            if (this._geometry) {
                this._geometry.removeEventListener(GeometryEvent.BOUNDS_INVALID, this._onGeometryBoundsInvalidDelegate);
                this._geometry.removeEventListener(GeometryEvent.SUB_GEOMETRY_ADDED, this._onSubGeometryAddedDelegate);
                this._geometry.removeEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED, this._onSubGeometryRemovedDelegate);
                for (i = 0; i < this._subMeshes.length; ++i)
                    this._subMeshes[i].dispose();
                this._subMeshes.length = 0;
            }
            this._geometry = value;
            if (this._geometry) {
                this._geometry.addEventListener(GeometryEvent.BOUNDS_INVALID, this._onGeometryBoundsInvalidDelegate);
                this._geometry.addEventListener(GeometryEvent.SUB_GEOMETRY_ADDED, this._onSubGeometryAddedDelegate);
                this._geometry.addEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED, this._onSubGeometryRemovedDelegate);
                var subGeoms = this._geometry.subGeometries;
                for (i = 0; i < subGeoms.length; ++i)
                    this.addSubMesh(subGeoms[i]);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "material", {
        /**
         * The material with which to render the Mesh.
         */
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (value == this._material)
                return;
            var i;
            var len = this._subMeshes.length;
            var subMesh;
            for (i = 0; i < len; i++)
                if (this._material && (subMesh = this._subMeshes[i]).material == this._material)
                    this._material.iRemoveOwner(subMesh);
            this._material = value;
            for (i = 0; i < len; i++)
                if (this._material && (subMesh = this._subMeshes[i]).material == this._material)
                    this._material.iAddOwner(subMesh);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "shareAnimationGeometry", {
        /**
         * Indicates whether or not the mesh share the same animation geometry.
         */
        get: function () {
            return this._shareAnimationGeometry;
        },
        set: function (value) {
            this._shareAnimationGeometry = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "subMeshes", {
        /**
         * The SubMeshes out of which the Mesh consists. Every SubMesh can be assigned a material to override the Mesh's
         * material.
         */
        get: function () {
            // Since this getter is invoked every iteration of the render loop, and
            // the prefab construct could affect the sub-meshes, the prefab is
            // validated here to give it a chance to rebuild.
            if (this._iSourcePrefab)
                this._iSourcePrefab._iValidate();
            return this._subMeshes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "uvTransform", {
        /**
         *
         */
        get: function () {
            return this._uvTransform;
        },
        set: function (value) {
            this._uvTransform = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    Mesh.prototype.bakeTransformations = function () {
        this.geometry.applyTransformation(this._iMatrix3D);
        this._iMatrix3D.identity();
    };
    /**
     * @inheritDoc
     */
    Mesh.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.material = null;
        this.geometry = null;
    };
    /**
     * Disposes mesh including the animator and children. This is a merely a convenience method.
     * @return
     */
    Mesh.prototype.disposeWithAnimatorAndChildren = function () {
        this.disposeWithChildren();
        if (this._animator)
            this._animator.dispose();
    };
    /**
     * Clones this Mesh instance along with all it's children, while re-using the same
     * material, geometry and animation set. The returned result will be a copy of this mesh,
     * containing copies of all of it's children.
     *
     * Properties that are re-used (i.e. not cloned) by the new copy include name,
     * geometry, and material. Properties that are cloned or created anew for the copy
     * include subMeshes, children of the mesh, and the animator.
     *
     * If you want to copy just the mesh, reusing it's geometry and material while not
     * cloning it's children, the simplest way is to create a new mesh manually:
     *
     * <code>
     * var clone : Mesh = new Mesh(original.geometry, original.material);
     * </code>
     */
    Mesh.prototype.clone = function () {
        var clone = new Mesh(this._geometry, this._material);
        clone._iMatrix3D = this._iMatrix3D;
        clone.pivot = this.pivot;
        clone.partition = this.partition;
        clone.bounds = this.bounds.clone();
        clone.name = this.name;
        clone.castsShadows = this.castsShadows;
        clone.shareAnimationGeometry = this.shareAnimationGeometry;
        clone.mouseEnabled = this.mouseEnabled;
        clone.mouseChildren = this.mouseChildren;
        //this is of course no proper cloning
        //maybe use this instead?: http://blog.another-d-mention.ro/programming/how-to-clone-duplicate-an-object-in-actionscript-3/
        clone.extra = this.extra;
        var len = this._subMeshes.length;
        for (var i = 0; i < len; ++i)
            clone._subMeshes[i].material = this._subMeshes[i]._iGetExplicitMaterial();
        len = this.numChildren;
        var obj;
        for (i = 0; i < len; ++i) {
            obj = this.getChildAt(i).clone();
            clone.addChild(obj);
        }
        if (this._animator)
            clone.animator = this._animator.clone();
        return clone;
    };
    /**
     * //TODO
     *
     * @param subGeometry
     * @returns {SubMeshBase}
     */
    Mesh.prototype.getSubMeshFromSubGeometry = function (subGeometry) {
        return this._subMeshes[this._geometry.subGeometries.indexOf(subGeometry)];
    };
    /**
     * @protected
     */
    Mesh.prototype.pCreateEntityPartitionNode = function () {
        return new EntityNode(this);
    };
    /**
     * //TODO
     *
     * @protected
     */
    Mesh.prototype.pUpdateBounds = function () {
        var i, j, p;
        var subGeoms = this._geometry.subGeometries;
        var subGeom;
        var boundingPositions;
        var numSubGeoms = subGeoms.length;
        var minX, minY, minZ;
        var maxX, maxY, maxZ;
        if (numSubGeoms > 0) {
            i = 0;
            subGeom = subGeoms[0];
            boundingPositions = subGeom.getBoundingPositions();
            minX = maxX = boundingPositions[i];
            minY = maxY = boundingPositions[i + 1];
            minZ = maxZ = boundingPositions[i + 2];
            j = numSubGeoms;
            while (j--) {
                subGeom = subGeoms[j];
                boundingPositions = subGeom.getBoundingPositions();
                i = boundingPositions.length;
                while (i--) {
                    p = boundingPositions[i];
                    if (p < minX)
                        minX = p;
                    else if (p > maxX)
                        maxX = p;
                    p = boundingPositions[i + 1];
                    if (p < minY)
                        minY = p;
                    else if (p > maxY)
                        maxY = p;
                    p = boundingPositions[i + 2];
                    if (p < minZ)
                        minZ = p;
                    else if (p > maxZ)
                        maxZ = p;
                }
            }
            this._pBounds.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
        }
        else {
            this._pBounds.fromExtremes(0, 0, 0, 0, 0, 0);
        }
        _super.prototype.pUpdateBounds.call(this);
    };
    /**
     * //TODO
     *
     * @private
     */
    Mesh.prototype.onGeometryBoundsInvalid = function (event) {
        this.pInvalidateBounds();
    };
    /**
     * Called when a SubGeometry was added to the Geometry.
     *
     * @private
     */
    Mesh.prototype.onSubGeometryAdded = function (event) {
        this.addSubMesh(event.subGeometry);
    };
    /**
     * Called when a SubGeometry was removed from the Geometry.
     *
     * @private
     */
    Mesh.prototype.onSubGeometryRemoved = function (event) {
        var subMesh;
        var subGeom = event.subGeometry;
        var len = this._subMeshes.length;
        var i;
        for (i = 0; i < len; ++i) {
            subMesh = this._subMeshes[i];
            if (subMesh.subGeometry == subGeom) {
                subMesh.dispose();
                this._subMeshes.splice(i, 1);
                break;
            }
        }
        --len;
        for (; i < len; ++i)
            this._subMeshes[i]._iIndex = i;
    };
    /**
     * Adds a SubMeshBase wrapping a SubGeometry.
     *
     * @param subGeometry
     */
    Mesh.prototype.addSubMesh = function (subGeometry) {
        var SubMeshClass = subGeometry.subMeshClass;
        var subMesh = new SubMeshClass(subGeometry, this, null);
        var len = this._subMeshes.length;
        subMesh._iIndex = len;
        this._subMeshes[len] = subMesh;
        this.pInvalidateBounds();
    };
    /**
     * //TODO
     *
     * @param shortestCollisionDistance
     * @param findClosest
     * @returns {boolean}
     *
     * @internal
     */
    Mesh.prototype._iTestCollision = function (shortestCollisionDistance, findClosest) {
        return this._pPickingCollider.testMeshCollision(this, this._pPickingCollisionVO, shortestCollisionDistance, findClosest);
    };
    /**
     *
     * @param renderer
     *
     * @internal
     */
    Mesh.prototype._iCollectRenderables = function (renderer) {
        // Since this getter is invoked every iteration of the render loop, and
        // the prefab construct could affect the sub-meshes, the prefab is
        // validated here to give it a chance to rebuild.
        if (this._iSourcePrefab)
            this._iSourcePrefab._iValidate();
        var len = this._subMeshes.length;
        for (var i = 0; i < len; i++)
            this._subMeshes[i]._iCollectRenderable(renderer);
    };
    Mesh.prototype._iInvalidateRenderableGeometries = function () {
        var len = this._subMeshes.length;
        for (var i = 0; i < len; ++i)
            this._subMeshes[i]._iInvalidateRenderableGeometry();
    };
    return Mesh;
})(DisplayObjectContainer);
module.exports = Mesh;


},{"awayjs-core/lib/library/AssetType":190,"awayjs-display/lib/base/Geometry":156,"awayjs-display/lib/containers/DisplayObjectContainer":163,"awayjs-display/lib/events/GeometryEvent":166,"awayjs-display/lib/partition/EntityNode":169}],165:[function(require,module,exports){
module.exports=require(70)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/DisplayObjectEvent.js":70,"awayjs-core/lib/events/Event":180}],166:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
/**
* Dispatched to notify changes in a geometry object's state.
*
* @class away.events.GeometryEvent
* @see away3d.core.base.Geometry
*/
var GeometryEvent = (function (_super) {
    __extends(GeometryEvent, _super);
    /**
     * Create a new GeometryEvent
     * @param type The event type.
     * @param subGeometry An optional TriangleSubGeometry object that is the subject of this event.
     */
    function GeometryEvent(type, subGeometry) {
        if (subGeometry === void 0) { subGeometry = null; }
        _super.call(this, type);
        this._subGeometry = subGeometry;
    }
    Object.defineProperty(GeometryEvent.prototype, "subGeometry", {
        /**
         * The TriangleSubGeometry object that is the subject of this event, if appropriate.
         */
        get: function () {
            return this._subGeometry;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     * @return An exact duplicate of the current object.
     */
    GeometryEvent.prototype.clone = function () {
        return new GeometryEvent(this.type, this._subGeometry);
    };
    /**
     * Dispatched when a TriangleSubGeometry was added to the dispatching Geometry.
     */
    GeometryEvent.SUB_GEOMETRY_ADDED = "SubGeometryAdded";
    /**
     * Dispatched when a TriangleSubGeometry was removed from the dispatching Geometry.
     */
    GeometryEvent.SUB_GEOMETRY_REMOVED = "SubGeometryRemoved";
    GeometryEvent.BOUNDS_INVALID = "BoundsInvalid";
    return GeometryEvent;
})(Event);
module.exports = GeometryEvent;


},{"awayjs-core/lib/events/Event":180}],167:[function(require,module,exports){
module.exports=require(74)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/SceneEvent.js":74,"awayjs-core/lib/events/Event":180}],168:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
/**
 * Dispatched to notify changes in a sub geometry object's state.
 *
 * @class away.events.SubGeometryEvent
 * @see away.core.base.Geometry
 */
var SubGeometryEvent = (function (_super) {
    __extends(SubGeometryEvent, _super);
    /**
     * Create a new GeometryEvent
     * @param type The event type.
     * @param dataType An optional data type of the vertex data being updated.
     */
    function SubGeometryEvent(type, dataType) {
        if (dataType === void 0) { dataType = ""; }
        _super.call(this, type);
        this._dataType = dataType;
    }
    Object.defineProperty(SubGeometryEvent.prototype, "dataType", {
        /**
         * The data type of the vertex data.
         */
        get: function () {
            return this._dataType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    SubGeometryEvent.prototype.clone = function () {
        return new SubGeometryEvent(this.type, this._dataType);
    };
    /**
     * Dispatched when a TriangleSubGeometry's index data has been updated.
     */
    SubGeometryEvent.INDICES_UPDATED = "indicesUpdated";
    /**
     * Dispatched when a TriangleSubGeometry's vertex data has been updated.
     */
    SubGeometryEvent.VERTICES_UPDATED = "verticesUpdated";
    return SubGeometryEvent;
})(Event);
module.exports = SubGeometryEvent;


},{"awayjs-core/lib/events/Event":180}],169:[function(require,module,exports){
module.exports=require(83)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/EntityNode.js":83,"awayjs-core/lib/errors/PartialImplementationError":177,"awayjs-display/lib/partition/NodeBase":170}],170:[function(require,module,exports){
module.exports=require(85)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/NodeBase.js":85}],171:[function(require,module,exports){
module.exports=require(89)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pick/PickingCollisionVO.js":89}],172:[function(require,module,exports){
module.exports=require(97)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/AxisAlignedBoundingBox.js":97,"awayjs-core/lib/bounds/BoundingVolumeBase":173,"awayjs-core/lib/geom/Matrix3DUtils":185,"awayjs-core/lib/geom/PlaneClassification":187,"awayjs-core/lib/geom/Vector3D":189}],173:[function(require,module,exports){
module.exports=require(99)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/BoundingVolumeBase.js":99,"awayjs-core/lib/errors/AbstractMethodError":174,"awayjs-core/lib/geom/Box":182}],174:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":176}],175:[function(require,module,exports){
module.exports=require(4)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/ArgumentError.js":4,"awayjs-core/lib/errors/Error":176}],176:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],177:[function(require,module,exports){
module.exports=require(6)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/PartialImplementationError.js":6,"awayjs-core/lib/errors/Error":176}],178:[function(require,module,exports){
module.exports=require(105)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/errors/RangeError.js":105,"awayjs-core/lib/errors/Error":176}],179:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":180}],180:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],181:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],182:[function(require,module,exports){
module.exports=require(110)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Box.js":110,"awayjs-core/lib/geom/Vector3D":189}],183:[function(require,module,exports){
module.exports=require(111)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/MathConsts.js":111}],184:[function(require,module,exports){
module.exports=require(113)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3D.js":113,"awayjs-core/lib/errors/ArgumentError":175,"awayjs-core/lib/geom/Orientation3D":186,"awayjs-core/lib/geom/Vector3D":189}],185:[function(require,module,exports){
module.exports=require(114)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3DUtils.js":114,"awayjs-core/lib/geom/Matrix3D":184,"awayjs-core/lib/geom/Vector3D":189}],186:[function(require,module,exports){
module.exports=require(115)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Orientation3D.js":115}],187:[function(require,module,exports){
module.exports=require(117)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/PlaneClassification.js":117}],188:[function(require,module,exports){
module.exports=require(17)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Point.js":17}],189:[function(require,module,exports){
module.exports=require(19)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Vector3D.js":19}],190:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],191:[function(require,module,exports){
module.exports=require(31)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/NamedAssetBase.js":31,"awayjs-core/lib/errors/AbstractMethodError":174,"awayjs-core/lib/events/AssetEvent":179,"awayjs-core/lib/events/EventDispatcher":181}],192:[function(require,module,exports){
var ContextGLBlendFactor = (function () {
    function ContextGLBlendFactor() {
    }
    ContextGLBlendFactor.DESTINATION_ALPHA = "destinationAlpha";
    ContextGLBlendFactor.DESTINATION_COLOR = "destinationColor";
    ContextGLBlendFactor.ONE = "one";
    ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA = "oneMinusDestinationAlpha";
    ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR = "oneMinusDestinationColor";
    ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA = "oneMinusSourceAlpha";
    ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR = "oneMinusSourceColor";
    ContextGLBlendFactor.SOURCE_ALPHA = "sourceAlpha";
    ContextGLBlendFactor.SOURCE_COLOR = "sourceColor";
    ContextGLBlendFactor.ZERO = "zero";
    return ContextGLBlendFactor;
})();
module.exports = ContextGLBlendFactor;


},{}],193:[function(require,module,exports){
var ContextGLCompareMode = (function () {
    function ContextGLCompareMode() {
    }
    ContextGLCompareMode.ALWAYS = "always";
    ContextGLCompareMode.EQUAL = "equal";
    ContextGLCompareMode.GREATER = "greater";
    ContextGLCompareMode.GREATER_EQUAL = "greaterEqual";
    ContextGLCompareMode.LESS = "less";
    ContextGLCompareMode.LESS_EQUAL = "lessEqual";
    ContextGLCompareMode.NEVER = "never";
    ContextGLCompareMode.NOT_EQUAL = "notEqual";
    return ContextGLCompareMode;
})();
module.exports = ContextGLCompareMode;


},{}],194:[function(require,module,exports){
var ContextGLMipFilter = (function () {
    function ContextGLMipFilter() {
    }
    ContextGLMipFilter.MIPLINEAR = "miplinear";
    ContextGLMipFilter.MIPNEAREST = "mipnearest";
    ContextGLMipFilter.MIPNONE = "mipnone";
    return ContextGLMipFilter;
})();
module.exports = ContextGLMipFilter;


},{}],195:[function(require,module,exports){
var ContextGLProfile = (function () {
    function ContextGLProfile() {
    }
    ContextGLProfile.BASELINE = "baseline";
    ContextGLProfile.BASELINE_CONSTRAINED = "baselineConstrained";
    ContextGLProfile.BASELINE_EXTENDED = "baselineExtended";
    return ContextGLProfile;
})();
module.exports = ContextGLProfile;


},{}],196:[function(require,module,exports){
var ContextGLProgramType = (function () {
    function ContextGLProgramType() {
    }
    ContextGLProgramType.FRAGMENT = "fragment";
    ContextGLProgramType.VERTEX = "vertex";
    return ContextGLProgramType;
})();
module.exports = ContextGLProgramType;


},{}],197:[function(require,module,exports){
var ContextGLTextureFilter = (function () {
    function ContextGLTextureFilter() {
    }
    ContextGLTextureFilter.LINEAR = "linear";
    ContextGLTextureFilter.NEAREST = "nearest";
    return ContextGLTextureFilter;
})();
module.exports = ContextGLTextureFilter;


},{}],198:[function(require,module,exports){
var ContextGLTextureFormat = (function () {
    function ContextGLTextureFormat() {
    }
    ContextGLTextureFormat.BGRA = "bgra";
    ContextGLTextureFormat.BGRA_PACKED = "bgraPacked4444";
    ContextGLTextureFormat.BGR_PACKED = "bgrPacked565";
    ContextGLTextureFormat.COMPRESSED = "compressed";
    ContextGLTextureFormat.COMPRESSED_ALPHA = "compressedAlpha";
    return ContextGLTextureFormat;
})();
module.exports = ContextGLTextureFormat;


},{}],199:[function(require,module,exports){
var ContextGLTriangleFace = (function () {
    function ContextGLTriangleFace() {
    }
    ContextGLTriangleFace.BACK = "back";
    ContextGLTriangleFace.FRONT = "front";
    ContextGLTriangleFace.FRONT_AND_BACK = "frontAndBack";
    ContextGLTriangleFace.NONE = "none";
    return ContextGLTriangleFace;
})();
module.exports = ContextGLTriangleFace;


},{}],200:[function(require,module,exports){
var ContextGLWrapMode = (function () {
    function ContextGLWrapMode() {
    }
    ContextGLWrapMode.CLAMP = "clamp";
    ContextGLWrapMode.REPEAT = "repeat";
    return ContextGLWrapMode;
})();
module.exports = ContextGLWrapMode;


},{}],201:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var ShadingMethodEvent = (function (_super) {
    __extends(ShadingMethodEvent, _super);
    function ShadingMethodEvent(type) {
        _super.call(this, type);
    }
    ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
    return ShadingMethodEvent;
})(Event);
module.exports = ShadingMethodEvent;


},{"awayjs-core/lib/events/Event":237}],202:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var LineSubGeometry = require("awayjs-display/lib/base/LineSubGeometry");
var ContextGLProgramType = require("awayjs-stagegl/lib/base/ContextGLProgramType");
var StageGLMaterialBase = require("awayjs-stagegl/lib/materials/StageGLMaterialBase");
var LineBasicPass = require("awayjs-stagegl/lib/materials/passes/LineBasicPass");
/**
 * LineMaterial is a material exclusively used to render wireframe objects
 *
 * @see away.entities.Lines
 */
var LineBasicMaterial = (function (_super) {
    __extends(LineBasicMaterial, _super);
    /**
     * Creates a new LineMaterial object.
     *
     * @param thickness The thickness of the wireframe lines.
     */
    function LineBasicMaterial(thickness) {
        if (thickness === void 0) { thickness = 1.25; }
        _super.call(this);
        this._constants = new Array(0, 0, 0, 0);
        this._thickness = thickness;
        this.bothSides = true;
        this._pAddScreenPass(this._screenPass = new LineBasicPass());
        this._calcMatrix = new Matrix3D();
        this._constants[1] = 1 / 255;
    }
    /**
     * @inheritDoc
     */
    LineBasicMaterial.prototype._iGetVertexCode = function (shaderObject, regCache, sharedReg) {
        return "m44 vt0, va0, vc8			\n" + "m44 vt1, va1, vc8			\n" + "sub vt2, vt1, vt0 			\n" + "slt vt5.x, vt0.z, vc7.z			\n" + "sub vt5.y, vc5.x, vt5.x			\n" + "add vt4.x, vt0.z, vc7.z			\n" + "sub vt4.y, vt0.z, vt1.z			\n" + "seq vt4.z, vt4.y vc6.x			\n" + "add vt4.y, vt4.y, vt4.z			\n" + "div vt4.z, vt4.x, vt4.y			\n" + "mul vt4.xyz, vt4.zzz, vt2.xyz	\n" + "add vt3.xyz, vt0.xyz, vt4.xyz	\n" + "mov vt3.w, vc5.x			\n" + "mul vt0, vt0, vt5.yyyy			\n" + "mul vt3, vt3, vt5.xxxx			\n" + "add vt0, vt0, vt3				\n" + "sub vt2, vt1, vt0 			\n" + "nrm vt2.xyz, vt2.xyz			\n" + "nrm vt5.xyz, vt0.xyz			\n" + "mov vt5.w, vc5.x				\n" + "crs vt3.xyz, vt2, vt5			\n" + "nrm vt3.xyz, vt3.xyz			\n" + "mul vt3.xyz, vt3.xyz, va2.xxx	\n" + "mov vt3.w, vc5.x			\n" + "dp3 vt4.x, vt0, vc6			\n" + "mul vt4.x, vt4.x, vc7.x			\n" + "mul vt3.xyz, vt3.xyz, vt4.xxx	\n" + "add vt0.xyz, vt0.xyz, vt3.xyz	\n" + "m44 op, vt0, vc0			\n" + "mov v0, va3				\n";
    };
    /**
     * @inheritDoc
     */
    LineBasicMaterial.prototype._iActivatePass = function (pass, stage, camera) {
        _super.prototype._iActivatePass.call(this, pass, stage, camera);
        var context = stage.context;
        this._constants[0] = this._thickness / ((stage.scissorRect) ? Math.min(stage.scissorRect.width, stage.scissorRect.height) : Math.min(stage.width, stage.height));
        // value to convert distance from camera to model length per pixel width
        this._constants[2] = camera.projection.near;
        context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 5, LineBasicMaterial.pONE_VECTOR, 1);
        context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 6, LineBasicMaterial.pFRONT_VECTOR, 1);
        context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 7, this._constants, 1);
        // projection matrix
        context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, camera.projection.matrix, true);
    };
    /**
     * @inheritDoc
     */
    LineBasicMaterial.prototype._iRenderPass = function (pass, renderable, stage, camera, viewProjection) {
        _super.prototype._iRenderPass.call(this, pass, renderable, stage, camera, viewProjection);
        var context = stage.context;
        this._calcMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
        this._calcMatrix.append(camera.inverseSceneTransform);
        context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 8, this._calcMatrix, true);
        context.activateBuffer(0, renderable.getVertexData(LineSubGeometry.START_POSITION_DATA), renderable.getVertexOffset(LineSubGeometry.START_POSITION_DATA), LineSubGeometry.POSITION_FORMAT);
        context.activateBuffer(1, renderable.getVertexData(LineSubGeometry.END_POSITION_DATA), renderable.getVertexOffset(LineSubGeometry.END_POSITION_DATA), LineSubGeometry.POSITION_FORMAT);
        context.activateBuffer(2, renderable.getVertexData(LineSubGeometry.THICKNESS_DATA), renderable.getVertexOffset(LineSubGeometry.THICKNESS_DATA), LineSubGeometry.THICKNESS_FORMAT);
        context.activateBuffer(3, renderable.getVertexData(LineSubGeometry.COLOR_DATA), renderable.getVertexOffset(LineSubGeometry.COLOR_DATA), LineSubGeometry.COLOR_FORMAT);
        context.drawTriangles(context.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
    };
    LineBasicMaterial.pONE_VECTOR = Array(1, 1, 1, 1);
    LineBasicMaterial.pFRONT_VECTOR = Array(0, 0, -1, 0);
    return LineBasicMaterial;
})(StageGLMaterialBase);
module.exports = LineBasicMaterial;


},{"awayjs-core/lib/geom/Matrix3D":241,"awayjs-display/lib/base/LineSubGeometry":259,"awayjs-stagegl/lib/base/ContextGLProgramType":196,"awayjs-stagegl/lib/materials/StageGLMaterialBase":203,"awayjs-stagegl/lib/materials/passes/LineBasicPass":225}],203:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var MaterialBase = require("awayjs-display/lib/materials/MaterialBase");
var StageGLMaterialBase = (function (_super) {
    __extends(StageGLMaterialBase, _super);
    function StageGLMaterialBase() {
        _super.apply(this, arguments);
    }
    StageGLMaterialBase.prototype._iGetVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    StageGLMaterialBase.prototype._iGetFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    return StageGLMaterialBase;
})(MaterialBase);
module.exports = StageGLMaterialBase;


},{"awayjs-display/lib/materials/MaterialBase":279}],204:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Texture2DBase = require("awayjs-core/lib/textures/Texture2DBase");
var BlendMode = require("awayjs-display/lib/base/BlendMode");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
var TriangleBasicPass = require("awayjs-stagegl/lib/materials/passes/TriangleBasicPass");
var TriangleMaterialBase = require("awayjs-stagegl/lib/materials/TriangleMaterialBase");
/**
 * TriangleMaterial forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var TriangleBasicMaterial = (function (_super) {
    __extends(TriangleBasicMaterial, _super);
    function TriangleBasicMaterial(textureColor, smoothAlpha, repeat, mipmap) {
        if (textureColor === void 0) { textureColor = null; }
        if (smoothAlpha === void 0) { smoothAlpha = null; }
        if (repeat === void 0) { repeat = false; }
        if (mipmap === void 0) { mipmap = false; }
        _super.call(this);
        this._alphaBlending = false;
        this._alpha = 1;
        this._depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
        this._screenPass = new TriangleBasicPass();
        if (textureColor instanceof Texture2DBase) {
            this.texture = textureColor;
            this.smooth = (smoothAlpha == null) ? true : false;
            this.repeat = repeat;
            this.mipmap = mipmap;
        }
        else {
            this.color = textureColor ? Number(textureColor) : 0xCCCCCC;
            this.alpha = (smoothAlpha == null) ? 1 : Number(smoothAlpha);
        }
    }
    Object.defineProperty(TriangleBasicMaterial.prototype, "depthCompareMode", {
        /**
         * The depth compare mode used to render the renderables using this material.
         *
         * @see away.stagegl.ContextGLCompareMode
         */
        get: function () {
            return this._depthCompareMode;
        },
        set: function (value) {
            if (this._depthCompareMode == value)
                return;
            this._depthCompareMode = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleBasicMaterial.prototype, "alpha", {
        /**
         * The alpha of the surface.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            if (this._alpha == value)
                return;
            this._alpha = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleBasicMaterial.prototype, "alphaBlending", {
        /**
         * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
         * example when using textures of foliage, consider using alphaThreshold instead.
         */
        get: function () {
            return this._alphaBlending;
        },
        set: function (value) {
            if (this._alphaBlending == value)
                return;
            this._alphaBlending = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    TriangleBasicMaterial.prototype.iUpdateMaterial = function () {
        var passesInvalid;
        if (this._pScreenPassesInvalid) {
            this.pUpdateScreenPasses();
            passesInvalid = true;
        }
        if (passesInvalid) {
            this._pClearScreenPasses();
            this._pAddScreenPass(this._screenPass);
        }
    };
    /**
     * Updates screen passes when they were found to be invalid.
     */
    TriangleBasicMaterial.prototype.pUpdateScreenPasses = function () {
        this.initPasses();
        this.setBlendAndCompareModes();
        this._pScreenPassesInvalid = false;
    };
    /**
     * Initializes all the passes and their dependent passes.
     */
    TriangleBasicMaterial.prototype.initPasses = function () {
        //
    };
    /**
     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
     */
    TriangleBasicMaterial.prototype.setBlendAndCompareModes = function () {
        this._pRequiresBlending = (this._pBlendMode != BlendMode.NORMAL || this._alphaBlending || this._alpha < 1);
        this._screenPass.depthCompareMode = this._depthCompareMode;
        this._screenPass.preserveAlpha = this._pRequiresBlending;
        this._screenPass.setBlendMode((this._pBlendMode == BlendMode.NORMAL && this._pRequiresBlending) ? BlendMode.LAYER : this._pBlendMode);
        this._screenPass.forceSeparateMVP = false;
    };
    return TriangleBasicMaterial;
})(TriangleMaterialBase);
module.exports = TriangleBasicMaterial;


},{"awayjs-core/lib/textures/Texture2DBase":251,"awayjs-display/lib/base/BlendMode":256,"awayjs-stagegl/lib/base/ContextGLCompareMode":193,"awayjs-stagegl/lib/materials/TriangleMaterialBase":205,"awayjs-stagegl/lib/materials/passes/TriangleBasicPass":228}],205:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Matrix3DUtils = require("awayjs-core/lib/geom/Matrix3DUtils");
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var ContextGLProgramType = require("awayjs-stagegl/lib/base/ContextGLProgramType");
var StageGLMaterialBase = require("awayjs-stagegl/lib/materials/StageGLMaterialBase");
/**
 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
 * using material methods to define their appearance.
 */
var TriangleMaterialBase = (function (_super) {
    __extends(TriangleMaterialBase, _super);
    function TriangleMaterialBase() {
        _super.apply(this, arguments);
    }
    TriangleMaterialBase.prototype._iGetVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = "";
        //get the projection coordinates
        var position = (shaderObject.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.localPosition;
        //reserving vertex constants for projection matrix
        var viewMatrixReg = registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        shaderObject.viewMatrixIndex = viewMatrixReg.index * 4;
        if (shaderObject.projectionDependencies > 0) {
            sharedRegisters.projectionFragment = registerCache.getFreeVarying();
            var temp = registerCache.getFreeVertexVectorTemp();
            code += "m44 " + temp + ", " + position + ", " + viewMatrixReg + "\n" + "mov " + sharedRegisters.projectionFragment + ", " + temp + "\n" + "mov op, " + temp + "\n";
        }
        else {
            code += "m44 op, " + position + ", " + viewMatrixReg + "\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    TriangleMaterialBase.prototype._iRenderPass = function (pass, renderable, stage, camera, viewProjection) {
        _super.prototype._iRenderPass.call(this, pass, renderable, stage, camera, viewProjection);
        var shaderObject = pass.shaderObject;
        if (shaderObject.sceneMatrixIndex >= 0) {
            renderable.sourceEntity.getRenderSceneTransform(camera).copyRawDataTo(shaderObject.vertexConstantData, shaderObject.sceneMatrixIndex, true);
            viewProjection.copyRawDataTo(shaderObject.vertexConstantData, shaderObject.viewMatrixIndex, true);
        }
        else {
            var matrix3D = Matrix3DUtils.CALCULATION_MATRIX;
            matrix3D.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
            matrix3D.append(viewProjection);
            matrix3D.copyRawDataTo(shaderObject.vertexConstantData, shaderObject.viewMatrixIndex, true);
        }
        var context = stage.context;
        context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 0, shaderObject.vertexConstantData, shaderObject.numUsedVertexConstants);
        context.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, shaderObject.fragmentConstantData, shaderObject.numUsedFragmentConstants);
        context.activateBuffer(0, renderable.getVertexData(TriangleSubGeometry.POSITION_DATA), renderable.getVertexOffset(TriangleSubGeometry.POSITION_DATA), TriangleSubGeometry.POSITION_FORMAT);
        context.drawTriangles(context.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
    };
    return TriangleMaterialBase;
})(StageGLMaterialBase);
module.exports = TriangleMaterialBase;


},{"awayjs-core/lib/geom/Matrix3DUtils":242,"awayjs-display/lib/base/TriangleSubGeometry":265,"awayjs-stagegl/lib/base/ContextGLProgramType":196,"awayjs-stagegl/lib/materials/StageGLMaterialBase":203}],206:[function(require,module,exports){
var TriangleMaterialMode = (function () {
    function TriangleMaterialMode() {
    }
    /**
     *
     */
    TriangleMaterialMode.SINGLE_PASS = "singlePass";
    /**
     *
     */
    TriangleMaterialMode.MULTI_PASS = "multiPass";
    return TriangleMaterialMode;
})();
module.exports = TriangleMaterialMode;


},{}],207:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ColorTransform = require("awayjs-core/lib/geom/ColorTransform");
var Texture2DBase = require("awayjs-core/lib/textures/Texture2DBase");
var BlendMode = require("awayjs-display/lib/base/BlendMode");
var StaticLightPicker = require("awayjs-display/lib/materials/lightpickers/StaticLightPicker");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
var AmbientBasicMethod = require("awayjs-stagegl/lib/materials/methods/AmbientBasicMethod");
var DiffuseBasicMethod = require("awayjs-stagegl/lib/materials/methods/DiffuseBasicMethod");
var NormalBasicMethod = require("awayjs-stagegl/lib/materials/methods/NormalBasicMethod");
var SpecularBasicMethod = require("awayjs-stagegl/lib/materials/methods/SpecularBasicMethod");
var MaterialPassMode = require("awayjs-stagegl/lib/materials/passes/MaterialPassMode");
var TriangleMethodPass = require("awayjs-stagegl/lib/materials/passes/TriangleMethodPass");
var TriangleMaterialBase = require("awayjs-stagegl/lib/materials/TriangleMaterialBase");
var TriangleMaterialMode = require("awayjs-stagegl/lib/materials/TriangleMaterialMode");
/**
 * TriangleMethodMaterial forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var TriangleMethodMaterial = (function (_super) {
    __extends(TriangleMethodMaterial, _super);
    function TriangleMethodMaterial(textureColor, smoothAlpha, repeat, mipmap) {
        if (textureColor === void 0) { textureColor = null; }
        if (smoothAlpha === void 0) { smoothAlpha = null; }
        if (repeat === void 0) { repeat = false; }
        if (mipmap === void 0) { mipmap = false; }
        _super.call(this);
        this._alphaBlending = false;
        this._alpha = 1;
        this._ambientMethod = new AmbientBasicMethod();
        this._diffuseMethod = new DiffuseBasicMethod();
        this._normalMethod = new NormalBasicMethod();
        this._specularMethod = new SpecularBasicMethod();
        this._depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
        this._materialMode = TriangleMaterialMode.SINGLE_PASS;
        if (textureColor instanceof Texture2DBase) {
            this.texture = textureColor;
            this.smooth = (smoothAlpha == null) ? true : false;
            this.repeat = repeat;
            this.mipmap = mipmap;
        }
        else {
            this.color = (textureColor == null) ? 0xFFFFFF : Number(textureColor);
            this.alpha = (smoothAlpha == null) ? 1 : Number(smoothAlpha);
        }
    }
    Object.defineProperty(TriangleMethodMaterial.prototype, "materialMode", {
        get: function () {
            return this._materialMode;
        },
        set: function (value) {
            if (this._materialMode == value)
                return;
            this._materialMode = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "depthCompareMode", {
        /**
         * The depth compare mode used to render the renderables using this material.
         *
         * @see away.stagegl.ContextGLCompareMode
         */
        get: function () {
            return this._depthCompareMode;
        },
        set: function (value) {
            if (this._depthCompareMode == value)
                return;
            this._depthCompareMode = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "alpha", {
        /**
         * The alpha of the surface.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            if (this._alpha == value)
                return;
            this._alpha = value;
            if (this._colorTransform == null)
                this._colorTransform = new ColorTransform();
            this._colorTransform.alphaMultiplier = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "colorTransform", {
        /**
         * The ColorTransform object to transform the colour of the material with. Defaults to null.
         */
        get: function () {
            return this._screenPass.colorTransform;
        },
        set: function (value) {
            this._screenPass.colorTransform = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "diffuseTexture", {
        /**
         * The texture object to use for the ambient colour.
         */
        get: function () {
            return this._diffuseMethod.texture;
        },
        set: function (value) {
            this._diffuseMethod.texture = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "ambientMethod", {
        /**
         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
         */
        get: function () {
            return this._ambientMethod;
        },
        set: function (value) {
            if (this._ambientMethod == value)
                return;
            if (value && this._ambientMethod)
                value.copyFrom(this._ambientMethod);
            this._ambientMethod = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "shadowMethod", {
        /**
         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
         */
        get: function () {
            return this._shadowMethod;
        },
        set: function (value) {
            if (this._shadowMethod == value)
                return;
            if (value && this._shadowMethod)
                value.copyFrom(this._shadowMethod);
            this._shadowMethod = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "diffuseMethod", {
        /**
         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
         */
        get: function () {
            return this._diffuseMethod;
        },
        set: function (value) {
            if (this._diffuseMethod == value)
                return;
            if (value && this._diffuseMethod)
                value.copyFrom(this._diffuseMethod);
            this._diffuseMethod = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "specularMethod", {
        /**
         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
         */
        get: function () {
            return this._specularMethod;
        },
        set: function (value) {
            if (this._specularMethod == value)
                return;
            if (value && this._specularMethod)
                value.copyFrom(this._specularMethod);
            this._specularMethod = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "normalMethod", {
        /**
         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
         */
        get: function () {
            return this._normalMethod;
        },
        set: function (value) {
            if (this._normalMethod == value)
                return;
            if (value && this._normalMethod)
                value.copyFrom(this._normalMethod);
            this._normalMethod = value;
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
     * methods added prior.
     */
    TriangleMethodMaterial.prototype.addEffectMethod = function (method) {
        if (this._screenPass == null)
            this._screenPass = new TriangleMethodPass();
        this._screenPass.addEffectMethod(method);
        this._pInvalidateScreenPasses();
    };
    Object.defineProperty(TriangleMethodMaterial.prototype, "numEffectMethods", {
        /**
         * The number of "effect" methods added to the material.
         */
        get: function () {
            return this._screenPass ? this._screenPass.numEffectMethods : 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Queries whether a given effect method was added to the material.
     *
     * @param method The method to be queried.
     * @return true if the method was added to the material, false otherwise.
     */
    TriangleMethodMaterial.prototype.hasEffectMethod = function (method) {
        return this._screenPass ? this._screenPass.hasEffectMethod(method) : false;
    };
    /**
     * Returns the method added at the given index.
     * @param index The index of the method to retrieve.
     * @return The method at the given index.
     */
    TriangleMethodMaterial.prototype.getEffectMethodAt = function (index) {
        if (this._screenPass == null)
            return null;
        return this._screenPass.getEffectMethodAt(index);
    };
    /**
     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
     * etc. The method will be applied to the result of the methods with a lower index.
     */
    TriangleMethodMaterial.prototype.addEffectMethodAt = function (method, index) {
        if (this._screenPass == null)
            this._screenPass = new TriangleMethodPass();
        this._screenPass.addEffectMethodAt(method, index);
        this._pInvalidatePasses();
    };
    /**
     * Removes an effect method from the material.
     * @param method The method to be removed.
     */
    TriangleMethodMaterial.prototype.removeEffectMethod = function (method) {
        if (this._screenPass == null)
            return;
        this._screenPass.removeEffectMethod(method);
        // reconsider
        if (this._screenPass.numEffectMethods == 0)
            this._pInvalidatePasses();
    };
    Object.defineProperty(TriangleMethodMaterial.prototype, "normalMap", {
        /**
         * The normal map to modulate the direction of the surface for each texel. The default normal method expects
         * tangent-space normal maps, but others could expect object-space maps.
         */
        get: function () {
            return this._normalMethod.normalMap;
        },
        set: function (value) {
            this._normalMethod.normalMap = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "specularMap", {
        /**
         * A specular map that defines the strength of specular reflections for each texel in the red channel,
         * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
         * specular and gloss maps from grayscale images, but correctly authored images are preferred.
         */
        get: function () {
            return this._specularMethod.texture;
        },
        set: function (value) {
            this._specularMethod.texture = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "gloss", {
        /**
         * The glossiness of the material (sharpness of the specular highlight).
         */
        get: function () {
            return this._specularMethod.gloss;
        },
        set: function (value) {
            this._specularMethod.gloss = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "ambient", {
        /**
         * The strength of the ambient reflection.
         */
        get: function () {
            return this._ambientMethod.ambient;
        },
        set: function (value) {
            this._ambientMethod.ambient = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "specular", {
        /**
         * The overall strength of the specular reflection.
         */
        get: function () {
            return this._specularMethod.specular;
        },
        set: function (value) {
            this._specularMethod.specular = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "ambientColor", {
        /**
         * The colour of the ambient reflection.
         */
        get: function () {
            return this._diffuseMethod.ambientColor;
        },
        set: function (value) {
            this._diffuseMethod.ambientColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "diffuseColor", {
        /**
         * The colour of the diffuse reflection.
         */
        get: function () {
            return this._diffuseMethod.diffuseColor;
        },
        set: function (value) {
            this._diffuseMethod.diffuseColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "specularColor", {
        /**
         * The colour of the specular reflection.
         */
        get: function () {
            return this._specularMethod.specularColor;
        },
        set: function (value) {
            this._specularMethod.specularColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "alphaBlending", {
        /**
         * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
         * example when using textures of foliage, consider using alphaThreshold instead.
         */
        get: function () {
            return this._alphaBlending;
        },
        set: function (value) {
            if (this._alphaBlending == value)
                return;
            this._alphaBlending = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    TriangleMethodMaterial.prototype._iUpdateMaterial = function () {
        if (this._pScreenPassesInvalid) {
            //Updates screen passes when they were found to be invalid.
            this._pScreenPassesInvalid = false;
            this.initPasses();
            this.setBlendAndCompareModes();
            this._pClearScreenPasses();
            if (this._materialMode == TriangleMaterialMode.MULTI_PASS) {
                if (this._casterLightPass)
                    this._pAddScreenPass(this._casterLightPass);
                if (this._nonCasterLightPasses)
                    for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
                        this._pAddScreenPass(this._nonCasterLightPasses[i]);
            }
            if (this._screenPass)
                this._pAddScreenPass(this._screenPass);
        }
    };
    /**
     * Initializes all the passes and their dependent passes.
     */
    TriangleMethodMaterial.prototype.initPasses = function () {
        // let the effects pass handle everything if there are no lights, when there are effect methods applied
        // after shading, or when the material mode is single pass.
        if (this.numLights == 0 || this.numEffectMethods > 0 || this._materialMode == TriangleMaterialMode.SINGLE_PASS)
            this.initEffectPass();
        else if (this._screenPass)
            this.removeEffectPass();
        // only use a caster light pass if shadows need to be rendered
        if (this._shadowMethod && this._materialMode == TriangleMaterialMode.MULTI_PASS)
            this.initCasterLightPass();
        else if (this._casterLightPass)
            this.removeCasterLightPass();
        // only use non caster light passes if there are lights that don't cast
        if (this.numNonCasters > 0 && this._materialMode == TriangleMaterialMode.MULTI_PASS)
            this.initNonCasterLightPasses();
        else if (this._nonCasterLightPasses)
            this.removeNonCasterLightPasses();
    };
    /**
     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
     */
    TriangleMethodMaterial.prototype.setBlendAndCompareModes = function () {
        var forceSeparateMVP = Boolean(this._casterLightPass || this._screenPass);
        // caster light pass is always first if it exists, hence it uses normal blending
        if (this._casterLightPass) {
            this._casterLightPass.forceSeparateMVP = forceSeparateMVP;
            this._casterLightPass.setBlendMode(BlendMode.NORMAL);
            this._casterLightPass.depthCompareMode = this._depthCompareMode;
        }
        if (this._nonCasterLightPasses) {
            var firstAdditiveIndex = 0;
            // if there's no caster light pass, the first non caster light pass will be the first
            // and should use normal blending
            if (!this._casterLightPass) {
                this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;
                this._nonCasterLightPasses[0].setBlendMode(BlendMode.NORMAL);
                this._nonCasterLightPasses[0].depthCompareMode = this._depthCompareMode;
                firstAdditiveIndex = 1;
            }
            for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {
                this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;
                this._nonCasterLightPasses[i].setBlendMode(BlendMode.ADD);
                this._nonCasterLightPasses[i].depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
            }
        }
        if (this._casterLightPass || this._nonCasterLightPasses) {
            //cannot be blended by blendmode property if multipass enabled
            this._pRequiresBlending = false;
            // there are light passes, so this should be blended in
            if (this._screenPass) {
                this._screenPass.passMode = MaterialPassMode.EFFECTS;
                this._screenPass.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
                this._screenPass.setBlendMode(BlendMode.LAYER);
                this._screenPass.forceSeparateMVP = forceSeparateMVP;
            }
        }
        else if (this._screenPass) {
            this._pRequiresBlending = (this._pBlendMode != BlendMode.NORMAL || this._alphaBlending || (this._colorTransform && this._colorTransform.alphaMultiplier < 1));
            // effects pass is the only pass, so it should just blend normally
            this._screenPass.passMode = MaterialPassMode.SUPER_SHADER;
            this._screenPass.depthCompareMode = this._depthCompareMode;
            this._screenPass.preserveAlpha = this._pRequiresBlending;
            this._screenPass.colorTransform = this._colorTransform;
            this._screenPass.setBlendMode((this._pBlendMode == BlendMode.NORMAL && this._pRequiresBlending) ? BlendMode.LAYER : this._pBlendMode);
            this._screenPass.forceSeparateMVP = false;
        }
    };
    TriangleMethodMaterial.prototype.initCasterLightPass = function () {
        if (this._casterLightPass == null)
            this._casterLightPass = new TriangleMethodPass(MaterialPassMode.LIGHTING);
        this._casterLightPass.lightPicker = new StaticLightPicker([this._shadowMethod.castingLight]);
        this._casterLightPass.shadowMethod = this._shadowMethod;
        this._casterLightPass.diffuseMethod = this._diffuseMethod;
        this._casterLightPass.ambientMethod = this._ambientMethod;
        this._casterLightPass.normalMethod = this._normalMethod;
        this._casterLightPass.specularMethod = this._specularMethod;
    };
    TriangleMethodMaterial.prototype.removeCasterLightPass = function () {
        this._casterLightPass.dispose();
        this._pRemoveScreenPass(this._casterLightPass);
        this._casterLightPass = null;
    };
    TriangleMethodMaterial.prototype.initNonCasterLightPasses = function () {
        this.removeNonCasterLightPasses();
        var pass;
        var numDirLights = this._pLightPicker.numDirectionalLights;
        var numPointLights = this._pLightPicker.numPointLights;
        var numLightProbes = this._pLightPicker.numLightProbes;
        var dirLightOffset = 0;
        var pointLightOffset = 0;
        var probeOffset = 0;
        if (!this._casterLightPass) {
            numDirLights += this._pLightPicker.numCastingDirectionalLights;
            numPointLights += this._pLightPicker.numCastingPointLights;
        }
        this._nonCasterLightPasses = new Array();
        while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {
            pass = new TriangleMethodPass(MaterialPassMode.LIGHTING);
            pass.includeCasters = this._shadowMethod == null;
            pass.directionalLightsOffset = dirLightOffset;
            pass.pointLightsOffset = pointLightOffset;
            pass.lightProbesOffset = probeOffset;
            pass.lightPicker = this._pLightPicker;
            pass.diffuseMethod = this._diffuseMethod;
            pass.ambientMethod = this._ambientMethod;
            pass.normalMethod = this._normalMethod;
            pass.specularMethod = this._specularMethod;
            this._nonCasterLightPasses.push(pass);
            dirLightOffset += pass.iNumDirectionalLights;
            pointLightOffset += pass.iNumPointLights;
            probeOffset += pass.iNumLightProbes;
        }
    };
    TriangleMethodMaterial.prototype.removeNonCasterLightPasses = function () {
        if (!this._nonCasterLightPasses)
            return;
        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
            this._pRemoveScreenPass(this._nonCasterLightPasses[i]);
        this._nonCasterLightPasses = null;
    };
    TriangleMethodMaterial.prototype.removeEffectPass = function () {
        if (this._screenPass.ambientMethod != this._ambientMethod)
            this._screenPass.ambientMethod.dispose();
        if (this._screenPass.diffuseMethod != this._diffuseMethod)
            this._screenPass.diffuseMethod.dispose();
        if (this._screenPass.specularMethod != this._specularMethod)
            this._screenPass.specularMethod.dispose();
        if (this._screenPass.normalMethod != this._normalMethod)
            this._screenPass.normalMethod.dispose();
        this._pRemoveScreenPass(this._screenPass);
        this._screenPass = null;
    };
    TriangleMethodMaterial.prototype.initEffectPass = function () {
        if (this._screenPass == null)
            this._screenPass = new TriangleMethodPass();
        if (this._materialMode == TriangleMaterialMode.SINGLE_PASS) {
            this._screenPass.ambientMethod = this._ambientMethod;
            this._screenPass.diffuseMethod = this._diffuseMethod;
            this._screenPass.specularMethod = this._specularMethod;
            this._screenPass.normalMethod = this._normalMethod;
            this._screenPass.shadowMethod = this._shadowMethod;
        }
        else if (this._materialMode == TriangleMaterialMode.MULTI_PASS) {
            if (this.numLights == 0) {
                this._screenPass.ambientMethod = this._ambientMethod;
            }
            else {
                this._screenPass.ambientMethod = null;
            }
            this._screenPass.preserveAlpha = false;
            this._screenPass.normalMethod = this._normalMethod;
        }
    };
    Object.defineProperty(TriangleMethodMaterial.prototype, "numLights", {
        /**
         * The maximum total number of lights provided by the light picker.
         */
        get: function () {
            return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights + this._pLightPicker.numCastingDirectionalLights + this._pLightPicker.numCastingPointLights : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodMaterial.prototype, "numNonCasters", {
        /**
         * The amount of lights that don't cast shadows.
         */
        get: function () {
            return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights : 0;
        },
        enumerable: true,
        configurable: true
    });
    return TriangleMethodMaterial;
})(TriangleMaterialBase);
module.exports = TriangleMethodMaterial;


},{"awayjs-core/lib/geom/ColorTransform":239,"awayjs-core/lib/textures/Texture2DBase":251,"awayjs-display/lib/base/BlendMode":256,"awayjs-display/lib/materials/lightpickers/StaticLightPicker":281,"awayjs-stagegl/lib/base/ContextGLCompareMode":193,"awayjs-stagegl/lib/materials/TriangleMaterialBase":205,"awayjs-stagegl/lib/materials/TriangleMaterialMode":206,"awayjs-stagegl/lib/materials/methods/AmbientBasicMethod":217,"awayjs-stagegl/lib/materials/methods/DiffuseBasicMethod":218,"awayjs-stagegl/lib/materials/methods/NormalBasicMethod":222,"awayjs-stagegl/lib/materials/methods/SpecularBasicMethod":224,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":227,"awayjs-stagegl/lib/materials/passes/TriangleMethodPass":229}],208:[function(require,module,exports){
/**
 * MethodVO contains data for a given shader object for the use within a single material.
 * This allows shader methods to be shared across materials while their non-public state differs.
 */
var MethodVO = (function () {
    /**
     * Creates a new MethodVO object.
     */
    function MethodVO(method) {
        this.useMethod = true;
        this.method = method;
    }
    /**
     * Resets the values of the value object to their "unused" state.
     */
    MethodVO.prototype.reset = function () {
        this.method.iReset();
        this.texturesIndex = -1;
        this.vertexConstantsIndex = -1;
        this.fragmentConstantsIndex = -1;
        this.needsProjection = false;
        this.needsView = false;
        this.needsNormals = false;
        this.needsTangents = false;
        this.needsUV = false;
        this.needsSecondaryUV = false;
        this.needsGlobalVertexPos = false;
        this.needsGlobalFragmentPos = false;
    };
    return MethodVO;
})();
module.exports = MethodVO;


},{}],209:[function(require,module,exports){
var ShaderRegisterElement = require("awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement");
/**
 * RegisterPool is used by the shader compilation process to keep track of which registers of a certain type are
 * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
 * or single components (x, y, z, w) of a single register.
 * It is used by ShaderRegisterCache to track usages of individual register types.
 *
 * @see away.materials.ShaderRegisterCache
 */
var RegisterPool = (function () {
    /**
     * Creates a new RegisterPool object.
     * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
     * @param regCount The amount of available registers of this type.
     * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
     */
    function RegisterPool(regName, regCount, persistent) {
        if (persistent === void 0) { persistent = true; }
        this._regName = regName;
        this._regCount = regCount;
        this._persistent = persistent;
        this.initRegisters(regName, regCount);
    }
    /**
     * Retrieve an entire vector register that's still available.
     */
    RegisterPool.prototype.requestFreeVectorReg = function () {
        for (var i = 0; i < this._regCount; ++i) {
            if (!this.isRegisterUsed(i)) {
                if (this._persistent)
                    this._usedVectorCount[i]++;
                return this._vectorRegisters[i];
            }
        }
        throw new Error("Register overflow!");
    };
    /**
     * Retrieve a single vector component that's still available.
     */
    RegisterPool.prototype.requestFreeRegComponent = function () {
        for (var i = 0; i < this._regCount; ++i) {
            if (this._usedVectorCount[i] > 0)
                continue;
            for (var j = 0; j < 4; ++j) {
                if (this._usedSingleCount[j][i] == 0) {
                    if (this._persistent)
                        this._usedSingleCount[j][i]++;
                    return this._registerComponents[j][i];
                }
            }
        }
        throw new Error("Register overflow!");
    };
    /**
     * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
     * has been called usageCount times again.
     * @param register The register to mark as used.
     * @param usageCount The amount of usages to add.
     */
    RegisterPool.prototype.addUsage = function (register, usageCount) {
        if (register._component > -1)
            this._usedSingleCount[register._component][register.index] += usageCount;
        else
            this._usedVectorCount[register.index] += usageCount;
    };
    /**
     * Removes a usage from a register. When usages reach 0, the register is freed again.
     * @param register The register for which to remove a usage.
     */
    RegisterPool.prototype.removeUsage = function (register) {
        if (register._component > -1) {
            if (--this._usedSingleCount[register._component][register.index] < 0)
                throw new Error("More usages removed than exist!");
        }
        else {
            if (--this._usedVectorCount[register.index] < 0)
                throw new Error("More usages removed than exist!");
        }
    };
    /**
     * Disposes any resources used by the current RegisterPool object.
     */
    RegisterPool.prototype.dispose = function () {
        this._vectorRegisters = null;
        this._registerComponents = null;
        this._usedSingleCount = null;
        this._usedVectorCount = null;
    };
    /**
     * Indicates whether or not any registers are in use.
     */
    RegisterPool.prototype.hasRegisteredRegs = function () {
        for (var i = 0; i < this._regCount; ++i)
            if (this.isRegisterUsed(i))
                return true;
        return false;
    };
    /**
     * Initializes all registers.
     */
    RegisterPool.prototype.initRegisters = function (regName, regCount) {
        var hash = RegisterPool._initPool(regName, regCount);
        this._vectorRegisters = RegisterPool._regPool[hash];
        this._registerComponents = RegisterPool._regCompsPool[hash];
        this._usedVectorCount = this._initArray(Array(regCount), 0);
        this._usedSingleCount = new Array(4);
        this._usedSingleCount[0] = this._initArray(new Array(regCount), 0);
        this._usedSingleCount[1] = this._initArray(new Array(regCount), 0);
        this._usedSingleCount[2] = this._initArray(new Array(regCount), 0);
        this._usedSingleCount[3] = this._initArray(new Array(regCount), 0);
    };
    RegisterPool._initPool = function (regName, regCount) {
        var hash = regName + regCount;
        if (RegisterPool._regPool[hash] != undefined)
            return hash;
        var vectorRegisters = new Array(regCount);
        RegisterPool._regPool[hash] = vectorRegisters;
        var registerComponents = [
            [],
            [],
            [],
            []
        ];
        RegisterPool._regCompsPool[hash] = registerComponents;
        for (var i = 0; i < regCount; ++i) {
            vectorRegisters[i] = new ShaderRegisterElement(regName, i);
            for (var j = 0; j < 4; ++j)
                registerComponents[j][i] = new ShaderRegisterElement(regName, i, j);
        }
        return hash;
    };
    /**
     * Check if the temp register is either used for single or vector use
     */
    RegisterPool.prototype.isRegisterUsed = function (index) {
        if (this._usedVectorCount[index] > 0)
            return true;
        for (var i = 0; i < 4; ++i)
            if (this._usedSingleCount[i][index] > 0)
                return true;
        return false;
    };
    RegisterPool.prototype._initArray = function (a, val) {
        var l = a.length;
        for (var c = 0; c < l; c++)
            a[c] = val;
        return a;
    };
    RegisterPool._regPool = new Object();
    RegisterPool._regCompsPool = new Object();
    return RegisterPool;
})();
module.exports = RegisterPool;


},{"awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement":216}],210:[function(require,module,exports){
var ShaderRegisterCache = require("awayjs-stagegl/lib/materials/compilation/ShaderRegisterCache");
var ShaderRegisterData = require("awayjs-stagegl/lib/materials/compilation/ShaderRegisterData");
var MaterialPassMode = require("awayjs-stagegl/lib/materials/passes/MaterialPassMode");
/**
 * ShaderCompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
 * material. Concrete subclasses are used by the default materials.
 *
 * @see away.materials.ShadingMethodBase
 */
var ShaderCompilerBase = (function () {
    /**
     * Creates a new ShaderCompilerBase object.
     * @param profile The compatibility profile of the renderer.
     */
    function ShaderCompilerBase(material, materialPass, shaderObject) {
        this._pVertexCode = ''; // Changed to emtpy string- AwayTS
        this._pFragmentCode = ''; // Changed to emtpy string - AwayTS
        this._pPostAnimationFragmentCode = ''; // Changed to emtpy string - AwayTS
        this._pMaterial = material;
        this._pMaterialPass = materialPass;
        this._pShaderObject = shaderObject;
        this._pProfile = shaderObject.profile;
        this._pSharedRegisters = new ShaderRegisterData();
        this._pRegisterCache = new ShaderRegisterCache(this._pProfile);
        this._pRegisterCache.vertexAttributesOffset = 1;
        this._pRegisterCache.reset();
    }
    /**
     * Compiles the code after all setup on the compiler has finished.
     */
    ShaderCompilerBase.prototype.compile = function () {
        this._pShaderObject.reset();
        this.pCalculateDependencies();
        this.pInitRegisterIndices();
        this.pCompileDependencies();
        //compile custom vertex & fragment codes
        this._pVertexCode += this._pMaterialPass._iGetVertexCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
        this._pPostAnimationFragmentCode += this._pMaterialPass._iGetFragmentCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
        //assign the final output color to the output register
        this._pPostAnimationFragmentCode += "mov " + this._pRegisterCache.fragmentOutputRegister + ", " + this._pSharedRegisters.shadedTarget + "\n";
        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.shadedTarget);
        //initialise the required shader constants
        this._pShaderObject.initConstantData(this._pRegisterCache, this._pAnimatableAttributes, this._pAnimationTargetRegisters, this._uvSource, this._uvTarget);
        this._pMaterialPass._iInitConstantData(this._pShaderObject);
    };
    /**
     * Compile the code for the methods.
     */
    ShaderCompilerBase.prototype.pCompileDependencies = function () {
        this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);
        //compile the world-space position if required
        if (this._pShaderObject.globalPosDependencies > 0)
            this.compileGlobalPositionCode();
        //Calculate the (possibly animated) UV coordinates.
        if (this._pShaderObject.uvDependencies > 0)
            this.compileUVCode();
        if (this._pShaderObject.secondaryUVDependencies > 0)
            this.compileSecondaryUVCode();
        if (this._pShaderObject.normalDependencies > 0)
            this.compileNormalCode();
        if (this._pShaderObject.viewDirDependencies > 0)
            this.compileViewDirCode();
        //collect code from material
        this._pVertexCode += this._pMaterial._iGetVertexCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
        this._pFragmentCode += this._pMaterial._iGetFragmentCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
        //collect code from pass
        this._pVertexCode += this._pMaterialPass._iGetPreLightingVertexCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
        this._pFragmentCode += this._pMaterialPass._iGetPreLightingFragmentCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
    };
    ShaderCompilerBase.prototype.compileGlobalPositionCode = function () {
        this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.globalPositionVertex = this._pRegisterCache.getFreeVertexVectorTemp(), this._pShaderObject.globalPosDependencies);
        var sceneMatrixReg = this._pRegisterCache.getFreeVertexConstant();
        this._pRegisterCache.getFreeVertexConstant();
        this._pRegisterCache.getFreeVertexConstant();
        this._pRegisterCache.getFreeVertexConstant();
        this._pShaderObject.sceneMatrixIndex = sceneMatrixReg.index * 4;
        this._pVertexCode += "m44 " + this._pSharedRegisters.globalPositionVertex + ", " + this._pSharedRegisters.localPosition + ", " + sceneMatrixReg + "\n";
        if (this._pShaderObject.usesGlobalPosFragment) {
            this._pSharedRegisters.globalPositionVarying = this._pRegisterCache.getFreeVarying();
            this._pVertexCode += "mov " + this._pSharedRegisters.globalPositionVarying + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
        }
    };
    /**
     * Calculate the (possibly animated) UV coordinates.
     */
    ShaderCompilerBase.prototype.compileUVCode = function () {
        var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
        this._pShaderObject.uvBufferIndex = uvAttributeReg.index;
        var varying = this._pRegisterCache.getFreeVarying();
        this._pSharedRegisters.uvVarying = varying;
        if (this._pShaderObject.usesUVTransform) {
            // a, b, 0, tx
            // c, d, 0, ty
            var uvTransform1 = this._pRegisterCache.getFreeVertexConstant();
            var uvTransform2 = this._pRegisterCache.getFreeVertexConstant();
            this._pShaderObject.uvTransformIndex = uvTransform1.index * 4;
            this._pVertexCode += "dp4 " + varying + ".x, " + uvAttributeReg + ", " + uvTransform1 + "\n" + "dp4 " + varying + ".y, " + uvAttributeReg + ", " + uvTransform2 + "\n" + "mov " + varying + ".zw, " + uvAttributeReg + ".zw \n";
        }
        else {
            this._pShaderObject.uvTransformIndex = -1;
            this._uvTarget = varying.toString();
            this._uvSource = uvAttributeReg.toString();
        }
    };
    /**
     * Provide the secondary UV coordinates.
     */
    ShaderCompilerBase.prototype.compileSecondaryUVCode = function () {
        var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
        this._pShaderObject.secondaryUVBufferIndex = uvAttributeReg.index;
        this._pSharedRegisters.secondaryUVVarying = this._pRegisterCache.getFreeVarying();
        this._pVertexCode += "mov " + this._pSharedRegisters.secondaryUVVarying + ", " + uvAttributeReg + "\n";
    };
    /**
     * Calculate the view direction.
     */
    ShaderCompilerBase.prototype.compileViewDirCode = function () {
        var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();
        this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
        this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pShaderObject.viewDirDependencies);
        this._pShaderObject.cameraPositionIndex = cameraPositionReg.index * 4;
        if (this._pShaderObject.usesTangentSpace) {
            var temp = this._pRegisterCache.getFreeVertexVectorTemp();
            this._pVertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + this._pSharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.viewDirVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
        }
        else {
            this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
            this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
        }
        //TODO is this required in all cases? (re: distancemappass)
        this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" + "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w\n";
    };
    /**
     * Calculate the normal.
     */
    ShaderCompilerBase.prototype.compileNormalCode = function () {
        this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pShaderObject.normalDependencies);
        //simple normal aquisition if no tangent space is being used
        if (this._pShaderObject.outputsNormals && !this._pShaderObject.outputsTangentNormals) {
            this._pVertexCode += this._pMaterialPass._iGetNormalVertexCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
            this._pFragmentCode += this._pMaterialPass._iGetNormalFragmentCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
            return;
        }
        var normalMatrix;
        if (!this._pShaderObject.outputsNormals || !this._pShaderObject.usesTangentSpace) {
            normalMatrix = new Array(3);
            normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
            normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
            normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();
            this._pRegisterCache.getFreeVertexConstant();
            this._pShaderObject.sceneNormalMatrixIndex = normalMatrix[0].index * 4;
            this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();
        }
        if (this._pShaderObject.outputsNormals) {
            if (this._pShaderObject.usesTangentSpace) {
                // normalize normal + tangent vector and generate (approximated) bitangent used in m33 operation for view
                this._pVertexCode += "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + this._pSharedRegisters.animatedNormal + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + this._pSharedRegisters.animatedTangent + "\n" + "crs " + this._pSharedRegisters.bitangent + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n";
                this._pFragmentCode += this._pMaterialPass._iGetNormalFragmentCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters);
            }
            else {
                //Compiles the vertex shader code for tangent-space normal maps.
                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.bitangentVarying = this._pRegisterCache.getFreeVarying();
                var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + temp + "\n" + "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + temp + "\n" + "mov " + this._pSharedRegisters.tangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "mov " + this._pSharedRegisters.normalVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "crs " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.tangentVarying + ".y, " + temp + ".x    \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".y, " + temp + ".y  \n" + "mov " + this._pSharedRegisters.normalVarying + ".y, " + temp + ".z    \n";
                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedTangent);
                //Compiles the fragment shader code for tangent-space normal maps.
                var t;
                var b;
                var n;
                t = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(t, 1);
                b = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(b, 1);
                n = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(n, 1);
                this._pFragmentCode += "nrm " + t + ".xyz, " + this._pSharedRegisters.tangentVarying + "\n" + "mov " + t + ".w, " + this._pSharedRegisters.tangentVarying + ".w	\n" + "nrm " + b + ".xyz, " + this._pSharedRegisters.bitangentVarying + "\n" + "nrm " + n + ".xyz, " + this._pSharedRegisters.normalVarying + "\n";
                //compile custom fragment code for normal calcs
                this._pFragmentCode += this._pMaterialPass._iGetNormalFragmentCode(this._pShaderObject, this._pRegisterCache, this._pSharedRegisters) + "m33 " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalFragment + ", " + t + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w\n";
                this._pRegisterCache.removeFragmentTempUsage(b);
                this._pRegisterCache.removeFragmentTempUsage(t);
                this._pRegisterCache.removeFragmentTempUsage(n);
            }
        }
        else {
            // no output, world space is enough
            this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w\n";
            this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w\n";
            if (this._pShaderObject.tangentDependencies > 0) {
                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                this._pVertexCode += "m33 " + this._pSharedRegisters.tangentVarying + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.animatedTangent + ".w\n";
            }
        }
        if (!this._pShaderObject.usesTangentSpace)
            this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedNormal);
    };
    /**
     * Reset all the indices to "unused".
     */
    ShaderCompilerBase.prototype.pInitRegisterIndices = function () {
        this._pShaderObject.pInitRegisterIndices();
        this._pAnimatableAttributes = new Array("va0");
        this._pAnimationTargetRegisters = new Array("vt0");
        this._pVertexCode = "";
        this._pFragmentCode = "";
        this._pPostAnimationFragmentCode = "";
        this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.localPosition = this._pRegisterCache.getFreeVertexVectorTemp(), 1);
        //create commonly shared constant registers
        this._pSharedRegisters.commons = this._pRegisterCache.getFreeFragmentConstant();
        this._pShaderObject.commonsDataIndex = this._pSharedRegisters.commons.index * 4;
        //Creates the registers to contain the tangent data.
        // need to be created FIRST and in this order (for when using tangent space)
        if (this._pShaderObject.tangentDependencies > 0 || this._pShaderObject.outputsNormals) {
            this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
            this._pShaderObject.tangentBufferIndex = this._pSharedRegisters.tangentInput.index;
            this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
            this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);
            if (this._pShaderObject.usesTangentSpace) {
                this._pSharedRegisters.bitangent = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.bitangent, 1);
            }
            this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
            this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
        }
        if (this._pShaderObject.normalDependencies > 0) {
            this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
            this._pShaderObject.normalBufferIndex = this._pSharedRegisters.normalInput.index;
            this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
            this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);
            this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
            this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
        }
    };
    /**
     * Figure out which named registers are required, and how often.
     */
    ShaderCompilerBase.prototype.pCalculateDependencies = function () {
        this._pShaderObject.useAlphaPremultiplied = this._pMaterial.alphaPremultiplied;
        this._pShaderObject.useBothSides = this._pMaterial.bothSides;
        this._pShaderObject.useMipmapping = this._pMaterial.mipmap;
        this._pShaderObject.useSmoothTextures = this._pMaterial.smooth;
        this._pShaderObject.repeatTextures = this._pMaterial.repeat;
        this._pShaderObject.usesUVTransform = this._pMaterial.animateUVs;
        this._pShaderObject.alphaThreshold = this._pMaterial.alphaThreshold;
        this._pShaderObject.texture = this._pMaterial.texture;
        this._pShaderObject.color = this._pMaterial.color;
        //TODO: fragment animtion should be compatible with lighting pass
        this._pShaderObject.usesFragmentAnimation = Boolean(this._pMaterialPass.passMode == MaterialPassMode.SUPER_SHADER);
        this._pMaterialPass._iIncludeDependencies(this._pShaderObject);
    };
    /**
     * Disposes all resources used by the compiler.
     */
    ShaderCompilerBase.prototype.dispose = function () {
        this._pRegisterCache.dispose();
        this._pRegisterCache = null;
        this._pSharedRegisters = null;
    };
    Object.defineProperty(ShaderCompilerBase.prototype, "vertexCode", {
        /**
         * The generated vertex code.
         */
        get: function () {
            return this._pVertexCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderCompilerBase.prototype, "fragmentCode", {
        /**
         * The generated fragment code.
         */
        get: function () {
            return this._pFragmentCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderCompilerBase.prototype, "postAnimationFragmentCode", {
        /**
         * The generated fragment code.
         */
        get: function () {
            return this._pPostAnimationFragmentCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderCompilerBase.prototype, "shadedTarget", {
        /**
         * The register name containing the final shaded colour.
         */
        get: function () {
            return this._pSharedRegisters.shadedTarget.toString();
        },
        enumerable: true,
        configurable: true
    });
    return ShaderCompilerBase;
})();
module.exports = ShaderCompilerBase;


},{"awayjs-stagegl/lib/materials/compilation/ShaderRegisterCache":214,"awayjs-stagegl/lib/materials/compilation/ShaderRegisterData":215,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":227}],211:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var LightSources = require("awayjs-display/lib/materials/LightSources");
var ContextGLProfile = require("awayjs-stagegl/lib/base/ContextGLProfile");
var ShaderCompilerBase = require("awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase");
/**
 * ShaderCompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
 * material. Concrete subclasses are used by the default materials.
 *
 * @see away.materials.ShadingMethodBase
 */
var ShaderLightingCompiler = (function (_super) {
    __extends(ShaderLightingCompiler, _super);
    /**
     * Creates a new ShaderCompilerBase object.
     * @param profile The compatibility profile of the renderer.
     */
    function ShaderLightingCompiler(material, materialPass, shaderObject) {
        _super.call(this, material, materialPass, shaderObject);
        this._materialLightingPass = materialPass;
        this._shaderLightingObject = shaderObject;
    }
    /**
     * Compile the code for the methods.
     */
    ShaderLightingCompiler.prototype.pCompileDependencies = function () {
        _super.prototype.pCompileDependencies.call(this);
        //compile the lighting code
        if (this._shaderLightingObject.usesShadows)
            this.pCompileShadowCode();
        if (this._shaderLightingObject.usesLights) {
            this.initLightRegisters();
            this.compileLightCode();
        }
        if (this._shaderLightingObject.usesProbes)
            this.compileLightProbeCode();
        this._pVertexCode += this._materialLightingPass._iGetPostLightingVertexCode(this._shaderLightingObject, this._pRegisterCache, this._pSharedRegisters);
        this._pFragmentCode += this._materialLightingPass._iGetPostLightingFragmentCode(this._shaderLightingObject, this._pRegisterCache, this._pSharedRegisters);
    };
    /**
     * Provides the code to provide shadow mapping.
     */
    ShaderLightingCompiler.prototype.pCompileShadowCode = function () {
        if (this._shaderLightingObject.normalDependencies > 0) {
            this._pSharedRegisters.shadowTarget = this._pSharedRegisters.normalFragment;
        }
        else {
            this._pSharedRegisters.shadowTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
            this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadowTarget, 1);
        }
    };
    /**
     * Initializes constant registers to contain light data.
     */
    ShaderLightingCompiler.prototype.initLightRegisters = function () {
        // init these first so we're sure they're in sequence
        var i, len;
        if (this._dirLightVertexConstants) {
            len = this._dirLightVertexConstants.length;
            for (i = 0; i < len; ++i) {
                this._dirLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();
                if (this._shaderLightingObject.lightVertexConstantIndex == -1)
                    this._shaderLightingObject.lightVertexConstantIndex = this._dirLightVertexConstants[i].index * 4;
            }
        }
        if (this._pointLightVertexConstants) {
            len = this._pointLightVertexConstants.length;
            for (i = 0; i < len; ++i) {
                this._pointLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();
                if (this._shaderLightingObject.lightVertexConstantIndex == -1)
                    this._shaderLightingObject.lightVertexConstantIndex = this._pointLightVertexConstants[i].index * 4;
            }
        }
        len = this._dirLightFragmentConstants.length;
        for (i = 0; i < len; ++i) {
            this._dirLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
                this._shaderLightingObject.lightFragmentConstantIndex = this._dirLightFragmentConstants[i].index * 4;
        }
        len = this._pointLightFragmentConstants.length;
        for (i = 0; i < len; ++i) {
            this._pointLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
                this._shaderLightingObject.lightFragmentConstantIndex = this._pointLightFragmentConstants[i].index * 4;
        }
    };
    /**
     * Compiles the shading code for directional and point lights.
     */
    ShaderLightingCompiler.prototype.compileLightCode = function () {
        var diffuseColorReg;
        var specularColorReg;
        var lightPosReg;
        var lightDirReg;
        var vertexRegIndex = 0;
        var fragmentRegIndex = 0;
        var addSpec = this._shaderLightingObject.usesLightsForSpecular;
        var addDiff = this._shaderLightingObject.usesLightsForDiffuse;
        for (var i = 0; i < this._materialLightingPass.iNumDirectionalLights; ++i) {
            if (this._shaderLightingObject.usesTangentSpace) {
                lightDirReg = this._dirLightVertexConstants[vertexRegIndex++];
                var lightVarying = this._pRegisterCache.getFreeVarying();
                this._pVertexCode += "m33 " + lightVarying + ".xyz, " + lightDirReg + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + lightDirReg + ".w\n";
                lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addVertexTempUsages(lightDirReg, 1);
                this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" + "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
            }
            else {
                lightDirReg = this._dirLightFragmentConstants[fragmentRegIndex++];
            }
            diffuseColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
            specularColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
            if (addDiff)
                this._pFragmentCode += this._materialLightingPass._iGetPerLightDiffuseFragmentCode(this._shaderLightingObject, lightDirReg, diffuseColorReg, this._pRegisterCache, this._pSharedRegisters);
            if (addSpec)
                this._pFragmentCode += this._materialLightingPass._iGetPerLightSpecularFragmentCode(this._shaderLightingObject, lightDirReg, specularColorReg, this._pRegisterCache, this._pSharedRegisters);
            if (this._shaderLightingObject.usesTangentSpace)
                this._pRegisterCache.removeVertexTempUsage(lightDirReg);
        }
        vertexRegIndex = 0;
        fragmentRegIndex = 0;
        for (var i = 0; i < this._materialLightingPass.iNumPointLights; ++i) {
            if (this._shaderLightingObject.usesTangentSpace || !this._shaderLightingObject.usesGlobalPosFragment)
                lightPosReg = this._pointLightVertexConstants[vertexRegIndex++];
            else
                lightPosReg = this._pointLightFragmentConstants[fragmentRegIndex++];
            diffuseColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
            specularColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
            lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
            this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);
            var lightVarying;
            if (this._shaderLightingObject.usesTangentSpace) {
                lightVarying = this._pRegisterCache.getFreeVarying();
                var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pVertexCode += "sub " + temp + ", " + lightPosReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + lightVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
            }
            else if (!this._shaderLightingObject.usesGlobalPosFragment) {
                lightVarying = this._pRegisterCache.getFreeVarying();
                this._pVertexCode += "sub " + lightVarying + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
            }
            else {
                lightVarying = lightDirReg;
                this._pFragmentCode += "sub " + lightDirReg + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVarying + "\n";
            }
            if (this._shaderLightingObject.usesLightFallOff) {
                // calculate attenuation
                this._pFragmentCode += "dp3 " + lightDirReg + ".w, " + lightVarying + ", " + lightVarying + "\n" + "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" + "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" + "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" + "sub " + lightDirReg + ".w, " + this._pSharedRegisters.commons + ".w, " + lightDirReg + ".w\n" + "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
            }
            else {
                this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" + "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
            }
            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
                this._shaderLightingObject.lightFragmentConstantIndex = lightPosReg.index * 4;
            if (addDiff)
                this._pFragmentCode += this._materialLightingPass._iGetPerLightDiffuseFragmentCode(this._shaderLightingObject, lightDirReg, diffuseColorReg, this._pRegisterCache, this._pSharedRegisters);
            if (addSpec)
                this._pFragmentCode += this._materialLightingPass._iGetPerLightSpecularFragmentCode(this._shaderLightingObject, lightDirReg, specularColorReg, this._pRegisterCache, this._pSharedRegisters);
            this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
        }
    };
    /**
     * Compiles shading code for light probes.
     */
    ShaderLightingCompiler.prototype.compileLightProbeCode = function () {
        var weightReg;
        var weightComponents = [".x", ".y", ".z", ".w"];
        var weightRegisters = new Array();
        var i;
        var texReg;
        var addSpec = this._shaderLightingObject.usesProbesForSpecular;
        var addDiff = this._shaderLightingObject.usesProbesForDiffuse;
        if (addDiff)
            this._shaderLightingObject.lightProbeDiffuseIndices = new Array();
        if (addSpec)
            this._shaderLightingObject.lightProbeSpecularIndices = new Array();
        for (i = 0; i < this._pNumProbeRegisters; ++i) {
            weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
            if (i == 0)
                this._shaderLightingObject.probeWeightsIndex = weightRegisters[i].index * 4;
        }
        for (i = 0; i < this._materialLightingPass.iNumLightProbes; ++i) {
            weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];
            if (addDiff) {
                texReg = this._pRegisterCache.getFreeTextureReg();
                this._shaderLightingObject.lightProbeDiffuseIndices[i] = texReg.index;
                this._pFragmentCode += this._materialLightingPass._iGetPerProbeDiffuseFragmentCode(this._shaderLightingObject, texReg, weightReg, this._pRegisterCache, this._pSharedRegisters);
            }
            if (addSpec) {
                texReg = this._pRegisterCache.getFreeTextureReg();
                this._shaderLightingObject.lightProbeSpecularIndices[i] = texReg.index;
                this._pFragmentCode += this._materialLightingPass._iGetPerProbeSpecularFragmentCode(this._shaderLightingObject, texReg, weightReg, this._pRegisterCache, this._pSharedRegisters);
            }
        }
    };
    /**
     * Reset all the indices to "unused".
     */
    ShaderLightingCompiler.prototype.pInitRegisterIndices = function () {
        _super.prototype.pInitRegisterIndices.call(this);
        this._shaderLightingObject.lightVertexConstantIndex = -1;
        this._shaderLightingObject.lightFragmentConstantIndex = -1;
        this._shaderLightingObject.probeWeightsIndex = -1;
        this._pNumProbeRegisters = Math.ceil(this._materialLightingPass.iNumLightProbes / 4);
        //init light data
        if (this._shaderLightingObject.usesTangentSpace || !this._shaderLightingObject.usesGlobalPosFragment) {
            this._pointLightVertexConstants = new Array(this._materialLightingPass.iNumPointLights);
            this._pointLightFragmentConstants = new Array(this._materialLightingPass.iNumPointLights * 2);
        }
        else {
            this._pointLightFragmentConstants = new Array(this._materialLightingPass.iNumPointLights * 3);
        }
        if (this._shaderLightingObject.usesTangentSpace) {
            this._dirLightVertexConstants = new Array(this._materialLightingPass.iNumDirectionalLights);
            this._dirLightFragmentConstants = new Array(this._materialLightingPass.iNumDirectionalLights * 2);
        }
        else {
            this._dirLightFragmentConstants = new Array(this._materialLightingPass.iNumDirectionalLights * 3);
        }
    };
    /**
     * Figure out which named registers are required, and how often.
     */
    ShaderLightingCompiler.prototype.pCalculateDependencies = function () {
        var numAllLights = this._materialLightingPass.iNumPointLights + this._materialLightingPass.iNumDirectionalLights;
        var numLightProbes = this._materialLightingPass.iNumLightProbes;
        var diffuseLightSources = this._pMaterial.diffuseLightSources;
        var specularLightSources = this._materialLightingPass._iUsesSpecular() ? this._pMaterial.specularLightSources : 0x00;
        var combinedLightSources = diffuseLightSources | specularLightSources;
        this._shaderLightingObject.usesLightFallOff = this._pMaterial.enableLightFallOff && this._shaderLightingObject.profile != ContextGLProfile.BASELINE_CONSTRAINED;
        this._shaderLightingObject.numLights = numAllLights + numLightProbes;
        this._shaderLightingObject.numPointLights = this._materialLightingPass.iNumPointLights;
        this._shaderLightingObject.numDirectionalLights = this._materialLightingPass.iNumDirectionalLights;
        this._shaderLightingObject.numLightProbes = numLightProbes;
        this._shaderLightingObject.pointLightsOffset = this._materialLightingPass.pointLightsOffset;
        this._shaderLightingObject.directionalLightsOffset = this._materialLightingPass.directionalLightsOffset;
        this._shaderLightingObject.lightProbesOffset = this._materialLightingPass.lightProbesOffset;
        this._shaderLightingObject.lightPicker = this._materialLightingPass.lightPicker;
        this._shaderLightingObject.usesLights = numAllLights > 0 && (combinedLightSources & LightSources.LIGHTS) != 0;
        this._shaderLightingObject.usesProbes = numLightProbes > 0 && (combinedLightSources & LightSources.PROBES) != 0;
        this._shaderLightingObject.usesLightsForSpecular = numAllLights > 0 && (specularLightSources & LightSources.LIGHTS) != 0;
        this._shaderLightingObject.usesProbesForSpecular = numLightProbes > 0 && (specularLightSources & LightSources.PROBES) != 0;
        this._shaderLightingObject.usesLightsForDiffuse = numAllLights > 0 && (diffuseLightSources & LightSources.LIGHTS) != 0;
        this._shaderLightingObject.usesProbesForDiffuse = numLightProbes > 0 && (diffuseLightSources & LightSources.PROBES) != 0;
        this._shaderLightingObject.usesShadows = this._materialLightingPass._iUsesShadows();
        _super.prototype.pCalculateDependencies.call(this);
    };
    return ShaderLightingCompiler;
})(ShaderCompilerBase);
module.exports = ShaderLightingCompiler;


},{"awayjs-display/lib/materials/LightSources":278,"awayjs-stagegl/lib/base/ContextGLProfile":195,"awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase":210}],212:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ShaderLightingCompiler = require("awayjs-stagegl/lib/materials/compilation/ShaderLightingCompiler");
var ShaderObjectBase = require("awayjs-stagegl/lib/materials/compilation/ShaderObjectBase");
/**
 * ShaderObjectBase keeps track of the number of dependencies for "named registers" used across a pass.
 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
 * each time a method has been compiled into the shader.
 *
 * @see RegisterPool.addUsage
 */
var ShaderLightingObject = (function (_super) {
    __extends(ShaderLightingObject, _super);
    /**
     * Creates a new MethodCompilerVO object.
     */
    function ShaderLightingObject(profile) {
        _super.call(this, profile);
    }
    /**
     * Factory method to create a concrete compiler object for this object
     *
     * @param materialPassVO
     * @returns {away.materials.ShaderLightingCompiler}
     */
    ShaderLightingObject.prototype.createCompiler = function (material, materialPass) {
        return new ShaderLightingCompiler(material, materialPass, this);
    };
    /**
     * Clears dependency counts for all registers. Called when recompiling a pass.
     */
    ShaderLightingObject.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.numLights = 0;
        this.usesLightFallOff = true;
    };
    /**
     * Adds any external world space dependencies, used to force world space calculations.
     */
    ShaderLightingObject.prototype.addWorldSpaceDependencies = function (fragmentLights) {
        _super.prototype.addWorldSpaceDependencies.call(this, fragmentLights);
        if (this.numPointLights > 0 && this.usesLights) {
            ++this.globalPosDependencies;
            if (fragmentLights)
                this.usesGlobalPosFragment = true;
        }
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    ShaderLightingObject.prototype.setRenderState = function (renderable, stage, camera, viewProjection) {
        _super.prototype.setRenderState.call(this, renderable, stage, camera, viewProjection);
        if (this.usesLights)
            this.updateLights();
        if (this.usesProbes)
            this.updateProbes(stage);
    };
    /**
     * Updates constant data render state used by the lights. This method is optional for subclasses to implement.
     */
    ShaderLightingObject.prototype.updateLights = function () {
        var dirLight;
        var pointLight;
        var i = 0;
        var k = 0;
        var len;
        var dirPos;
        var total = 0;
        var numLightTypes = this.usesShadows ? 2 : 1;
        var l;
        var offset;
        this.ambientR = this.ambientG = this.ambientB = 0;
        l = this.lightVertexConstantIndex;
        k = this.lightFragmentConstantIndex;
        var cast = 0;
        var dirLights = this.lightPicker.directionalLights;
        offset = this.directionalLightsOffset;
        len = this.lightPicker.directionalLights.length;
        if (offset > len) {
            cast = 1;
            offset -= len;
        }
        for (; cast < numLightTypes; ++cast) {
            if (cast)
                dirLights = this.lightPicker.castingDirectionalLights;
            len = dirLights.length;
            if (len > this.numDirectionalLights)
                len = this.numDirectionalLights;
            for (i = 0; i < len; ++i) {
                dirLight = dirLights[offset + i];
                dirPos = dirLight.sceneDirection;
                this.ambientR += dirLight._iAmbientR;
                this.ambientG += dirLight._iAmbientG;
                this.ambientB += dirLight._iAmbientB;
                if (this.usesTangentSpace) {
                    var x = -dirPos.x;
                    var y = -dirPos.y;
                    var z = -dirPos.z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z;
                    this.vertexConstantData[l++] = 1;
                }
                else {
                    this.fragmentConstantData[k++] = -dirPos.x;
                    this.fragmentConstantData[k++] = -dirPos.y;
                    this.fragmentConstantData[k++] = -dirPos.z;
                    this.fragmentConstantData[k++] = 1;
                }
                this.fragmentConstantData[k++] = dirLight._iDiffuseR;
                this.fragmentConstantData[k++] = dirLight._iDiffuseG;
                this.fragmentConstantData[k++] = dirLight._iDiffuseB;
                this.fragmentConstantData[k++] = 1;
                this.fragmentConstantData[k++] = dirLight._iSpecularR;
                this.fragmentConstantData[k++] = dirLight._iSpecularG;
                this.fragmentConstantData[k++] = dirLight._iSpecularB;
                this.fragmentConstantData[k++] = 1;
                if (++total == this.numDirectionalLights) {
                    // break loop
                    i = len;
                    cast = numLightTypes;
                }
            }
        }
        // more directional supported than currently picked, need to clamp all to 0
        if (this.numDirectionalLights > total) {
            i = k + (this.numDirectionalLights - total) * 12;
            while (k < i)
                this.fragmentConstantData[k++] = 0;
        }
        total = 0;
        var pointLights = this.lightPicker.pointLights;
        offset = this.pointLightsOffset;
        len = this.lightPicker.pointLights.length;
        if (offset > len) {
            cast = 1;
            offset -= len;
        }
        else {
            cast = 0;
        }
        for (; cast < numLightTypes; ++cast) {
            if (cast)
                pointLights = this.lightPicker.castingPointLights;
            len = pointLights.length;
            for (i = 0; i < len; ++i) {
                pointLight = pointLights[offset + i];
                dirPos = pointLight.scenePosition;
                this.ambientR += pointLight._iAmbientR;
                this.ambientG += pointLight._iAmbientG;
                this.ambientB += pointLight._iAmbientB;
                if (this.usesTangentSpace) {
                    x = dirPos.x;
                    y = dirPos.y;
                    z = dirPos.z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
                    this.vertexConstantData[l++] = 1;
                }
                else if (!this.usesGlobalPosFragment) {
                    this.vertexConstantData[l++] = dirPos.x;
                    this.vertexConstantData[l++] = dirPos.y;
                    this.vertexConstantData[l++] = dirPos.z;
                    this.vertexConstantData[l++] = 1;
                }
                else {
                    this.fragmentConstantData[k++] = dirPos.x;
                    this.fragmentConstantData[k++] = dirPos.y;
                    this.fragmentConstantData[k++] = dirPos.z;
                    this.fragmentConstantData[k++] = 1;
                }
                this.fragmentConstantData[k++] = pointLight._iDiffuseR;
                this.fragmentConstantData[k++] = pointLight._iDiffuseG;
                this.fragmentConstantData[k++] = pointLight._iDiffuseB;
                var radius = pointLight._pRadius;
                this.fragmentConstantData[k++] = radius * radius;
                this.fragmentConstantData[k++] = pointLight._iSpecularR;
                this.fragmentConstantData[k++] = pointLight._iSpecularG;
                this.fragmentConstantData[k++] = pointLight._iSpecularB;
                this.fragmentConstantData[k++] = pointLight._pFallOffFactor;
                if (++total == this.numPointLights) {
                    // break loop
                    i = len;
                    cast = numLightTypes;
                }
            }
        }
        // more directional supported than currently picked, need to clamp all to 0
        if (this.numPointLights > total) {
            i = k + (total - this.numPointLights) * 12;
            for (; k < i; ++k)
                this.fragmentConstantData[k] = 0;
        }
    };
    /**
     * Updates constant data render state used by the light probes. This method is optional for subclasses to implement.
     */
    ShaderLightingObject.prototype.updateProbes = function (stage) {
        var probe;
        var lightProbes = this.lightPicker.lightProbes;
        var weights = this.lightPicker.lightProbeWeights;
        var len = lightProbes.length - this.lightProbesOffset;
        var addDiff = this.usesProbesForDiffuse;
        var addSpec = this.usesProbesForSpecular;
        if (!(addDiff || addSpec))
            return;
        if (len > this.numLightProbes)
            len = this.numLightProbes;
        for (var i = 0; i < len; ++i) {
            probe = lightProbes[this.lightProbesOffset + i];
            if (addDiff)
                stage.context.activateCubeTexture(this.lightProbeDiffuseIndices[i], probe.diffuseMap);
            if (addSpec)
                stage.context.activateCubeTexture(this.lightProbeSpecularIndices[i], probe.specularMap);
        }
        for (i = 0; i < len; ++i)
            this.fragmentConstantData[this.probeWeightsIndex + i] = weights[this.lightProbesOffset + i];
    };
    return ShaderLightingObject;
})(ShaderObjectBase);
module.exports = ShaderLightingObject;


},{"awayjs-stagegl/lib/materials/compilation/ShaderLightingCompiler":211,"awayjs-stagegl/lib/materials/compilation/ShaderObjectBase":213}],213:[function(require,module,exports){
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var ContextGLTriangleFace = require("awayjs-stagegl/lib/base/ContextGLTriangleFace");
var ShaderCompilerBase = require("awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase");
/**
 * ShaderObjectBase keeps track of the number of dependencies for "named registers" used across a pass.
 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
 * each time a method has been compiled into the shader.
 *
 * @see RegisterPool.addUsage
 */
var ShaderObjectBase = (function () {
    /**
     * Creates a new MethodCompilerVO object.
     */
    function ShaderObjectBase(profile) {
        this._defaultCulling = ContextGLTriangleFace.BACK;
        this._pInverseSceneMatrix = new Array();
        //set ambient values to default
        this.ambientR = 0xFF;
        this.ambientG = 0xFF;
        this.ambientB = 0xFF;
        /**
         * Indicates whether there are any dependencies on the world-space position vector.
         */
        this.usesGlobalPosFragment = false;
        this.vertexConstantData = new Array();
        this.fragmentConstantData = new Array();
        this.profile = profile;
    }
    /**
     * Factory method to create a concrete compiler object for this object
     *
     * @param materialPassVO
     * @returns {away.materials.ShaderCompilerBase}
     */
    ShaderObjectBase.prototype.createCompiler = function (material, materialPass) {
        return new ShaderCompilerBase(material, materialPass, this);
    };
    /**
     * Clears dependency counts for all registers. Called when recompiling a pass.
     */
    ShaderObjectBase.prototype.reset = function () {
        this.projectionDependencies = 0;
        this.normalDependencies = 0;
        this.viewDirDependencies = 0;
        this.uvDependencies = 0;
        this.secondaryUVDependencies = 0;
        this.globalPosDependencies = 0;
        this.tangentDependencies = 0;
        this.usesGlobalPosFragment = false;
        this.usesFragmentAnimation = false;
        this.usesTangentSpace = false;
        this.outputsNormals = false;
        this.outputsTangentNormals = false;
    };
    /**
     * Adds any external world space dependencies, used to force world space calculations.
     */
    ShaderObjectBase.prototype.addWorldSpaceDependencies = function (fragmentLights) {
        if (this.viewDirDependencies > 0)
            ++this.globalPosDependencies;
    };
    ShaderObjectBase.prototype.pInitRegisterIndices = function () {
        this.commonsDataIndex = -1;
        this.cameraPositionIndex = -1;
        this.uvBufferIndex = -1;
        this.uvTransformIndex = -1;
        this.secondaryUVBufferIndex = -1;
        this.normalBufferIndex = -1;
        this.tangentBufferIndex = -1;
        this.sceneMatrixIndex = -1;
        this.sceneNormalMatrixIndex = -1;
    };
    /**
     * Initializes the unchanging constant data for this shader object.
     */
    ShaderObjectBase.prototype.initConstantData = function (registerCache, animatableAttributes, animationTargetRegisters, uvSource, uvTarget) {
        //Updates the amount of used register indices.
        this.numUsedVertexConstants = registerCache.numUsedVertexConstants;
        this.numUsedFragmentConstants = registerCache.numUsedFragmentConstants;
        this.numUsedStreams = registerCache.numUsedStreams;
        this.numUsedTextures = registerCache.numUsedTextures;
        this.numUsedVaryings = registerCache.numUsedVaryings;
        this.numUsedFragmentConstants = registerCache.numUsedFragmentConstants;
        this.animatableAttributes = animatableAttributes;
        this.animationTargetRegisters = animationTargetRegisters;
        this.uvSource = uvSource;
        this.uvTarget = uvTarget;
        this.vertexConstantData.length = this.numUsedVertexConstants * 4;
        this.fragmentConstantData.length = this.numUsedFragmentConstants * 4;
        //Initializes commonly required constant values.
        this.fragmentConstantData[this.commonsDataIndex] = .5;
        this.fragmentConstantData[this.commonsDataIndex + 1] = 0;
        this.fragmentConstantData[this.commonsDataIndex + 2] = 1 / 255;
        this.fragmentConstantData[this.commonsDataIndex + 3] = 1;
        //Initializes the default UV transformation matrix.
        if (this.uvTransformIndex >= 0) {
            this.vertexConstantData[this.uvTransformIndex] = 1;
            this.vertexConstantData[this.uvTransformIndex + 1] = 0;
            this.vertexConstantData[this.uvTransformIndex + 2] = 0;
            this.vertexConstantData[this.uvTransformIndex + 3] = 0;
            this.vertexConstantData[this.uvTransformIndex + 4] = 0;
            this.vertexConstantData[this.uvTransformIndex + 5] = 1;
            this.vertexConstantData[this.uvTransformIndex + 6] = 0;
            this.vertexConstantData[this.uvTransformIndex + 7] = 0;
        }
        if (this.cameraPositionIndex >= 0)
            this.vertexConstantData[this.cameraPositionIndex + 3] = 1;
    };
    /**
     * @inheritDoc
     */
    ShaderObjectBase.prototype.iActivate = function (stage, camera) {
        stage.context.setCulling(this.useBothSides ? ContextGLTriangleFace.NONE : this._defaultCulling, camera.projection.coordinateSystem);
        if (!this.usesTangentSpace && this.cameraPositionIndex >= 0) {
            var pos = camera.scenePosition;
            this.vertexConstantData[this.cameraPositionIndex] = pos.x;
            this.vertexConstantData[this.cameraPositionIndex + 1] = pos.y;
            this.vertexConstantData[this.cameraPositionIndex + 2] = pos.z;
        }
    };
    /**
     * @inheritDoc
     */
    ShaderObjectBase.prototype.iDeactivate = function (stage) {
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    ShaderObjectBase.prototype.setRenderState = function (renderable, stage, camera, viewProjection) {
        var context = stage.context;
        if (renderable.materialOwner.animator)
            renderable.materialOwner.animator.setRenderState(this, renderable, stage, camera, this.numUsedVertexConstants, this.numUsedStreams);
        if (this.uvBufferIndex >= 0)
            context.activateBuffer(this.uvBufferIndex, renderable.getVertexData(TriangleSubGeometry.UV_DATA), renderable.getVertexOffset(TriangleSubGeometry.UV_DATA), TriangleSubGeometry.UV_FORMAT);
        if (this.secondaryUVBufferIndex >= 0)
            context.activateBuffer(this.secondaryUVBufferIndex, renderable.getVertexData(TriangleSubGeometry.SECONDARY_UV_DATA), renderable.getVertexOffset(TriangleSubGeometry.SECONDARY_UV_DATA), TriangleSubGeometry.SECONDARY_UV_FORMAT);
        if (this.normalBufferIndex >= 0)
            context.activateBuffer(this.normalBufferIndex, renderable.getVertexData(TriangleSubGeometry.NORMAL_DATA), renderable.getVertexOffset(TriangleSubGeometry.NORMAL_DATA), TriangleSubGeometry.NORMAL_FORMAT);
        if (this.tangentBufferIndex >= 0)
            context.activateBuffer(this.tangentBufferIndex, renderable.getVertexData(TriangleSubGeometry.TANGENT_DATA), renderable.getVertexOffset(TriangleSubGeometry.TANGENT_DATA), TriangleSubGeometry.TANGENT_FORMAT);
        if (this.usesUVTransform) {
            var uvTransform = renderable.materialOwner.uvTransform.matrix;
            if (uvTransform) {
                this.vertexConstantData[this.uvTransformIndex] = uvTransform.a;
                this.vertexConstantData[this.uvTransformIndex + 1] = uvTransform.b;
                this.vertexConstantData[this.uvTransformIndex + 3] = uvTransform.tx;
                this.vertexConstantData[this.uvTransformIndex + 4] = uvTransform.c;
                this.vertexConstantData[this.uvTransformIndex + 5] = uvTransform.d;
                this.vertexConstantData[this.uvTransformIndex + 7] = uvTransform.ty;
            }
            else {
                this.vertexConstantData[this.uvTransformIndex] = 1;
                this.vertexConstantData[this.uvTransformIndex + 1] = 0;
                this.vertexConstantData[this.uvTransformIndex + 3] = 0;
                this.vertexConstantData[this.uvTransformIndex + 4] = 0;
                this.vertexConstantData[this.uvTransformIndex + 5] = 1;
                this.vertexConstantData[this.uvTransformIndex + 7] = 0;
            }
        }
        if (this.sceneNormalMatrixIndex >= 0)
            renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this.vertexConstantData, this.sceneNormalMatrixIndex, false);
        if (this.usesTangentSpace && this.cameraPositionIndex >= 0) {
            renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._pInverseSceneMatrix);
            var pos = camera.scenePosition;
            var x = pos.x;
            var y = pos.y;
            var z = pos.z;
            this.vertexConstantData[this.cameraPositionIndex] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
            this.vertexConstantData[this.cameraPositionIndex + 1] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
            this.vertexConstantData[this.cameraPositionIndex + 2] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
        }
    };
    ShaderObjectBase.prototype.dispose = function () {
        //TODO uncount associated program data
    };
    return ShaderObjectBase;
})();
module.exports = ShaderObjectBase;


},{"awayjs-display/lib/base/TriangleSubGeometry":265,"awayjs-stagegl/lib/base/ContextGLTriangleFace":199,"awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase":210}],214:[function(require,module,exports){
var RegisterPool = require("awayjs-stagegl/lib/materials/compilation/RegisterPool");
var ShaderRegisterElement = require("awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement");
/**
 * ShaderRegister Cache provides the usage management system for all registers during shading compilation.
 */
var ShaderRegisterCache = (function () {
    /**
     * Create a new ShaderRegisterCache object.
     *
     * @param profile The compatibility profile used by the renderer.
     */
    function ShaderRegisterCache(profile) {
        this._numUsedVertexConstants = 0;
        this._numUsedFragmentConstants = 0;
        this._numUsedStreams = 0;
        this._numUsedTextures = 0;
        this._numUsedVaryings = 0;
        this._profile = profile;
    }
    /**
     * Resets all registers.
     */
    ShaderRegisterCache.prototype.reset = function () {
        this._fragmentTempCache = new RegisterPool("ft", 8, false);
        this._vertexTempCache = new RegisterPool("vt", 8, false);
        this._varyingCache = new RegisterPool("v", 8);
        this._textureCache = new RegisterPool("fs", 8);
        this._vertexAttributesCache = new RegisterPool("va", 8);
        this._fragmentConstantsCache = new RegisterPool("fc", 28);
        this._vertexConstantsCache = new RegisterPool("vc", 128);
        this._fragmentOutputRegister = new ShaderRegisterElement("oc", -1);
        this._vertexOutputRegister = new ShaderRegisterElement("op", -1);
        this._numUsedVertexConstants = 0;
        this._numUsedStreams = 0;
        this._numUsedTextures = 0;
        this._numUsedVaryings = 0;
        this._numUsedFragmentConstants = 0;
        var i;
        for (i = 0; i < this._vertexAttributesOffset; ++i)
            this.getFreeVertexAttribute();
        for (i = 0; i < this._vertexConstantOffset; ++i)
            this.getFreeVertexConstant();
        for (i = 0; i < this._varyingsOffset; ++i)
            this.getFreeVarying();
        for (i = 0; i < this._fragmentConstantOffset; ++i)
            this.getFreeFragmentConstant();
    };
    /**
     * Disposes all resources used.
     */
    ShaderRegisterCache.prototype.dispose = function () {
        this._fragmentTempCache.dispose();
        this._vertexTempCache.dispose();
        this._varyingCache.dispose();
        this._fragmentConstantsCache.dispose();
        this._vertexAttributesCache.dispose();
        this._fragmentTempCache = null;
        this._vertexTempCache = null;
        this._varyingCache = null;
        this._fragmentConstantsCache = null;
        this._vertexAttributesCache = null;
        this._fragmentOutputRegister = null;
        this._vertexOutputRegister = null;
    };
    /**
     * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
     * has been called usageCount times again.
     * @param register The register to mark as used.
     * @param usageCount The amount of usages to add.
     */
    ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
        this._fragmentTempCache.addUsage(register, usageCount);
    };
    /**
     * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
     * @param register The register for which to remove a usage.
     */
    ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
        this._fragmentTempCache.removeUsage(register);
    };
    /**
     * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
     * until removeUsage has been called usageCount times again.
     * @param register The register to mark as used.
     * @param usageCount The amount of usages to add.
     */
    ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
        this._vertexTempCache.addUsage(register, usageCount);
    };
    /**
     * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
     * @param register The register for which to remove a usage.
     */
    ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
        this._vertexTempCache.removeUsage(register);
    };
    /**
     * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
     * has been called usageCount times again.
     */
    ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
        return this._fragmentTempCache.requestFreeVectorReg();
    };
    /**
     * Retrieve a single component from a fragment temporary register that's still available.
     */
    ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
        return this._fragmentTempCache.requestFreeRegComponent();
    };
    /**
     * Retrieve an available varying register
     */
    ShaderRegisterCache.prototype.getFreeVarying = function () {
        ++this._numUsedVaryings;
        return this._varyingCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an available fragment constant register
     */
    ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
        ++this._numUsedFragmentConstants;
        return this._fragmentConstantsCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an available vertex constant register
     */
    ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
        ++this._numUsedVertexConstants;
        return this._vertexConstantsCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an entire vertex temporary register that's still available.
     */
    ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
        return this._vertexTempCache.requestFreeVectorReg();
    };
    /**
     * Retrieve a single component from a vertex temporary register that's still available.
     */
    ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
        return this._vertexTempCache.requestFreeRegComponent();
    };
    /**
     * Retrieve an available vertex attribute register
     */
    ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
        ++this._numUsedStreams;
        return this._vertexAttributesCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an available texture register
     */
    ShaderRegisterCache.prototype.getFreeTextureReg = function () {
        ++this._numUsedTextures;
        return this._textureCache.requestFreeVectorReg();
    };
    Object.defineProperty(ShaderRegisterCache.prototype, "vertexConstantOffset", {
        /**
         * Indicates the start index from which to retrieve vertex constants.
         */
        get: function () {
            return this._vertexConstantOffset;
        },
        set: function (vertexConstantOffset) {
            this._vertexConstantOffset = vertexConstantOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "vertexAttributesOffset", {
        /**
         * Indicates the start index from which to retrieve vertex attributes.
         */
        get: function () {
            return this._vertexAttributesOffset;
        },
        set: function (value) {
            this._vertexAttributesOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "varyingsOffset", {
        /**
         * Indicates the start index from which to retrieve varying registers.
         */
        get: function () {
            return this._varyingsOffset;
        },
        set: function (value) {
            this._varyingsOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "fragmentConstantOffset", {
        /**
         * Indicates the start index from which to retrieve fragment constants.
         */
        get: function () {
            return this._fragmentConstantOffset;
        },
        set: function (value) {
            this._fragmentConstantOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
        /**
         * The fragment output register.
         */
        get: function () {
            return this._fragmentOutputRegister;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
        /**
         * The amount of used vertex constant registers.
         */
        get: function () {
            return this._numUsedVertexConstants;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
        /**
         * The amount of used fragment constant registers.
         */
        get: function () {
            return this._numUsedFragmentConstants;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
        /**
         * The amount of used vertex streams.
         */
        get: function () {
            return this._numUsedStreams;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
        /**
         * The amount of used texture slots.
         */
        get: function () {
            return this._numUsedTextures;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
        /**
         * The amount of used varying registers.
         */
        get: function () {
            return this._numUsedVaryings;
        },
        enumerable: true,
        configurable: true
    });
    return ShaderRegisterCache;
})();
module.exports = ShaderRegisterCache;


},{"awayjs-stagegl/lib/materials/compilation/RegisterPool":209,"awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement":216}],215:[function(require,module,exports){
/**
 * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
 */
var ShaderRegisterData = (function () {
    function ShaderRegisterData() {
    }
    return ShaderRegisterData;
})();
module.exports = ShaderRegisterData;


},{}],216:[function(require,module,exports){
/**
 * A single register element (an entire register or a single register's component) used by the RegisterPool.
 */
var ShaderRegisterElement = (function () {
    /**
     * Creates a new ShaderRegisterElement object.
     *
     * @param regName The name of the register.
     * @param index The index of the register.
     * @param component The register's component, if not the entire register is represented.
     */
    function ShaderRegisterElement(regName, index, component) {
        if (component === void 0) { component = -1; }
        this._component = component;
        this._regName = regName;
        this._index = index;
        this._toStr = this._regName;
        if (this._index >= 0)
            this._toStr += this._index;
        if (component > -1)
            this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
    }
    /**
     * Converts the register or the components AGAL string representation.
     */
    ShaderRegisterElement.prototype.toString = function () {
        return this._toStr;
    };
    Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
        /**
         * The register's name.
         */
        get: function () {
            return this._regName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterElement.prototype, "index", {
        /**
         * The register's index.
         */
        get: function () {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];
    return ShaderRegisterElement;
})();
module.exports = ShaderRegisterElement;


},{}],217:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var ShadingMethodBase = require("awayjs-stagegl/lib/materials/methods/ShadingMethodBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * AmbientBasicMethod provides the default shading method for uniform ambient lighting.
 */
var AmbientBasicMethod = (function (_super) {
    __extends(AmbientBasicMethod, _super);
    /**
     * Creates a new AmbientBasicMethod object.
     */
    function AmbientBasicMethod() {
        _super.call(this);
        this._color = 0xffffff;
        this._alpha = 1;
        this._colorR = 1;
        this._colorG = 1;
        this._colorB = 1;
        this._ambient = 1;
    }
    /**
     * @inheritDoc
     */
    AmbientBasicMethod.prototype.iInitVO = function (shaderObject, methodVO) {
        methodVO.needsUV = Boolean(shaderObject.texture != null);
    };
    /**
     * @inheritDoc
     */
    AmbientBasicMethod.prototype.iInitConstants = function (shaderObject, methodVO) {
        if (!methodVO.needsUV) {
            this._color = shaderObject.color;
            this.updateColor();
        }
    };
    Object.defineProperty(AmbientBasicMethod.prototype, "ambient", {
        /**
         * The strength of the ambient reflection of the surface.
         */
        get: function () {
            return this._ambient;
        },
        set: function (value) {
            if (this._ambient == value)
                return;
            this._ambient = value;
            this.updateColor();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmbientBasicMethod.prototype, "alpha", {
        /**
         * The alpha component of the surface.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            if (this._alpha == value)
                return;
            this._alpha = value;
            this.updateColor();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    AmbientBasicMethod.prototype.copyFrom = function (method) {
        var m = method;
        var b = m;
    };
    /**
     * @inheritDoc
     */
    AmbientBasicMethod.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        var code = "";
        var ambientInputRegister;
        if (methodVO.needsUV) {
            ambientInputRegister = registerCache.getFreeTextureReg();
            methodVO.texturesIndex = ambientInputRegister.index;
            code += ShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedRegisters, ambientInputRegister, shaderObject.texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);
            if (shaderObject.alphaThreshold > 0) {
                var cutOffReg = registerCache.getFreeFragmentConstant();
                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;
                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" + "kil " + targetReg + ".w\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
            }
        }
        else {
            ambientInputRegister = registerCache.getFreeFragmentConstant();
            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;
            code += "mov " + targetReg + ", " + ambientInputRegister + "\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    AmbientBasicMethod.prototype.iActivate = function (shaderObject, methodVO, stage) {
        if (methodVO.needsUV) {
            stage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            stage.context.activateTexture(methodVO.texturesIndex, shaderObject.texture);
            if (shaderObject.alphaThreshold > 0)
                shaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex] = shaderObject.alphaThreshold;
        }
        else {
            var index = methodVO.fragmentConstantsIndex;
            var data = shaderObject.fragmentConstantData;
            data[index] = this._colorR;
            data[index + 1] = this._colorG;
            data[index + 2] = this._colorB;
            data[index + 3] = this._alpha;
        }
    };
    /**
     * Updates the ambient color data used by the render state.
     */
    AmbientBasicMethod.prototype.updateColor = function () {
        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._ambient;
        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._ambient;
        this._colorB = (this._color & 0xff) / 0xff * this._ambient;
    };
    return AmbientBasicMethod;
})(ShadingMethodBase);
module.exports = AmbientBasicMethod;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":194,"awayjs-stagegl/lib/base/ContextGLTextureFilter":197,"awayjs-stagegl/lib/base/ContextGLWrapMode":200,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":223,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":231}],218:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var LightingMethodBase = require("awayjs-stagegl/lib/materials/methods/LightingMethodBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.
 */
var DiffuseBasicMethod = (function (_super) {
    __extends(DiffuseBasicMethod, _super);
    /**
     * Creates a new DiffuseBasicMethod object.
     */
    function DiffuseBasicMethod() {
        _super.call(this);
        this._multiply = true;
        this._diffuseColor = 0xffffff;
        this._ambientColor = 0xffffff;
        this._diffuseR = 1;
        this._diffuseG = 1;
        this._diffuseB = 1;
        this._ambientR = 1;
        this._ambientG = 1;
        this._ambientB = 1;
    }
    DiffuseBasicMethod.prototype.iIsUsed = function (shaderObject) {
        if (!shaderObject.numLights)
            return false;
        return true;
    };
    Object.defineProperty(DiffuseBasicMethod.prototype, "multiply", {
        /**
         * Set internally if diffuse color component multiplies or replaces the ambient color
         */
        get: function () {
            return this._multiply;
        },
        set: function (value) {
            if (this._multiply == value)
                return;
            this._multiply = value;
            this.iInvalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    DiffuseBasicMethod.prototype.iInitVO = function (shaderObject, methodVO) {
        methodVO.needsUV = this._pUseTexture;
        methodVO.needsNormals = shaderObject.numLights > 0;
    };
    /**
     * Forces the creation of the texture.
     * @param stage The Stage used by the renderer
     */
    DiffuseBasicMethod.prototype.generateMip = function (stage) {
        if (this._pUseTexture)
            stage.context.activateTexture(0, this._texture);
    };
    Object.defineProperty(DiffuseBasicMethod.prototype, "diffuseColor", {
        /**
         * The color of the diffuse reflection when not using a texture.
         */
        get: function () {
            return this._diffuseColor;
        },
        set: function (value) {
            if (this._diffuseColor == value)
                return;
            this._diffuseColor = value;
            this.updateDiffuse();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseBasicMethod.prototype, "ambientColor", {
        /**
         * The color of the ambient reflection
         */
        get: function () {
            return this._ambientColor;
        },
        set: function (value) {
            if (this._ambientColor == value)
                return;
            this._ambientColor = value;
            this.updateAmbient();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseBasicMethod.prototype, "texture", {
        /**
         * The bitmapData to use to define the diffuse reflection color per texel.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            var b = (value != null);
            if (b != this._pUseTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))
                this.iInvalidateShaderProgram();
            this._pUseTexture = b;
            this._texture = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.dispose = function () {
        this._texture = null;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.copyFrom = function (method) {
        var diff = method;
        this.texture = diff.texture;
        this.multiply = diff.multiply;
        this.diffuseColor = diff.diffuseColor;
        this.ambientColor = diff.ambientColor;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iCleanCompilationData = function () {
        _super.prototype.iCleanCompilationData.call(this);
        this._pTotalLightColorReg = null;
        this._pDiffuseInputRegister = null;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (shaderObject, methodVO, registerCache, sharedRegisters) {
        var code = "";
        this._pIsFirstLight = true;
        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._pTotalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        code += "dp3 " + t + ".x, " + lightDirReg + ", " + sharedRegisters.normalFragment + "\n" + "max " + t + ".w, " + t + ".x, " + sharedRegisters.commons + ".y\n";
        if (shaderObject.usesLightFallOff)
            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._iModulateMethod != null)
            code += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);
        code += "mul " + t + ", " + t + ".w, " + lightColReg + "\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._pTotalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        code += "tex " + t + ", " + sharedRegisters.normalFragment + ", " + cubeMapReg + " <cube,linear,miplinear>\n" + "mul " + t + ".xyz, " + t + ".xyz, " + weightRegister + "\n";
        if (this._iModulateMethod != null)
            code += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);
        if (!this._pIsFirstLight) {
            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        var code = "";
        var albedo;
        var cutOffReg;
        // incorporate input from ambient
        if (sharedRegisters.shadowTarget)
            code += this.pApplyShadow(shaderObject, methodVO, registerCache, sharedRegisters);
        albedo = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(albedo, 1);
        var ambientColorRegister = registerCache.getFreeFragmentConstant();
        methodVO.fragmentConstantsIndex = ambientColorRegister.index * 4;
        if (this._pUseTexture) {
            this._pDiffuseInputRegister = registerCache.getFreeTextureReg();
            methodVO.texturesIndex = this._pDiffuseInputRegister.index;
            code += ShaderCompilerHelper.getTex2DSampleCode(albedo, sharedRegisters, this._pDiffuseInputRegister, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);
        }
        else {
            this._pDiffuseInputRegister = registerCache.getFreeFragmentConstant();
            code += "mov " + albedo + ", " + this._pDiffuseInputRegister + "\n";
        }
        code += "sat " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + "\n" + "mul " + albedo + ".xyz, " + albedo + ", " + this._pTotalLightColorReg + "\n";
        if (this._multiply) {
            code += "add " + albedo + ".xyz, " + albedo + ", " + ambientColorRegister + "\n" + "mul " + targetReg + ".xyz, " + targetReg + ", " + albedo + "\n";
        }
        else {
            code += "mul " + targetReg + ".xyz, " + targetReg + ", " + ambientColorRegister + "\n" + "mul " + this._pTotalLightColorReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" + "sub " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" + "add " + targetReg + ".xyz, " + targetReg + ", " + albedo + "\n";
        }
        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
        registerCache.removeFragmentTempUsage(albedo);
        return code;
    };
    /**
     * Generate the code that applies the calculated shadow to the diffuse light
     * @param methodVO The MethodVO object for which the compilation is currently happening.
     * @param regCache The register cache the compiler is currently using for the register management.
     */
    DiffuseBasicMethod.prototype.pApplyShadow = function (shaderObject, methodVO, regCache, sharedRegisters) {
        return "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iActivate = function (shaderObject, methodVO, stage) {
        if (this._pUseTexture) {
            stage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            stage.context.activateTexture(methodVO.texturesIndex, this._texture);
        }
        else {
            var index = methodVO.fragmentConstantsIndex;
            var data = shaderObject.fragmentConstantData;
            data[index + 4] = this._diffuseR;
            data[index + 5] = this._diffuseG;
            data[index + 6] = this._diffuseB;
            data[index + 7] = 1;
        }
    };
    /**
     * Updates the diffuse color data used by the render state.
     */
    DiffuseBasicMethod.prototype.updateDiffuse = function () {
        this._diffuseR = ((this._diffuseColor >> 16) & 0xff) / 0xff;
        this._diffuseG = ((this._diffuseColor >> 8) & 0xff) / 0xff;
        this._diffuseB = (this._diffuseColor & 0xff) / 0xff;
    };
    /**
     * Updates the ambient color data used by the render state.
     */
    DiffuseBasicMethod.prototype.updateAmbient = function () {
        this._ambientR = ((this._ambientColor >> 16) & 0xff) / 0xff;
        this._ambientG = ((this._ambientColor >> 8) & 0xff) / 0xff;
        this._ambientB = (this._ambientColor & 0xff) / 0xff;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.iSetRenderState = function (shaderObject, methodVO, renderable, stage, camera) {
        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)
        if (shaderObject.numLights > 0) {
            var index = methodVO.fragmentConstantsIndex;
            var data = shaderObject.fragmentConstantData;
            data[index] = shaderObject.ambientR * this._ambientR;
            data[index + 1] = shaderObject.ambientG * this._ambientG;
            data[index + 2] = shaderObject.ambientB * this._ambientB;
            data[index + 3] = 1;
        }
    };
    return DiffuseBasicMethod;
})(LightingMethodBase);
module.exports = DiffuseBasicMethod;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":194,"awayjs-stagegl/lib/base/ContextGLTextureFilter":197,"awayjs-stagegl/lib/base/ContextGLWrapMode":200,"awayjs-stagegl/lib/materials/methods/LightingMethodBase":221,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":231}],219:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EffectMethodBase = require("awayjs-stagegl/lib/materials/methods/EffectMethodBase");
/**
 * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a
 * ColorTransform object.
 */
var EffectColorTransformMethod = (function (_super) {
    __extends(EffectColorTransformMethod, _super);
    /**
     * Creates a new EffectColorTransformMethod.
     */
    function EffectColorTransformMethod() {
        _super.call(this);
    }
    Object.defineProperty(EffectColorTransformMethod.prototype, "colorTransform", {
        /**
         * The ColorTransform object to transform the colour of the material with.
         */
        get: function () {
            return this._colorTransform;
        },
        set: function (value) {
            this._colorTransform = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    EffectColorTransformMethod.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        var code = "";
        var colorMultReg = registerCache.getFreeFragmentConstant();
        var colorOffsReg = registerCache.getFreeFragmentConstant();
        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;
        //TODO: AGAL <> GLSL
        code += "mul " + targetReg + ", " + targetReg + ", " + colorMultReg + "\n" + "add " + targetReg + ", " + targetReg + ", " + colorOffsReg + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    EffectColorTransformMethod.prototype.iActivate = function (shaderObject, methodVO, stage) {
        var inv = 1 / 0xff;
        var index = methodVO.fragmentConstantsIndex;
        var data = shaderObject.fragmentConstantData;
        data[index] = this._colorTransform.redMultiplier;
        data[index + 1] = this._colorTransform.greenMultiplier;
        data[index + 2] = this._colorTransform.blueMultiplier;
        data[index + 3] = this._colorTransform.alphaMultiplier;
        data[index + 4] = this._colorTransform.redOffset * inv;
        data[index + 5] = this._colorTransform.greenOffset * inv;
        data[index + 6] = this._colorTransform.blueOffset * inv;
        data[index + 7] = this._colorTransform.alphaOffset * inv;
    };
    return EffectColorTransformMethod;
})(EffectMethodBase);
module.exports = EffectColorTransformMethod;


},{"awayjs-stagegl/lib/materials/methods/EffectMethodBase":220}],220:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var ShadingMethodBase = require("awayjs-stagegl/lib/materials/methods/ShadingMethodBase");
/**
 * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,
 * and are in essence post-process effects on the materials.
 */
var EffectMethodBase = (function (_super) {
    __extends(EffectMethodBase, _super);
    function EffectMethodBase() {
        _super.call(this);
    }
    Object.defineProperty(EffectMethodBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AssetType.EFFECTS_METHOD;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register that will be containing the method's output.
     * @private
     */
    EffectMethodBase.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        throw new AbstractMethodError();
        return "";
    };
    return EffectMethodBase;
})(ShadingMethodBase);
module.exports = EffectMethodBase;


},{"awayjs-core/lib/errors/AbstractMethodError":233,"awayjs-core/lib/library/AssetType":247,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":223}],221:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ShadingMethodBase = require("awayjs-stagegl/lib/materials/methods/ShadingMethodBase");
/**
 * LightingMethodBase provides an abstract base method for shading methods that uses lights.
 * Used for diffuse and specular shaders only.
 */
var LightingMethodBase = (function (_super) {
    __extends(LightingMethodBase, _super);
    /**
     * Creates a new LightingMethodBase.
     */
    function LightingMethodBase() {
        _super.call(this);
    }
    /**
     * Get the fragment shader code that will be needed before any per-light code is added.
     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
     * @param regCache The register cache used during the compilation.
     * @private
     */
    LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (shaderObject, methodVO, registerCache, sharedRegisters) {
        return "";
    };
    /**
     * Get the fragment shader code that will generate the code relevant to a single light.
     *
     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
     * @param lightDirReg The register containing the light direction vector.
     * @param lightColReg The register containing the light colour.
     * @param regCache The register cache used during the compilation.
     */
    LightingMethodBase.prototype.iGetFragmentCodePerLight = function (shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
        return "";
    };
    /**
     * Get the fragment shader code that will generate the code relevant to a single light probe object.
     *
     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
     * @param cubeMapReg The register containing the cube map for the current probe
     * @param weightRegister A string representation of the register + component containing the current weight
     * @param regCache The register cache providing any necessary registers to the shader
     */
    LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
        return "";
    };
    /**
     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
     *
     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register containing the final shading output.
     * @private
     */
    LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        return "";
    };
    return LightingMethodBase;
})(ShadingMethodBase);
module.exports = LightingMethodBase;


},{"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":223}],222:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var ShadingMethodBase = require("awayjs-stagegl/lib/materials/methods/ShadingMethodBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * NormalBasicMethod is the default method for standard tangent-space normal mapping.
 */
var NormalBasicMethod = (function (_super) {
    __extends(NormalBasicMethod, _super);
    /**
     * Creates a new NormalBasicMethod object.
     */
    function NormalBasicMethod() {
        _super.call(this);
    }
    NormalBasicMethod.prototype.iIsUsed = function (shaderObject) {
        if (!this._useTexture || !shaderObject.normalDependencies)
            return false;
        return true;
    };
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.iInitVO = function (shaderObject, methodVO) {
        methodVO.needsUV = this._useTexture;
    };
    /**
     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
     */
    NormalBasicMethod.prototype.iOutputsTangentNormals = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.copyFrom = function (method) {
        var s = method;
        var bnm = method;
        if (bnm.normalMap != null)
            this.normalMap = bnm.normalMap;
    };
    Object.defineProperty(NormalBasicMethod.prototype, "normalMap", {
        /**
         * The texture containing the normals per pixel.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            var b = (value != null);
            if (b != this._useTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))
                this.iInvalidateShaderProgram();
            this._useTexture = b;
            this._texture = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.iCleanCompilationData = function () {
        _super.prototype.iCleanCompilationData.call(this);
        this._pNormalTextureRegister = null;
    };
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.dispose = function () {
        if (this._texture)
            this._texture = null;
    };
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.iActivate = function (shaderObject, methodVO, stage) {
        if (methodVO.texturesIndex >= 0) {
            stage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            stage.context.activateTexture(methodVO.texturesIndex, this._texture);
        }
    };
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        this._pNormalTextureRegister = registerCache.getFreeTextureReg();
        methodVO.texturesIndex = this._pNormalTextureRegister.index;
        return ShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedRegisters, this._pNormalTextureRegister, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping) + "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx\n" + "nrm " + targetReg + ".xyz, " + targetReg + "\n";
    };
    return NormalBasicMethod;
})(ShadingMethodBase);
module.exports = NormalBasicMethod;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":194,"awayjs-stagegl/lib/base/ContextGLTextureFilter":197,"awayjs-stagegl/lib/base/ContextGLWrapMode":200,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":223,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":231}],223:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var ShadingMethodEvent = require("awayjs-stagegl/lib/events/ShadingMethodEvent");
/**
 * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
 * the final shading program.
 */
var ShadingMethodBase = (function (_super) {
    __extends(ShadingMethodBase, _super);
    /**
     * Create a new ShadingMethodBase object.
     */
    function ShadingMethodBase() {
        _super.call(this);
    }
    ShadingMethodBase.prototype.iIsUsed = function (shaderObject) {
        return true;
    };
    /**
     * Initializes the properties for a MethodVO, including register and texture indices.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iInitVO = function (shaderObject, methodVO) {
    };
    /**
     * Initializes unchanging shader constants using the data from a MethodVO.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iInitConstants = function (shaderObject, methodVO) {
    };
    /**
     * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.
     */
    ShadingMethodBase.prototype.iUsesTangentSpace = function () {
        return true;
    };
    Object.defineProperty(ShadingMethodBase.prototype, "passes", {
        /**
         * Any passes required that render to a texture used by this method.
         */
        get: function () {
            return this._passes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cleans up any resources used by the current object.
     */
    ShadingMethodBase.prototype.dispose = function () {
    };
    /**
     * Resets the compilation state of the method.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iReset = function () {
        this.iCleanCompilationData();
    };
    /**
     * Resets the method's state for compilation.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iCleanCompilationData = function () {
    };
    /**
     * Get the vertex shader code for this method.
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iGetVertexCode = function (shaderObject, methodVO, registerCache, sharedRegisters) {
        return "";
    };
    /**
     * @inheritDoc
     */
    ShadingMethodBase.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        return null;
    };
    /**
     * Sets the render state for this method.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param stage The Stage object currently used for rendering.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iActivate = function (shaderObject, methodVO, stage) {
    };
    /**
     * Sets the render state for a single renderable.
     *
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param renderable The renderable currently being rendered.
     * @param stage The Stage object currently used for rendering.
     * @param camera The camera from which the scene is currently rendered.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iSetRenderState = function (shaderObject, methodVO, renderable, stage, camera) {
    };
    /**
     * Clears the render state for this method.
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param stage The Stage object currently used for rendering.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iDeactivate = function (shaderObject, methodVO, stage) {
    };
    /**
     * Marks the shader program as invalid, so it will be recompiled before the next render.
     *
     * @internal
     */
    ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {
        this.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));
    };
    /**
     * Copies the state from a ShadingMethodBase object into the current object.
     */
    ShadingMethodBase.prototype.copyFrom = function (method) {
    };
    return ShadingMethodBase;
})(NamedAssetBase);
module.exports = ShadingMethodBase;


},{"awayjs-core/lib/library/NamedAssetBase":248,"awayjs-stagegl/lib/events/ShadingMethodEvent":201}],224:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var LightingMethodBase = require("awayjs-stagegl/lib/materials/methods/LightingMethodBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
 * version of Phong specularity).
 */
var SpecularBasicMethod = (function (_super) {
    __extends(SpecularBasicMethod, _super);
    /**
     * Creates a new SpecularBasicMethod object.
     */
    function SpecularBasicMethod() {
        _super.call(this);
        this._gloss = 50;
        this._specular = 1;
        this._specularColor = 0xffffff;
        this._iSpecularR = 1;
        this._iSpecularG = 1;
        this._iSpecularB = 1;
    }
    SpecularBasicMethod.prototype.iIsUsed = function (shaderObject) {
        if (!shaderObject.numLights)
            return false;
        return true;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iInitVO = function (shaderObject, methodVO) {
        methodVO.needsUV = this._pUseTexture;
        methodVO.needsNormals = shaderObject.numLights > 0;
        methodVO.needsView = shaderObject.numLights > 0;
    };
    Object.defineProperty(SpecularBasicMethod.prototype, "gloss", {
        /**
         * The sharpness of the specular highlight.
         */
        get: function () {
            return this._gloss;
        },
        set: function (value) {
            this._gloss = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "specular", {
        /**
         * The overall strength of the specular highlights.
         */
        get: function () {
            return this._specular;
        },
        set: function (value) {
            if (value == this._specular)
                return;
            this._specular = value;
            this.updateSpecular();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "specularColor", {
        /**
         * The colour of the specular reflection of the surface.
         */
        get: function () {
            return this._specularColor;
        },
        set: function (value) {
            if (this._specularColor == value)
                return;
            // specular is now either enabled or disabled
            if (this._specularColor == 0 || value == 0)
                this.iInvalidateShaderProgram();
            this._specularColor = value;
            this.updateSpecular();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "texture", {
        /**
         * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness
         * in the green channel. You can use SpecularBitmapTexture if you want to easily set specular and gloss maps
         * from grayscale images, but prepared images are preferred.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            var b = (value != null);
            if (b != this._pUseTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))
                this.iInvalidateShaderProgram();
            this._pUseTexture = b;
            this._texture = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.copyFrom = function (method) {
        var m = method;
        var bsm = method;
        var spec = bsm; //SpecularBasicMethod(method);
        this.texture = spec.texture;
        this.specular = spec.specular;
        this.specularColor = spec.specularColor;
        this.gloss = spec.gloss;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iCleanCompilationData = function () {
        _super.prototype.iCleanCompilationData.call(this);
        this._pTotalLightColorReg = null;
        this._pSpecularTextureRegister = null;
        this._pSpecularTexData = null;
        this._pSpecularDataRegister = null;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (shaderObject, methodVO, registerCache, sharedRegisters) {
        var code = "";
        this._pIsFirstLight = true;
        this._pSpecularDataRegister = registerCache.getFreeFragmentConstant();
        methodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;
        if (this._pUseTexture) {
            this._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(this._pSpecularTexData, 1);
            this._pSpecularTextureRegister = registerCache.getFreeTextureReg();
            methodVO.texturesIndex = this._pSpecularTextureRegister.index;
            code = ShaderCompilerHelper.getTex2DSampleCode(this._pSpecularTexData, sharedRegisters, this._pSpecularTextureRegister, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);
        }
        else {
            this._pSpecularTextureRegister = null;
        }
        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        if (this._pIsFirstLight) {
            t = this._pTotalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        var viewDirReg = sharedRegisters.viewDirFragment;
        var normalReg = sharedRegisters.normalFragment;
        // blinn-phong half vector model
        code += "add " + t + ", " + lightDirReg + ", " + viewDirReg + "\n" + "nrm " + t + ".xyz, " + t + "\n" + "dp3 " + t + ".w, " + normalReg + ", " + t + "\n" + "sat " + t + ".w, " + t + ".w\n";
        if (this._pUseTexture) {
            // apply gloss modulation from texture
            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
        }
        else {
            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
        }
        // attenuate
        if (shaderObject.usesLightFallOff)
            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._iModulateMethod != null)
            code += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);
        code += "mul " + t + ".xyz, " + lightColReg + ", " + t + ".w\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._pTotalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        var normalReg = sharedRegisters.normalFragment;
        var viewDirReg = sharedRegisters.viewDirFragment;
        code += "dp3 " + t + ".w, " + normalReg + ", " + viewDirReg + "\n" + "add " + t + ".w, " + t + ".w, " + t + ".w\n" + "mul " + t + ", " + t + ".w, " + normalReg + "\n" + "sub " + t + ", " + t + ", " + viewDirReg + "\n" + "tex " + t + ", " + t + ", " + cubeMapReg + " <cube," + (shaderObject.useSmoothTextures ? "linear" : "nearest") + ",miplinear>\n" + "mul " + t + ".xyz, " + t + ", " + weightRegister + "\n";
        if (this._iModulateMethod != null)
            code += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);
        if (!this._pIsFirstLight) {
            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        var code = "";
        if (sharedRegisters.shadowTarget)
            code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
        if (this._pUseTexture) {
            // apply strength modulation from texture
            code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularTexData + ".x\n";
            registerCache.removeFragmentTempUsage(this._pSpecularTexData);
        }
        // apply material's specular reflection
        code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularDataRegister + "\n" + "add " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n";
        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.iActivate = function (shaderObject, methodVO, stage) {
        if (this._pUseTexture) {
            stage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            stage.context.activateTexture(methodVO.texturesIndex, this._texture);
        }
        var index = methodVO.fragmentConstantsIndex;
        var data = shaderObject.fragmentConstantData;
        data[index] = this._iSpecularR;
        data[index + 1] = this._iSpecularG;
        data[index + 2] = this._iSpecularB;
        data[index + 3] = this._gloss;
    };
    /**
     * Updates the specular color data used by the render state.
     */
    SpecularBasicMethod.prototype.updateSpecular = function () {
        this._iSpecularR = ((this._specularColor >> 16) & 0xff) / 0xff * this._specular;
        this._iSpecularG = ((this._specularColor >> 8) & 0xff) / 0xff * this._specular;
        this._iSpecularB = (this._specularColor & 0xff) / 0xff * this._specular;
    };
    return SpecularBasicMethod;
})(LightingMethodBase);
module.exports = SpecularBasicMethod;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":194,"awayjs-stagegl/lib/base/ContextGLTextureFilter":197,"awayjs-stagegl/lib/base/ContextGLWrapMode":200,"awayjs-stagegl/lib/materials/methods/LightingMethodBase":221,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":231}],225:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var MaterialPassBase = require("awayjs-stagegl/lib/materials/passes/MaterialPassBase");
/**
 * LineBasicPass is a material pass that draws wireframe segments.
 */
var LineBasicPass = (function (_super) {
    __extends(LineBasicPass, _super);
    /**
     * Creates a new SegmentPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function LineBasicPass() {
        _super.call(this);
    }
    /**
     * @inheritDoc
     */
    LineBasicPass.prototype._iGetFragmentCode = function (shaderObject, regCache, sharedReg) {
        var targetReg = sharedReg.shadedTarget;
        return "mov " + targetReg + ", v0\n";
    };
    return LineBasicPass;
})(MaterialPassBase);
module.exports = LineBasicPass;


},{"awayjs-stagegl/lib/materials/passes/MaterialPassBase":226}],226:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var ArgumentError = require("awayjs-core/lib/errors/ArgumentError");
var Event = require("awayjs-core/lib/events/Event");
var BlendMode = require("awayjs-display/lib/base/BlendMode");
var ContextGLBlendFactor = require("awayjs-stagegl/lib/base/ContextGLBlendFactor");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
var ShaderObjectBase = require("awayjs-stagegl/lib/materials/compilation/ShaderObjectBase");
var MaterialPassMode = require("awayjs-stagegl/lib/materials/passes/MaterialPassMode");
/**
 * MaterialPassBase provides an abstract base class for material shader passes. A material pass constitutes at least
 * a render call per required renderable.
 */
var MaterialPassBase = (function (_super) {
    __extends(MaterialPassBase, _super);
    /**
     * Creates a new MaterialPassBase object.
     */
    function MaterialPassBase(passMode) {
        var _this = this;
        if (passMode === void 0) { passMode = 0x03; }
        _super.call(this);
        this._materialPassData = new Array();
        this._maxLights = 3;
        this._preserveAlpha = true;
        this._includeCasters = true;
        this._forceSeparateMVP = false;
        this._directionalLightsOffset = 0;
        this._pointLightsOffset = 0;
        this._lightProbesOffset = 0;
        this._pNumPointLights = 0;
        this._pNumDirectionalLights = 0;
        this._pNumLightProbes = 0;
        this._pNumLights = 0;
        this._depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
        this._blendFactorSource = ContextGLBlendFactor.ONE;
        this._blendFactorDest = ContextGLBlendFactor.ZERO;
        this._pEnableBlending = false;
        this._writeDepth = true;
        this._passMode = passMode;
        this._onLightsChangeDelegate = function (event) { return _this.onLightsChange(event); };
    }
    Object.defineProperty(MaterialPassBase.prototype, "preserveAlpha", {
        /**
         * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
         */
        get: function () {
            return this._preserveAlpha;
        },
        set: function (value) {
            if (this._preserveAlpha == value)
                return;
            this._preserveAlpha = value;
            this._pInvalidatePass();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "includeCasters", {
        /**
         * Indicates whether or not shadow casting lights need to be included.
         */
        get: function () {
            return this._includeCasters;
        },
        set: function (value) {
            if (this._includeCasters == value)
                return;
            this._includeCasters = value;
            this._pInvalidatePass();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "forceSeparateMVP", {
        /**
         * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
         * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
         * projection code.
         */
        get: function () {
            return this._forceSeparateMVP;
        },
        set: function (value) {
            if (this._forceSeparateMVP == value)
                return;
            this._forceSeparateMVP = value;
            this._pInvalidatePass();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "directionalLightsOffset", {
        /**
         * Indicates the offset in the light picker's directional light vector for which to start including lights.
         * This needs to be set before the light picker is assigned.
         */
        get: function () {
            return this._directionalLightsOffset;
        },
        set: function (value) {
            this._directionalLightsOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "pointLightsOffset", {
        /**
         * Indicates the offset in the light picker's point light vector for which to start including lights.
         * This needs to be set before the light picker is assigned.
         */
        get: function () {
            return this._pointLightsOffset;
        },
        set: function (value) {
            this._pointLightsOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "lightProbesOffset", {
        /**
         * Indicates the offset in the light picker's light probes vector for which to start including lights.
         * This needs to be set before the light picker is assigned.
         */
        get: function () {
            return this._lightProbesOffset;
        },
        set: function (value) {
            this._lightProbesOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "passMode", {
        /**
         *
         */
        get: function () {
            return this._passMode;
        },
        set: function (value) {
            this._passMode = value;
            this._pInvalidatePass();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Factory method to create a concrete shader object for this pass.
     *
     * @param profile The compatibility profile used by the renderer.
     */
    MaterialPassBase.prototype.createShaderObject = function (profile) {
        return new ShaderObjectBase(profile);
    };
    Object.defineProperty(MaterialPassBase.prototype, "writeDepth", {
        /**
         * Indicate whether this pass should write to the depth buffer or not. Ignored when blending is enabled.
         */
        get: function () {
            return this._writeDepth;
        },
        set: function (value) {
            this._writeDepth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "depthCompareMode", {
        /**
         * The depth compare mode used to render the renderables using this material.
         *
         * @see away.stagegl.ContextGLCompareMode
         */
        get: function () {
            return this._depthCompareMode;
        },
        set: function (value) {
            this._depthCompareMode = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cleans up any resources used by the current object.
     * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
     */
    MaterialPassBase.prototype.dispose = function () {
        if (this._pLightPicker)
            this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);
        while (this._materialPassData.length)
            this._materialPassData[0].dispose();
        this._materialPassData = null;
    };
    /**
     * Renders an object to the current render target.
     *
     * @private
     */
    MaterialPassBase.prototype._iRender = function (pass, renderable, stage, camera, viewProjection) {
        this.setRenderState(pass, renderable, stage, camera, viewProjection);
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    MaterialPassBase.prototype.setRenderState = function (pass, renderable, stage, camera, viewProjection) {
        pass.shaderObject.setRenderState(renderable, stage, camera, viewProjection);
    };
    /**
     * The blend mode to use when drawing this renderable. The following blend modes are supported:
     * <ul>
     * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
     * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
     * <li>BlendMode.MULTIPLY</li>
     * <li>BlendMode.ADD</li>
     * <li>BlendMode.ALPHA</li>
     * </ul>
     */
    MaterialPassBase.prototype.setBlendMode = function (value) {
        switch (value) {
            case BlendMode.NORMAL:
                this._blendFactorSource = ContextGLBlendFactor.ONE;
                this._blendFactorDest = ContextGLBlendFactor.ZERO;
                this._pEnableBlending = false;
                break;
            case BlendMode.LAYER:
                this._blendFactorSource = ContextGLBlendFactor.SOURCE_ALPHA;
                this._blendFactorDest = ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                this._pEnableBlending = true;
                break;
            case BlendMode.MULTIPLY:
                this._blendFactorSource = ContextGLBlendFactor.ZERO;
                this._blendFactorDest = ContextGLBlendFactor.SOURCE_COLOR;
                this._pEnableBlending = true;
                break;
            case BlendMode.ADD:
                this._blendFactorSource = ContextGLBlendFactor.SOURCE_ALPHA;
                this._blendFactorDest = ContextGLBlendFactor.ONE;
                this._pEnableBlending = true;
                break;
            case BlendMode.ALPHA:
                this._blendFactorSource = ContextGLBlendFactor.ZERO;
                this._blendFactorDest = ContextGLBlendFactor.SOURCE_ALPHA;
                this._pEnableBlending = true;
                break;
            default:
                throw new ArgumentError("Unsupported blend mode!");
        }
    };
    /**
     * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
     * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
     * @param stage The Stage object which is currently used for rendering.
     * @param camera The camera from which the scene is viewed.
     * @private
     */
    MaterialPassBase.prototype._iActivate = function (pass, stage, camera) {
        var context = stage.context;
        context.setDepthTest((this._writeDepth && !this._pEnableBlending), this._depthCompareMode);
        if (this._pEnableBlending)
            context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
        context.activateMaterialPass(pass, stage, camera);
    };
    /**
     * Clears the render state for the pass. This needs to be called before activating another pass.
     * @param stage The Stage used for rendering
     *
     * @private
     */
    MaterialPassBase.prototype._iDeactivate = function (pass, stage) {
        stage.context.deactivateMaterialPass(pass, stage);
        stage.context.setDepthTest(true, ContextGLCompareMode.LESS_EQUAL); // TODO : imeplement
    };
    /**
     * Marks the shader program as invalid, so it will be recompiled before the next render.
     *
     * @param updateMaterial Indicates whether the invalidation should be performed on the entire material. Should always pass "true" unless it's called from the material itself.
     */
    MaterialPassBase.prototype._pInvalidatePass = function () {
        var len = this._materialPassData.length;
        for (var i = 0; i < len; i++)
            this._materialPassData[i].invalidate();
        this.dispatchEvent(new Event(Event.CHANGE));
    };
    Object.defineProperty(MaterialPassBase.prototype, "lightPicker", {
        /**
         * The light picker used by the material to provide lights to the material if it supports lighting.
         *
         * @see away.materials.LightPickerBase
         * @see away.materials.StaticLightPicker
         */
        get: function () {
            return this._pLightPicker;
        },
        set: function (value) {
            if (this._pLightPicker)
                this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);
            this._pLightPicker = value;
            if (this._pLightPicker)
                this._pLightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);
            this.pUpdateLights();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called when the light picker's configuration changes.
     */
    MaterialPassBase.prototype.onLightsChange = function (event) {
        this.pUpdateLights();
    };
    /**
     * Implemented by subclasses if the pass uses lights to update the shader.
     */
    MaterialPassBase.prototype.pUpdateLights = function () {
        var numDirectionalLightsOld = this._pNumDirectionalLights;
        var numPointLightsOld = this._pNumPointLights;
        var numLightProbesOld = this._pNumLightProbes;
        if (this._pLightPicker && (this._passMode & MaterialPassMode.LIGHTING)) {
            this._pNumDirectionalLights = this.calculateNumDirectionalLights(this._pLightPicker.numDirectionalLights);
            this._pNumPointLights = this.calculateNumPointLights(this._pLightPicker.numPointLights);
            this._pNumLightProbes = this.calculateNumProbes(this._pLightPicker.numLightProbes);
            if (this._includeCasters) {
                this._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                this._pNumPointLights += this._pLightPicker.numCastingPointLights;
            }
        }
        else {
            this._pNumDirectionalLights = 0;
            this._pNumPointLights = 0;
            this._pNumLightProbes = 0;
        }
        this._pNumLights = this._pNumDirectionalLights + this._pNumPointLights;
        if (numDirectionalLightsOld != this._pNumDirectionalLights || numPointLightsOld != this._pNumPointLights || numLightProbesOld != this._pNumLightProbes)
            this._pInvalidatePass();
    };
    MaterialPassBase.prototype._iIncludeDependencies = function (shaderObject) {
        if (this._forceSeparateMVP)
            shaderObject.globalPosDependencies++;
        shaderObject.outputsNormals = this._pOutputsNormals(shaderObject);
        shaderObject.outputsTangentNormals = shaderObject.outputsNormals && this._pOutputsTangentNormals(shaderObject);
        shaderObject.usesTangentSpace = shaderObject.outputsTangentNormals && this._pUsesTangentSpace(shaderObject);
        if (!shaderObject.usesTangentSpace)
            shaderObject.addWorldSpaceDependencies(Boolean(this._passMode & MaterialPassMode.EFFECTS));
    };
    MaterialPassBase.prototype._iInitConstantData = function (shaderObject) {
    };
    MaterialPassBase.prototype._iGetPreLightingVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    MaterialPassBase.prototype._iGetPreLightingFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    MaterialPassBase.prototype._iGetVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    MaterialPassBase.prototype._iGetFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    MaterialPassBase.prototype._iGetNormalVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    MaterialPassBase.prototype._iGetNormalFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        return "";
    };
    Object.defineProperty(MaterialPassBase.prototype, "iNumPointLights", {
        /**
         * The amount of point lights that need to be supported.
         */
        get: function () {
            return this._pNumPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "iNumDirectionalLights", {
        /**
         * The amount of directional lights that need to be supported.
         */
        get: function () {
            return this._pNumDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPassBase.prototype, "iNumLightProbes", {
        /**
         * The amount of light probes that need to be supported.
         */
        get: function () {
            return this._pNumLightProbes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates whether or not normals are calculated at all.
     */
    MaterialPassBase.prototype._pOutputsNormals = function (shaderObject) {
        return false;
    };
    /**
     * Indicates whether or not normals are calculated in tangent space.
     */
    MaterialPassBase.prototype._pOutputsTangentNormals = function (shaderObject) {
        return false;
    };
    /**
     * Indicates whether or not normals are allowed in tangent space. This is only the case if no object-space
     * dependencies exist.
     */
    MaterialPassBase.prototype._pUsesTangentSpace = function (shaderObject) {
        return false;
    };
    /**
     * Calculates the amount of directional lights this material will support.
     * @param numDirectionalLights The maximum amount of directional lights to support.
     * @return The amount of directional lights this material will support, bounded by the amount necessary.
     */
    MaterialPassBase.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {
        return Math.min(numDirectionalLights - this._directionalLightsOffset, this._maxLights);
    };
    /**
     * Calculates the amount of point lights this material will support.
     * @param numDirectionalLights The maximum amount of point lights to support.
     * @return The amount of point lights this material will support, bounded by the amount necessary.
     */
    MaterialPassBase.prototype.calculateNumPointLights = function (numPointLights) {
        var numFree = this._maxLights - this._pNumDirectionalLights;
        return Math.min(numPointLights - this._pointLightsOffset, numFree);
    };
    /**
     * Calculates the amount of light probes this material will support.
     * @param numDirectionalLights The maximum amount of light probes to support.
     * @return The amount of light probes this material will support, bounded by the amount necessary.
     */
    MaterialPassBase.prototype.calculateNumProbes = function (numLightProbes) {
        var numChannels = 0;
        //			if ((this._pSpecularLightSources & LightSources.PROBES) != 0)
        //				++numChannels;
        //
        //			if ((this._pDiffuseLightSources & LightSources.PROBES) != 0)
        //				++numChannels;
        // 4 channels available
        return Math.min(numLightProbes - this._lightProbesOffset, (4 / numChannels) | 0);
    };
    MaterialPassBase.prototype._iAddMaterialPassData = function (materialPassData) {
        this._materialPassData.push(materialPassData);
        return materialPassData;
    };
    MaterialPassBase.prototype._iRemoveMaterialPassData = function (materialPassData) {
        this._materialPassData.splice(this._materialPassData.indexOf(materialPassData), 1);
        return materialPassData;
    };
    return MaterialPassBase;
})(NamedAssetBase);
module.exports = MaterialPassBase;


},{"awayjs-core/lib/errors/ArgumentError":234,"awayjs-core/lib/events/Event":237,"awayjs-core/lib/library/NamedAssetBase":248,"awayjs-display/lib/base/BlendMode":256,"awayjs-stagegl/lib/base/ContextGLBlendFactor":192,"awayjs-stagegl/lib/base/ContextGLCompareMode":193,"awayjs-stagegl/lib/materials/compilation/ShaderObjectBase":213,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":227}],227:[function(require,module,exports){
var MaterialPassMode = (function () {
    function MaterialPassMode() {
    }
    MaterialPassMode.EFFECTS = 0x01;
    /**
     *
     */
    MaterialPassMode.LIGHTING = 0x02;
    /**
     *
     */
    MaterialPassMode.SUPER_SHADER = 0x03;
    return MaterialPassMode;
})();
module.exports = MaterialPassMode;


},{}],228:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var MaterialPassBase = require("awayjs-stagegl/lib/materials/passes/MaterialPassBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
 * using material methods to define their appearance.
 */
var TriangleBasicPass = (function (_super) {
    __extends(TriangleBasicPass, _super);
    /**
     * Creates a new CompiledPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function TriangleBasicPass() {
        _super.call(this);
        this._diffuseColor = 0xffffff;
        this._diffuseR = 1;
        this._diffuseG = 1;
        this._diffuseB = 1;
        this._diffuseA = 1;
    }
    Object.defineProperty(TriangleBasicPass.prototype, "diffuseAlpha", {
        /**
         * The alpha component of the diffuse reflection.
         */
        get: function () {
            return this._diffuseA;
        },
        set: function (value) {
            this._diffuseA = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleBasicPass.prototype, "diffuseColor", {
        /**
         * The color of the diffuse reflection when not using a texture.
         */
        get: function () {
            return this._diffuseColor;
        },
        set: function (diffuseColor) {
            this._diffuseColor = diffuseColor;
            this._diffuseR = ((this._diffuseColor >> 16) & 0xff) / 0xff;
            this._diffuseG = ((this._diffuseColor >> 8) & 0xff) / 0xff;
            this._diffuseB = (this._diffuseColor & 0xff) / 0xff;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    TriangleBasicPass.prototype._iGetFragmentCode = function (shaderObject, regCache, sharedReg) {
        var code = "";
        var targetReg = sharedReg.shadedTarget;
        var diffuseInputReg;
        if (shaderObject.texture != null) {
            diffuseInputReg = regCache.getFreeTextureReg();
            this._texturesIndex = diffuseInputReg.index;
            code += ShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedReg, diffuseInputReg, shaderObject.texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);
            if (shaderObject.alphaThreshold > 0) {
                var cutOffReg = regCache.getFreeFragmentConstant();
                this._fragmentConstantsIndex = cutOffReg.index * 4;
                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" + "kil " + targetReg + ".w\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
            }
        }
        else {
            diffuseInputReg = regCache.getFreeFragmentConstant();
            this._fragmentConstantsIndex = diffuseInputReg.index * 4;
            code += "mov " + targetReg + ", " + diffuseInputReg + "\n";
        }
        return code;
    };
    TriangleBasicPass.prototype._iIncludeDependencies = function (dependencyCounter) {
        if (dependencyCounter.texture != null)
            dependencyCounter.uvDependencies++;
    };
    /**
     * @inheritDoc
     */
    TriangleBasicPass.prototype._iActivate = function (pass, stage, camera) {
        _super.prototype._iActivate.call(this, pass, stage, camera);
        var shaderObject = pass.shaderObject;
        if (shaderObject.texture != null) {
            stage.context.setSamplerStateAt(this._texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            stage.context.activateTexture(this._texturesIndex, shaderObject.texture);
            if (shaderObject.alphaThreshold > 0)
                shaderObject.fragmentConstantData[this._fragmentConstantsIndex] = shaderObject.alphaThreshold;
        }
        else {
            var index = this._fragmentConstantsIndex;
            var data = shaderObject.fragmentConstantData;
            data[index] = this._diffuseR;
            data[index + 1] = this._diffuseG;
            data[index + 2] = this._diffuseB;
            data[index + 3] = this._diffuseA;
        }
    };
    return TriangleBasicPass;
})(MaterialPassBase);
module.exports = TriangleBasicPass;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":194,"awayjs-stagegl/lib/base/ContextGLTextureFilter":197,"awayjs-stagegl/lib/base/ContextGLWrapMode":200,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":226,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":231}],229:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ShadingMethodEvent = require("awayjs-stagegl/lib/events/ShadingMethodEvent");
var MethodVO = require("awayjs-stagegl/lib/materials/compilation/MethodVO");
var ShaderLightingObject = require("awayjs-stagegl/lib/materials/compilation/ShaderLightingObject");
var ShaderObjectBase = require("awayjs-stagegl/lib/materials/compilation/ShaderObjectBase");
var EffectColorTransformMethod = require("awayjs-stagegl/lib/materials/methods/EffectColorTransformMethod");
var MaterialPassBase = require("awayjs-stagegl/lib/materials/passes/MaterialPassBase");
var MaterialPassMode = require("awayjs-stagegl/lib/materials/passes/MaterialPassMode");
/**
 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
 * using material methods to define their appearance.
 */
var TriangleMethodPass = (function (_super) {
    __extends(TriangleMethodPass, _super);
    /**
     * Creates a new CompiledPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function TriangleMethodPass(passMode) {
        var _this = this;
        if (passMode === void 0) { passMode = 0x03; }
        _super.call(this, passMode);
        this._iMethodVOs = new Array();
        this._numEffectDependencies = 0;
        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
    }
    /**
     * Factory method to create a concrete shader object for this pass.
     *
     * @param profile The compatibility profile used by the renderer.
     */
    TriangleMethodPass.prototype.createShaderObject = function (profile) {
        if (this._pLightPicker && (this.passMode & MaterialPassMode.LIGHTING))
            return new ShaderLightingObject(profile);
        return new ShaderObjectBase(profile);
    };
    /**
     * Initializes the unchanging constant data for this material.
     */
    TriangleMethodPass.prototype._iInitConstantData = function (shaderObject) {
        _super.prototype._iInitConstantData.call(this, shaderObject);
        //Updates method constants if they have changed.
        var len = this._iMethodVOs.length;
        for (var i = 0; i < len; ++i)
            this._iMethodVOs[i].method.iInitConstants(shaderObject, this._iMethodVOs[i]);
    };
    Object.defineProperty(TriangleMethodPass.prototype, "colorTransform", {
        /**
         * The ColorTransform object to transform the colour of the material with. Defaults to null.
         */
        get: function () {
            return this.colorTransformMethod ? this.colorTransformMethod.colorTransform : null;
        },
        set: function (value) {
            if (value) {
                if (this.colorTransformMethod == null)
                    this.colorTransformMethod = new EffectColorTransformMethod();
                this.colorTransformMethod.colorTransform = value;
            }
            else if (!value) {
                if (this.colorTransformMethod)
                    this.colorTransformMethod = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodPass.prototype, "colorTransformMethod", {
        /**
         * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.
         */
        get: function () {
            return this._iColorTransformMethodVO ? this._iColorTransformMethodVO.method : null;
        },
        set: function (value) {
            if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)
                return;
            if (this._iColorTransformMethodVO) {
                this._removeDependency(this._iColorTransformMethodVO);
                this._iColorTransformMethodVO = null;
            }
            if (value) {
                this._iColorTransformMethodVO = new MethodVO(value);
                this._addDependency(this._iColorTransformMethodVO);
            }
        },
        enumerable: true,
        configurable: true
    });
    TriangleMethodPass.prototype._removeDependency = function (methodVO, effectsDependency) {
        if (effectsDependency === void 0) { effectsDependency = false; }
        var index = this._iMethodVOs.indexOf(methodVO);
        if (!effectsDependency)
            this._numEffectDependencies--;
        methodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
        this._iMethodVOs.splice(index, 1);
        this._pInvalidatePass();
    };
    TriangleMethodPass.prototype._addDependency = function (methodVO, effectsDependency, index) {
        if (effectsDependency === void 0) { effectsDependency = false; }
        if (index === void 0) { index = -1; }
        methodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
        if (effectsDependency) {
            if (index != -1)
                this._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);
            else
                this._iMethodVOs.push(methodVO);
            this._numEffectDependencies++;
        }
        else {
            this._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);
        }
        this._pInvalidatePass();
    };
    /**
     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
     * methods added prior.
     */
    TriangleMethodPass.prototype.addEffectMethod = function (method) {
        this._addDependency(new MethodVO(method), true);
    };
    Object.defineProperty(TriangleMethodPass.prototype, "numEffectMethods", {
        /**
         * The number of "effect" methods added to the material.
         */
        get: function () {
            return this._numEffectDependencies;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Queries whether a given effects method was added to the material.
     *
     * @param method The method to be queried.
     * @return true if the method was added to the material, false otherwise.
     */
    TriangleMethodPass.prototype.hasEffectMethod = function (method) {
        return this.getDependencyForMethod(method) != null;
    };
    /**
     * Returns the method added at the given index.
     * @param index The index of the method to retrieve.
     * @return The method at the given index.
     */
    TriangleMethodPass.prototype.getEffectMethodAt = function (index) {
        if (index < 0 || index > this._numEffectDependencies - 1)
            return null;
        return this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;
    };
    /**
     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
     * etc. The method will be applied to the result of the methods with a lower index.
     */
    TriangleMethodPass.prototype.addEffectMethodAt = function (method, index) {
        this._addDependency(new MethodVO(method), true, index);
    };
    /**
     * Removes an effect method from the material.
     * @param method The method to be removed.
     */
    TriangleMethodPass.prototype.removeEffectMethod = function (method) {
        var methodVO = this.getDependencyForMethod(method);
        if (methodVO != null)
            this._removeDependency(methodVO, true);
    };
    TriangleMethodPass.prototype.getDependencyForMethod = function (method) {
        var len = this._iMethodVOs.length;
        for (var i = 0; i < len; ++i)
            if (this._iMethodVOs[i].method == method)
                return this._iMethodVOs[i];
        return null;
    };
    Object.defineProperty(TriangleMethodPass.prototype, "normalMethod", {
        /**
         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
         */
        get: function () {
            return this._iNormalMethodVO ? this._iNormalMethodVO.method : null;
        },
        set: function (value) {
            if (this._iNormalMethodVO && this._iNormalMethodVO.method == value)
                return;
            if (this._iNormalMethodVO) {
                this._removeDependency(this._iNormalMethodVO);
                this._iNormalMethodVO = null;
            }
            if (value) {
                this._iNormalMethodVO = new MethodVO(value);
                this._addDependency(this._iNormalMethodVO);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodPass.prototype, "ambientMethod", {
        /**
         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
         */
        get: function () {
            return this._iAmbientMethodVO ? this._iAmbientMethodVO.method : null;
        },
        set: function (value) {
            if (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)
                return;
            if (this._iAmbientMethodVO) {
                this._removeDependency(this._iAmbientMethodVO);
                this._iAmbientMethodVO = null;
            }
            if (value) {
                this._iAmbientMethodVO = new MethodVO(value);
                this._addDependency(this._iAmbientMethodVO);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodPass.prototype, "shadowMethod", {
        /**
         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
         */
        get: function () {
            return this._iShadowMethodVO ? this._iShadowMethodVO.method : null;
        },
        set: function (value) {
            if (this._iShadowMethodVO && this._iShadowMethodVO.method == value)
                return;
            if (this._iShadowMethodVO) {
                this._removeDependency(this._iShadowMethodVO);
                this._iShadowMethodVO = null;
            }
            if (value) {
                this._iShadowMethodVO = new MethodVO(value);
                this._addDependency(this._iShadowMethodVO);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodPass.prototype, "diffuseMethod", {
        /**
         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
         */
        get: function () {
            return this._iDiffuseMethodVO ? this._iDiffuseMethodVO.method : null;
        },
        set: function (value) {
            if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)
                return;
            if (this._iDiffuseMethodVO) {
                this._removeDependency(this._iDiffuseMethodVO);
                this._iDiffuseMethodVO = null;
            }
            if (value) {
                this._iDiffuseMethodVO = new MethodVO(value);
                this._addDependency(this._iDiffuseMethodVO);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleMethodPass.prototype, "specularMethod", {
        /**
         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
         */
        get: function () {
            return this._iSpecularMethodVO ? this._iSpecularMethodVO.method : null;
        },
        set: function (value) {
            if (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)
                return;
            if (this._iSpecularMethodVO) {
                this._removeDependency(this._iSpecularMethodVO);
                this._iSpecularMethodVO = null;
            }
            if (value) {
                this._iSpecularMethodVO = new MethodVO(value);
                this._addDependency(this._iSpecularMethodVO);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    TriangleMethodPass.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        while (this._iMethodVOs.length)
            this._removeDependency(this._iMethodVOs[0]);
        this._iMethodVOs = null;
    };
    /**
     * Called when any method's shader code is invalidated.
     */
    TriangleMethodPass.prototype.onShaderInvalidated = function (event) {
        this._pInvalidatePass();
    };
    // RENDER LOOP
    /**
     * @inheritDoc
     */
    TriangleMethodPass.prototype._iActivate = function (pass, stage, camera) {
        _super.prototype._iActivate.call(this, pass, stage, camera);
        var methodVO;
        var len = this._iMethodVOs.length;
        for (var i = 0; i < len; ++i) {
            methodVO = this._iMethodVOs[i];
            if (methodVO.useMethod)
                methodVO.method.iActivate(pass.shaderObject, methodVO, stage);
        }
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    TriangleMethodPass.prototype.setRenderState = function (pass, renderable, stage, camera, viewProjection) {
        _super.prototype.setRenderState.call(this, pass, renderable, stage, camera, viewProjection);
        var methodVO;
        var len = this._iMethodVOs.length;
        for (var i = 0; i < len; ++i) {
            methodVO = this._iMethodVOs[i];
            if (methodVO.useMethod)
                methodVO.method.iSetRenderState(pass.shaderObject, methodVO, renderable, stage, camera);
        }
    };
    /**
     * @inheritDoc
     */
    TriangleMethodPass.prototype._iDeactivate = function (pass, stage) {
        _super.prototype._iDeactivate.call(this, pass, stage);
        var methodVO;
        var len = this._iMethodVOs.length;
        for (var i = 0; i < len; ++i) {
            methodVO = this._iMethodVOs[i];
            if (methodVO.useMethod)
                methodVO.method.iDeactivate(pass.shaderObject, methodVO, stage);
        }
    };
    TriangleMethodPass.prototype._iIncludeDependencies = function (shaderObject) {
        var i;
        var len = this._iMethodVOs.length;
        for (i = 0; i < len; ++i)
            this.setupAndCountDependencies(shaderObject, this._iMethodVOs[i]);
        for (i = 0; i < len; ++i)
            this._iMethodVOs[i].useMethod = this._iMethodVOs[i].method.iIsUsed(shaderObject);
        _super.prototype._iIncludeDependencies.call(this, shaderObject);
    };
    /**
     * Counts the dependencies for a given method.
     * @param method The method to count the dependencies for.
     * @param methodVO The method's data for this material.
     */
    TriangleMethodPass.prototype.setupAndCountDependencies = function (shaderObject, methodVO) {
        methodVO.reset();
        methodVO.method.iInitVO(shaderObject, methodVO);
        if (methodVO.needsProjection)
            shaderObject.projectionDependencies++;
        if (methodVO.needsGlobalVertexPos) {
            shaderObject.globalPosDependencies++;
            if (methodVO.needsGlobalFragmentPos)
                shaderObject.usesGlobalPosFragment = true;
        }
        else if (methodVO.needsGlobalFragmentPos) {
            shaderObject.globalPosDependencies++;
            shaderObject.usesGlobalPosFragment = true;
        }
        if (methodVO.needsNormals)
            shaderObject.normalDependencies++;
        if (methodVO.needsTangents)
            shaderObject.tangentDependencies++;
        if (methodVO.needsView)
            shaderObject.viewDirDependencies++;
        if (methodVO.needsUV)
            shaderObject.uvDependencies++;
        if (methodVO.needsSecondaryUV)
            shaderObject.secondaryUVDependencies++;
    };
    TriangleMethodPass.prototype._iGetPreLightingVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = "";
        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)
            code += this._iAmbientMethodVO.method.iGetVertexCode(shaderObject, this._iAmbientMethodVO, registerCache, sharedRegisters);
        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)
            code += this._iDiffuseMethodVO.method.iGetVertexCode(shaderObject, this._iDiffuseMethodVO, registerCache, sharedRegisters);
        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)
            code += this._iSpecularMethodVO.method.iGetVertexCode(shaderObject, this._iSpecularMethodVO, registerCache, sharedRegisters);
        return code;
    };
    TriangleMethodPass.prototype._iGetPreLightingFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = "";
        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {
            code += this._iAmbientMethodVO.method.iGetFragmentCode(shaderObject, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);
            if (this._iAmbientMethodVO.needsNormals)
                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
            if (this._iAmbientMethodVO.needsView)
                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        }
        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)
            code += this._iDiffuseMethodVO.method.iGetFragmentPreLightingCode(shaderObject, this._iDiffuseMethodVO, registerCache, sharedRegisters);
        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)
            code += this._iSpecularMethodVO.method.iGetFragmentPreLightingCode(shaderObject, this._iSpecularMethodVO, registerCache, sharedRegisters);
        return code;
    };
    TriangleMethodPass.prototype._iGetPerLightDiffuseFragmentCode = function (shaderObject, lightDirReg, diffuseColorReg, registerCache, sharedRegisters) {
        return this._iDiffuseMethodVO.method.iGetFragmentCodePerLight(shaderObject, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);
    };
    TriangleMethodPass.prototype._iGetPerLightSpecularFragmentCode = function (shaderObject, lightDirReg, specularColorReg, registerCache, sharedRegisters) {
        return this._iSpecularMethodVO.method.iGetFragmentCodePerLight(shaderObject, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);
    };
    TriangleMethodPass.prototype._iGetPerProbeDiffuseFragmentCode = function (shaderObject, texReg, weightReg, registerCache, sharedRegisters) {
        return this._iDiffuseMethodVO.method.iGetFragmentCodePerProbe(shaderObject, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);
    };
    TriangleMethodPass.prototype._iGetPerProbeSpecularFragmentCode = function (shaderObject, texReg, weightReg, registerCache, sharedRegisters) {
        return this._iSpecularMethodVO.method.iGetFragmentCodePerProbe(shaderObject, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);
    };
    TriangleMethodPass.prototype._iGetPostLightingVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = "";
        if (this._iShadowMethodVO)
            code += this._iShadowMethodVO.method.iGetVertexCode(shaderObject, this._iShadowMethodVO, registerCache, sharedRegisters);
        return code;
    };
    TriangleMethodPass.prototype._iGetPostLightingFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = "";
        if (shaderObject.useAlphaPremultiplied && this._pEnableBlending) {
            code += "add " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.commons + ".z\n" + "div " + sharedRegisters.shadedTarget + ".xyz, " + sharedRegisters.shadedTarget + ", " + sharedRegisters.shadedTarget + ".w\n" + "sub " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.commons + ".z\n" + "sat " + sharedRegisters.shadedTarget + ".xyz, " + sharedRegisters.shadedTarget + "\n";
        }
        if (this._iShadowMethodVO)
            code += this._iShadowMethodVO.method.iGetFragmentCode(shaderObject, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);
        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {
            code += this._iDiffuseMethodVO.method.iGetFragmentPostLightingCode(shaderObject, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);
            // resolve other dependencies as well?
            if (this._iDiffuseMethodVO.needsNormals)
                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
            if (this._iDiffuseMethodVO.needsView)
                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        }
        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {
            code += this._iSpecularMethodVO.method.iGetFragmentPostLightingCode(shaderObject, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);
            if (this._iSpecularMethodVO.needsNormals)
                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
            if (this._iSpecularMethodVO.needsView)
                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        }
        if (this._iShadowMethodVO)
            registerCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);
        return code;
    };
    /**
     * Indicates whether or not normals are allowed in tangent space. This is only the case if no object-space
     * dependencies exist.
     */
    TriangleMethodPass.prototype._pUsesTangentSpace = function (shaderObject) {
        if (shaderObject.usesProbes)
            return false;
        var methodVO;
        var len = this._iMethodVOs.length;
        for (var i = 0; i < len; ++i) {
            methodVO = this._iMethodVOs[i];
            if (methodVO.useMethod && !methodVO.method.iUsesTangentSpace())
                return false;
        }
        return true;
    };
    /**
     * Indicates whether or not normals are output in tangent space.
     */
    TriangleMethodPass.prototype._pOutputsTangentNormals = function (shaderObject) {
        return this._iNormalMethodVO.method.iOutputsTangentNormals();
    };
    /**
     * Indicates whether or not normals are output by the pass.
     */
    TriangleMethodPass.prototype._pOutputsNormals = function (shaderObject) {
        return this._iNormalMethodVO && this._iNormalMethodVO.useMethod;
    };
    TriangleMethodPass.prototype._iGetNormalVertexCode = function (shaderObject, registerCache, sharedRegisters) {
        return this._iNormalMethodVO.method.iGetVertexCode(shaderObject, this._iNormalMethodVO, registerCache, sharedRegisters);
    };
    TriangleMethodPass.prototype._iGetNormalFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = this._iNormalMethodVO.method.iGetFragmentCode(shaderObject, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);
        if (this._iNormalMethodVO.needsView)
            registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        if (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)
            registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);
        return code;
    };
    /**
     * @inheritDoc
     */
    TriangleMethodPass.prototype._iGetVertexCode = function (shaderObject, regCache, sharedReg) {
        var code = "";
        var methodVO;
        var len = this._iMethodVOs.length;
        for (var i = len - this._numEffectDependencies; i < len; i++) {
            methodVO = this._iMethodVOs[i];
            if (methodVO.useMethod) {
                code += methodVO.method.iGetVertexCode(shaderObject, methodVO, regCache, sharedReg);
                if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)
                    regCache.removeVertexTempUsage(sharedReg.globalPositionVertex);
            }
        }
        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)
            code += this._iColorTransformMethodVO.method.iGetVertexCode(shaderObject, this._iColorTransformMethodVO, regCache, sharedReg);
        return code;
    };
    /**
     * @inheritDoc
     */
    TriangleMethodPass.prototype._iGetFragmentCode = function (shaderObject, regCache, sharedReg) {
        var code = "";
        var alphaReg;
        if (this.preserveAlpha && this._numEffectDependencies > 0) {
            alphaReg = regCache.getFreeFragmentSingleTemp();
            regCache.addFragmentTempUsages(alphaReg, 1);
            code += "mov " + alphaReg + ", " + sharedReg.shadedTarget + ".w\n";
        }
        var methodVO;
        var len = this._iMethodVOs.length;
        for (var i = len - this._numEffectDependencies; i < len; i++) {
            methodVO = this._iMethodVOs[i];
            if (methodVO.useMethod) {
                code += methodVO.method.iGetFragmentCode(shaderObject, methodVO, sharedReg.shadedTarget, regCache, sharedReg);
                if (methodVO.needsNormals)
                    regCache.removeFragmentTempUsage(sharedReg.normalFragment);
                if (methodVO.needsView)
                    regCache.removeFragmentTempUsage(sharedReg.viewDirFragment);
            }
        }
        if (this.preserveAlpha && this._numEffectDependencies > 0) {
            code += "mov " + sharedReg.shadedTarget + ".w, " + alphaReg + "\n";
            regCache.removeFragmentTempUsage(alphaReg);
        }
        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)
            code += this._iColorTransformMethodVO.method.iGetFragmentCode(shaderObject, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);
        return code;
    };
    /**
     * Indicates whether the shader uses any shadows.
     */
    TriangleMethodPass.prototype._iUsesShadows = function () {
        return Boolean(this._iShadowMethodVO || this.lightPicker.castingDirectionalLights.length > 0 || this.lightPicker.castingPointLights.length > 0);
    };
    /**
     * Indicates whether the shader uses any specular component.
     */
    TriangleMethodPass.prototype._iUsesSpecular = function () {
        return Boolean(this._iSpecularMethodVO);
    };
    return TriangleMethodPass;
})(MaterialPassBase);
module.exports = TriangleMethodPass;


},{"awayjs-stagegl/lib/events/ShadingMethodEvent":201,"awayjs-stagegl/lib/materials/compilation/MethodVO":208,"awayjs-stagegl/lib/materials/compilation/ShaderLightingObject":212,"awayjs-stagegl/lib/materials/compilation/ShaderObjectBase":213,"awayjs-stagegl/lib/materials/methods/EffectColorTransformMethod":219,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":226,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":227}],230:[function(require,module,exports){
var BitmapData = require("awayjs-core/lib/base/BitmapData");
var AssetType = require("awayjs-core/lib/library/AssetType");
var BitmapTexture = require("awayjs-core/lib/textures/BitmapTexture");
var LineBasicMaterial = require("awayjs-stagegl/lib/materials/LineBasicMaterial");
var TriangleBasicMaterial = require("awayjs-stagegl/lib/materials/TriangleBasicMaterial");
var DefaultMaterialManager = (function () {
    function DefaultMaterialManager() {
    }
    DefaultMaterialManager.getDefaultMaterial = function (materialOwner) {
        if (materialOwner === void 0) { materialOwner = null; }
        if (materialOwner != null && materialOwner.assetType == AssetType.LINE_SUB_MESH) {
            if (!DefaultMaterialManager._defaultLineMaterial)
                DefaultMaterialManager.createDefaultLineMaterial();
            return DefaultMaterialManager._defaultLineMaterial;
        }
        else {
            if (!DefaultMaterialManager._defaultTriangleMaterial)
                DefaultMaterialManager.createDefaultTriangleMaterial();
            return DefaultMaterialManager._defaultTriangleMaterial;
        }
    };
    DefaultMaterialManager.getDefaultTexture = function (materialOwner) {
        if (materialOwner === void 0) { materialOwner = null; }
        if (!DefaultMaterialManager._defaultTexture)
            DefaultMaterialManager.createDefaultTexture();
        return DefaultMaterialManager._defaultTexture;
    };
    DefaultMaterialManager.createDefaultTexture = function () {
        DefaultMaterialManager._defaultBitmapData = DefaultMaterialManager.createCheckeredBitmapData();
        DefaultMaterialManager._defaultTexture = new BitmapTexture(DefaultMaterialManager._defaultBitmapData, true);
        DefaultMaterialManager._defaultTexture.name = "defaultTexture";
    };
    DefaultMaterialManager.createCheckeredBitmapData = function () {
        var b = new BitmapData(8, 8, false, 0x000000);
        //create chekerboard
        var i, j;
        for (i = 0; i < 8; i++) {
            for (j = 0; j < 8; j++) {
                if ((j & 1) ^ (i & 1)) {
                    b.setPixel(i, j, 0XFFFFFF);
                }
            }
        }
        return b;
    };
    DefaultMaterialManager.createDefaultTriangleMaterial = function () {
        if (!DefaultMaterialManager._defaultTexture)
            DefaultMaterialManager.createDefaultTexture();
        DefaultMaterialManager._defaultTriangleMaterial = new TriangleBasicMaterial(DefaultMaterialManager._defaultTexture);
        DefaultMaterialManager._defaultTriangleMaterial.mipmap = false;
        DefaultMaterialManager._defaultTriangleMaterial.smooth = false;
        DefaultMaterialManager._defaultTriangleMaterial.name = "defaultTriangleMaterial";
    };
    DefaultMaterialManager.createDefaultLineMaterial = function () {
        DefaultMaterialManager._defaultLineMaterial = new LineBasicMaterial();
        DefaultMaterialManager._defaultLineMaterial.name = "defaultSegmentMaterial";
    };
    return DefaultMaterialManager;
})();
module.exports = DefaultMaterialManager;


},{"awayjs-core/lib/base/BitmapData":232,"awayjs-core/lib/library/AssetType":247,"awayjs-core/lib/textures/BitmapTexture":249,"awayjs-stagegl/lib/materials/LineBasicMaterial":202,"awayjs-stagegl/lib/materials/TriangleBasicMaterial":204}],231:[function(require,module,exports){
var ContextGLTextureFormat = require("awayjs-stagegl/lib/base/ContextGLTextureFormat");
var ShaderCompilerHelper = (function () {
    function ShaderCompilerHelper() {
    }
    /**
     * A helper method that generates standard code for sampling from a texture using the normal uv coordinates.
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param sharedReg The shared register object for the shader.
     * @param inputReg The texture stream register.
     * @param texture The texture which will be assigned to the given slot.
     * @param uvReg An optional uv register if coordinates different from the primary uv coordinates are to be used.
     * @param forceWrap If true, texture wrapping is enabled regardless of the material setting.
     * @return The fragment code that performs the sampling.
     *
     * @protected
     */
    ShaderCompilerHelper.getTex2DSampleCode = function (targetReg, sharedReg, inputReg, texture, smooth, repeat, mipmaps, uvReg, forceWrap) {
        if (uvReg === void 0) { uvReg = null; }
        if (forceWrap === void 0) { forceWrap = null; }
        var wrap = forceWrap || (repeat ? "wrap" : "clamp");
        var format = ShaderCompilerHelper.getFormatStringForTexture(texture);
        var enableMipMaps = mipmaps && texture.hasMipmaps;
        var filter = (smooth) ? (enableMipMaps ? "linear,miplinear" : "linear") : (enableMipMaps ? "nearest,mipnearest" : "nearest");
        if (uvReg == null)
            uvReg = sharedReg.uvVarying;
        return "tex " + targetReg + ", " + uvReg + ", " + inputReg + " <2d," + filter + "," + format + wrap + ">\n";
    };
    /**
     * A helper method that generates standard code for sampling from a cube texture.
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param targetReg The register in which to store the sampled colour.
     * @param inputReg The texture stream register.
     * @param texture The cube map which will be assigned to the given slot.
     * @param uvReg The direction vector with which to sample the cube map.
     *
     * @protected
     */
    ShaderCompilerHelper.getTexCubeSampleCode = function (targetReg, inputReg, texture, smooth, mipmaps, uvReg) {
        var filter;
        var format = ShaderCompilerHelper.getFormatStringForTexture(texture);
        var enableMipMaps = mipmaps && texture.hasMipmaps;
        var filter = (smooth) ? (enableMipMaps ? "linear,miplinear" : "linear") : (enableMipMaps ? "nearest,mipnearest" : "nearest");
        return "tex " + targetReg + ", " + uvReg + ", " + inputReg + " <cube," + format + filter + ">\n";
    };
    /**
     * Generates a texture format string for the sample instruction.
     * @param texture The texture for which to get the format string.
     * @return
     *
     * @protected
     */
    ShaderCompilerHelper.getFormatStringForTexture = function (texture) {
        switch (texture.format) {
            case ContextGLTextureFormat.COMPRESSED:
                return "dxt1,";
                break;
            case ContextGLTextureFormat.COMPRESSED_ALPHA:
                return "dxt5,";
                break;
            default:
                return "";
        }
    };
    return ShaderCompilerHelper;
})();
module.exports = ShaderCompilerHelper;


},{"awayjs-stagegl/lib/base/ContextGLTextureFormat":198}],232:[function(require,module,exports){
module.exports=require(2)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/base/BitmapData.js":2,"awayjs-core/lib/geom/Rectangle":245,"awayjs-core/lib/utils/ColorUtils":253}],233:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":235}],234:[function(require,module,exports){
module.exports=require(4)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/ArgumentError.js":4,"awayjs-core/lib/errors/Error":235}],235:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],236:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":237}],237:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],238:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],239:[function(require,module,exports){
var ColorUtils = require("awayjs-core/lib/utils/ColorUtils");
/**
 * The ColorTransform class lets you adjust the color values in a display
 * object. The color adjustment or <i>color transformation</i> can be applied
 * to all four channels: red, green, blue, and alpha transparency.
 *
 * <p>When a ColorTransform object is applied to a display object, a new value
 * for each color channel is calculated like this:</p>
 *
 * <ul>
 *   <li>New red value = (old red value * <code>redMultiplier</code>) +
 * <code>redOffset</code></li>
 *   <li>New green value = (old green value * <code>greenMultiplier</code>) +
 * <code>greenOffset</code></li>
 *   <li>New blue value = (old blue value * <code>blueMultiplier</code>) +
 * <code>blueOffset</code></li>
 *   <li>New alpha value = (old alpha value * <code>alphaMultiplier</code>) +
 * <code>alphaOffset</code></li>
 * </ul>
 *
 * <p>If any of the color channel values is greater than 255 after the
 * calculation, it is set to 255. If it is less than 0, it is set to 0.</p>
 *
 * <p>You can use ColorTransform objects in the following ways:</p>
 *
 * <ul>
 *   <li>In the <code>colorTransform</code> parameter of the
 * <code>colorTransform()</code> method of the BitmapData class</li>
 *   <li>As the <code>colorTransform</code> property of a Transform object
 * (which can be used as the <code>transform</code> property of a display
 * object)</li>
 * </ul>
 *
 * <p>You must use the <code>new ColorTransform()</code> constructor to create
 * a ColorTransform object before you can call the methods of the
 * ColorTransform object.</p>
 *
 * <p>Color transformations do not apply to the background color of a movie
 * clip(such as a loaded SWF object). They apply only to graphics and symbols
 * that are attached to the movie clip.</p>
 */
var ColorTransform = (function () {
    /**
     * Creates a ColorTransform object for a display object with the specified
     * color channel values and alpha values.
     *
     * @param redMultiplier   The value for the red multiplier, in the range from
     *                        0 to 1.
     * @param greenMultiplier The value for the green multiplier, in the range
     *                        from 0 to 1.
     * @param blueMultiplier  The value for the blue multiplier, in the range
     *                        from 0 to 1.
     * @param alphaMultiplier The value for the alpha transparency multiplier, in
     *                        the range from 0 to 1.
     * @param redOffset       The offset value for the red color channel, in the
     *                        range from -255 to 255.
     * @param greenOffset     The offset value for the green color channel, in
     *                        the range from -255 to 255.
     * @param blueOffset      The offset for the blue color channel value, in the
     *                        range from -255 to 255.
     * @param alphaOffset     The offset for alpha transparency channel value, in
     *                        the range from -255 to 255.
     */
    function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
        if (redMultiplier === void 0) { redMultiplier = 1; }
        if (greenMultiplier === void 0) { greenMultiplier = 1; }
        if (blueMultiplier === void 0) { blueMultiplier = 1; }
        if (alphaMultiplier === void 0) { alphaMultiplier = 1; }
        if (redOffset === void 0) { redOffset = 0; }
        if (greenOffset === void 0) { greenOffset = 0; }
        if (blueOffset === void 0) { blueOffset = 0; }
        if (alphaOffset === void 0) { alphaOffset = 0; }
        this.redMultiplier = redMultiplier;
        this.greenMultiplier = greenMultiplier;
        this.blueMultiplier = blueMultiplier;
        this.alphaMultiplier = alphaMultiplier;
        this.redOffset = redOffset;
        this.greenOffset = greenOffset;
        this.blueOffset = blueOffset;
        this.alphaOffset = alphaOffset;
    }
    Object.defineProperty(ColorTransform.prototype, "color", {
        /**
         * The RGB color value for a ColorTransform object.
         *
         * <p>When you set this property, it changes the three color offset values
         * (<code>redOffset</code>, <code>greenOffset</code>, and
         * <code>blueOffset</code>) accordingly, and it sets the three color
         * multiplier values(<code>redMultiplier</code>,
         * <code>greenMultiplier</code>, and <code>blueMultiplier</code>) to 0. The
         * alpha transparency multiplier and offset values do not change.</p>
         *
         * <p>When you pass a value for this property, use the format
         * 0x<i>RRGGBB</i>. <i>RR</i>, <i>GG</i>, and <i>BB</i> each consist of two
         * hexadecimal digits that specify the offset of each color component. The 0x
         * tells the ActionScript compiler that the number is a hexadecimal
         * value.</p>
         */
        get: function () {
            return ((this.redOffset << 16) | (this.greenOffset << 8) | this.blueOffset);
        },
        set: function (value) {
            var argb = ColorUtils.float32ColorToARGB(value);
            this.redOffset = argb[1]; //(value >> 16) & 0xFF;
            this.greenOffset = argb[2]; //(value >> 8) & 0xFF;
            this.blueOffset = argb[3]; //value & 0xFF;
            this.redMultiplier = 0;
            this.greenMultiplier = 0;
            this.blueMultiplier = 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Concatenates the ColorTranform object specified by the <code>second</code>
     * parameter with the current ColorTransform object and sets the current
     * object as the result, which is an additive combination of the two color
     * transformations. When you apply the concatenated ColorTransform object,
     * the effect is the same as applying the <code>second</code> color
     * transformation after the <i>original</i> color transformation.
     *
     * @param second The ColorTransform object to be combined with the current
     *               ColorTransform object.
     */
    ColorTransform.prototype.concat = function (second) {
        this.redMultiplier += second.redMultiplier;
        this.greenMultiplier += second.greenMultiplier;
        this.blueMultiplier += second.blueMultiplier;
        this.alphaMultiplier += second.alphaMultiplier;
    };
    return ColorTransform;
})();
module.exports = ColorTransform;


},{"awayjs-core/lib/utils/ColorUtils":253}],240:[function(require,module,exports){
module.exports=require(16)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Matrix.js":16,"awayjs-core/lib/errors/ArgumentError":234,"awayjs-core/lib/geom/Point":244}],241:[function(require,module,exports){
module.exports=require(113)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3D.js":113,"awayjs-core/lib/errors/ArgumentError":234,"awayjs-core/lib/geom/Orientation3D":243,"awayjs-core/lib/geom/Vector3D":246}],242:[function(require,module,exports){
module.exports=require(114)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3DUtils.js":114,"awayjs-core/lib/geom/Matrix3D":241,"awayjs-core/lib/geom/Vector3D":246}],243:[function(require,module,exports){
module.exports=require(115)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Orientation3D.js":115}],244:[function(require,module,exports){
module.exports=require(17)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Point.js":17}],245:[function(require,module,exports){
module.exports=require(18)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Rectangle.js":18,"awayjs-core/lib/geom/Point":244}],246:[function(require,module,exports){
module.exports=require(19)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Vector3D.js":19}],247:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],248:[function(require,module,exports){
module.exports=require(31)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/NamedAssetBase.js":31,"awayjs-core/lib/errors/AbstractMethodError":233,"awayjs-core/lib/events/AssetEvent":236,"awayjs-core/lib/events/EventDispatcher":238}],249:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Error = require("awayjs-core/lib/errors/Error");
var Texture2DBase = require("awayjs-core/lib/textures/Texture2DBase");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var BitmapTexture = (function (_super) {
    __extends(BitmapTexture, _super);
    function BitmapTexture(bitmapData, generateMipmaps) {
        if (generateMipmaps === void 0) { generateMipmaps = false; }
        _super.call(this, generateMipmaps);
        this.bitmapData = bitmapData;
    }
    Object.defineProperty(BitmapTexture.prototype, "bitmapData", {
        /**
         *
         * @returns {BitmapData}
         */
        get: function () {
            return this._bitmapData;
        },
        set: function (value) {
            if (this._bitmapData == value)
                return;
            if (!TextureUtils.isBitmapDataValid(value))
                throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
            this._bitmapData = value;
            this.invalidateContent();
            this._pSetSize(value.width, value.height);
        },
        enumerable: true,
        configurable: true
    });
    BitmapTexture.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._bitmapData.dispose();
        this._bitmapData = null;
    };
    BitmapTexture.prototype._iGetTextureData = function () {
        return this._bitmapData;
    };
    return BitmapTexture;
})(Texture2DBase);
module.exports = BitmapTexture;


},{"awayjs-core/lib/errors/Error":235,"awayjs-core/lib/textures/Texture2DBase":251,"awayjs-core/lib/utils/TextureUtils":254}],250:[function(require,module,exports){
module.exports=require(46)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/MipmapGenerator.js":46,"awayjs-core/lib/base/BitmapData":232,"awayjs-core/lib/geom/Matrix":240,"awayjs-core/lib/geom/Rectangle":245}],251:[function(require,module,exports){
module.exports=require(47)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/Texture2DBase.js":47,"awayjs-core/lib/errors/AbstractMethodError":233,"awayjs-core/lib/textures/MipmapGenerator":250,"awayjs-core/lib/textures/TextureProxyBase":252}],252:[function(require,module,exports){
module.exports=require(48)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/TextureProxyBase.js":48,"awayjs-core/lib/library/AssetType":247,"awayjs-core/lib/library/NamedAssetBase":248}],253:[function(require,module,exports){
module.exports=require(51)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ColorUtils.js":51}],254:[function(require,module,exports){
module.exports=require(54)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/TextureUtils.js":54}],255:[function(require,module,exports){
module.exports=require(57)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/AlignmentMode.js":57}],256:[function(require,module,exports){
/**
 * A class that provides constant values for visual blend mode effects. These
 * constants are used in the following:
 * <ul>
 *   <li> The <code>blendMode</code> property of the
 * flash.display.DisplayObject class.</li>
 *   <li> The <code>blendMode</code> parameter of the <code>draw()</code>
 * method of the flash.display.BitmapData class</li>
 * </ul>
 */
var BlendMode = (function () {
    function BlendMode() {
    }
    /**
     * Adds the values of the constituent colors of the display object to the
     * colors of its background, applying a ceiling of 0xFF. This setting is
     * commonly used for animating a lightening dissolve between two objects.
     *
     * <p>For example, if the display object has a pixel with an RGB value of
     * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
     * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
     * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>
     */
    BlendMode.ADD = "add";
    /**
     * Applies the alpha value of each pixel of the display object to the
     * background. This requires the <code>blendMode</code> property of the
     * parent display object be set to
     * <code>away.base.BlendMode.LAYER</code>.
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.ALPHA = "alpha";
    /**
     * Selects the darker of the constituent colors of the display object and the
     * colors of the background(the colors with the smaller values). This
     * setting is commonly used for superimposing type.
     *
     * <p>For example, if the display object has a pixel with an RGB value of
     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
     * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
     * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.DARKEN = "darken";
    /**
     * Compares the constituent colors of the display object with the colors of
     * its background, and subtracts the darker of the values of the two
     * constituent colors from the lighter value. This setting is commonly used
     * for more vibrant colors.
     *
     * <p>For example, if the display object has a pixel with an RGB value of
     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
     * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
     * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>
     */
    BlendMode.DIFFERENCE = "difference";
    /**
     * Erases the background based on the alpha value of the display object. This
     * process requires that the <code>blendMode</code> property of the parent
     * display object be set to <code>flash.display.BlendMode.LAYER</code>.
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.ERASE = "erase";
    /**
     * Adjusts the color of each pixel based on the darkness of the display
     * object. If the display object is lighter than 50% gray, the display object
     * and background colors are screened, which results in a lighter color. If
     * the display object is darker than 50% gray, the colors are multiplied,
     * which results in a darker color. This setting is commonly used for shading
     * effects.
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.HARDLIGHT = "hardlight";
    /**
     * Inverts the background.
     */
    BlendMode.INVERT = "invert";
    /**
     * Forces the creation of a transparency group for the display object. This
     * means that the display object is precomposed in a temporary buffer before
     * it is processed further. The precomposition is done automatically if the
     * display object is precached by means of bitmap caching or if the display
     * object is a display object container that has at least one child object
     * with a <code>blendMode</code> setting other than <code>"normal"</code>.
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.LAYER = "layer";
    /**
     * Selects the lighter of the constituent colors of the display object and
     * the colors of the background(the colors with the larger values). This
     * setting is commonly used for superimposing type.
     *
     * <p>For example, if the display object has a pixel with an RGB value of
     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
     * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
     * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.LIGHTEN = "lighten";
    /**
     * Multiplies the values of the display object constituent colors by the
     * constituent colors of the background color, and normalizes by dividing by
     * 0xFF, resulting in darker colors. This setting is commonly used for
     * shadows and depth effects.
     *
     * <p>For example, if a constituent color(such as red) of one pixel in the
     * display object and the corresponding color of the pixel in the background
     * both have the value 0x88, the multiplied result is 0x4840. Dividing by
     * 0xFF yields a value of 0x48 for that constituent color, which is a darker
     * shade than the color of the display object or the color of the
     * background.</p>
     */
    BlendMode.MULTIPLY = "multiply";
    /**
     * The display object appears in front of the background. Pixel values of the
     * display object override the pixel values of the background. Where the
     * display object is transparent, the background is visible.
     */
    BlendMode.NORMAL = "normal";
    /**
     * Adjusts the color of each pixel based on the darkness of the background.
     * If the background is lighter than 50% gray, the display object and
     * background colors are screened, which results in a lighter color. If the
     * background is darker than 50% gray, the colors are multiplied, which
     * results in a darker color. This setting is commonly used for shading
     * effects.
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.OVERLAY = "overlay";
    /**
     * Multiplies the complement(inverse) of the display object color by the
     * complement of the background color, resulting in a bleaching effect. This
     * setting is commonly used for highlights or to remove black areas of the
     * display object.
     */
    BlendMode.SCREEN = "screen";
    /**
     * Uses a shader to define the blend between objects.
     *
     * <p>Setting the <code>blendShader</code> property to a Shader instance
     * automatically sets the display object's <code>blendMode</code> property to
     * <code>BlendMode.SHADER</code>. If the <code>blendMode</code> property is
     * set to <code>BlendMode.SHADER</code> without first setting the
     * <code>blendShader</code> property, the <code>blendMode</code> property is
     * set to <code>BlendMode.NORMAL</code> instead. If the
     * <code>blendShader</code> property is set(which sets the
     * <code>blendMode</code> property to <code>BlendMode.SHADER</code>), then
     * later the value of the <code>blendMode</code> property is changed, the
     * blend mode can be reset to use the blend shader simply by setting the
     * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. The
     * <code>blendShader</code> property does not need to be set again except to
     * change the shader that's used to define the blend mode.</p>
     *
     * <p>Not supported under GPU rendering.</p>
     */
    BlendMode.SHADER = "shader";
    /**
     * Subtracts the values of the constituent colors in the display object from
     * the values of the background color, applying a floor of 0. This setting is
     * commonly used for animating a darkening dissolve between two objects.
     *
     * <p>For example, if the display object has a pixel with an RGB value of
     * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
     * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
     * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).</p>
     */
    BlendMode.SUBTRACT = "subtract";
    return BlendMode;
})();
module.exports = BlendMode;


},{}],257:[function(require,module,exports){
module.exports=require(58)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/DisplayObject.js":58,"awayjs-core/lib/bounds/AxisAlignedBoundingBox":297,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/geom/MathConsts":311,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Matrix3DUtils":314,"awayjs-core/lib/geom/Point":318,"awayjs-core/lib/geom/Vector3D":320,"awayjs-core/lib/library/NamedAssetBase":322,"awayjs-display/lib/base/AlignmentMode":255,"awayjs-display/lib/base/OrientationMode":261,"awayjs-display/lib/base/Transform":264,"awayjs-display/lib/events/DisplayObjectEvent":273,"awayjs-display/lib/events/SceneEvent":276,"awayjs-display/lib/pick/PickingCollisionVO":291}],258:[function(require,module,exports){
module.exports=require(59)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/LightBase.js":59,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/library/AssetType":321,"awayjs-display/lib/containers/DisplayObjectContainer":267,"awayjs-display/lib/events/LightEvent":274}],259:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var LineSubMesh = require("awayjs-display/lib/base/LineSubMesh");
var SubGeometryBase = require("awayjs-display/lib/base/SubGeometryBase");
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var SubGeometryEvent = require("awayjs-display/lib/events/SubGeometryEvent");
/**
 * @class LineSubGeometry
 */
var LineSubGeometry = (function (_super) {
    __extends(LineSubGeometry, _super);
    /**
     *
     */
    function LineSubGeometry() {
        _super.call(this, true);
        this._positionsDirty = true;
        this._boundingPositionDirty = true;
        this._thicknessDirty = true;
        this._colorsDirty = true;
        this._pSubMeshClass = LineSubMesh;
    }
    LineSubGeometry.prototype._pUpdateStrideOffset = function () {
        this._pOffset[LineSubGeometry.VERTEX_DATA] = 0;
        var stride = 0;
        this._pOffset[LineSubGeometry.START_POSITION_DATA] = stride;
        stride += 3;
        this._pOffset[LineSubGeometry.END_POSITION_DATA] = stride;
        stride += 3;
        this._pOffset[LineSubGeometry.THICKNESS_DATA] = stride;
        stride += 1;
        this._pOffset[LineSubGeometry.COLOR_DATA] = stride;
        stride += 4;
        this._pStride[LineSubGeometry.VERTEX_DATA] = stride;
        this._pStride[LineSubGeometry.START_POSITION_DATA] = stride;
        this._pStride[LineSubGeometry.END_POSITION_DATA] = stride;
        this._pStride[LineSubGeometry.THICKNESS_DATA] = stride;
        this._pStride[LineSubGeometry.COLOR_DATA] = stride;
        var len = this._pNumVertices * stride;
        if (this._pVertices == null)
            this._pVertices = new Array(len);
        else if (this._pVertices.length != len)
            this._pVertices.length = len;
        this._pStrideOffsetDirty = false;
    };
    Object.defineProperty(LineSubGeometry.prototype, "vertices", {
        /**
         *
         */
        get: function () {
            if (this._positionsDirty)
                this.updatePositions(this._startPositions, this._endPositions);
            if (this._thicknessDirty)
                this.updateThickness(this._thickness);
            if (this._colorsDirty)
                this.updateColors(this._startColors, this._endColors);
            return this._pVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubGeometry.prototype, "startPositions", {
        /**
         *
         */
        get: function () {
            if (this._positionsDirty)
                this.updatePositions(this._startPositions, this._endPositions);
            return this._startPositions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubGeometry.prototype, "endPositions", {
        /**
         *
         */
        get: function () {
            if (this._positionsDirty)
                this.updatePositions(this._startPositions, this._endPositions);
            return this._endPositions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubGeometry.prototype, "thickness", {
        /**
         *
         */
        get: function () {
            if (this._thicknessDirty)
                this.updateThickness(this._thickness);
            return this._thickness;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubGeometry.prototype, "startColors", {
        /**
         *
         */
        get: function () {
            if (this._colorsDirty)
                this.updateColors(this._startColors, this._endColors);
            return this._startColors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubGeometry.prototype, "endColors", {
        /**
         *
         */
        get: function () {
            if (this._colorsDirty)
                this.updateColors(this._startColors, this._endColors);
            return this._endColors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubGeometry.prototype, "numSegments", {
        /**
         * The total amount of segments in the TriangleSubGeometry.
         */
        get: function () {
            return this._numSegments;
        },
        enumerable: true,
        configurable: true
    });
    LineSubGeometry.prototype.getBoundingPositions = function () {
        if (this._boundingPositionDirty)
            this._boundingPositions = this.startPositions.concat(this.endPositions);
        return this._boundingPositions;
    };
    /**
     *
     */
    LineSubGeometry.prototype.updatePositions = function (startValues, endValues) {
        var i;
        var j;
        var values;
        var index;
        var stride;
        var positions;
        var indices;
        this._startPositions = startValues;
        if (this._startPositions == null)
            this._startPositions = new Array();
        this._endPositions = endValues;
        if (this._endPositions == null)
            this._endPositions = new Array();
        this._boundingPositionDirty = true;
        this._numSegments = this._startPositions.length / 3;
        this._pNumVertices = this._numSegments * 4;
        var lenV = this._pNumVertices * this.getStride(LineSubGeometry.VERTEX_DATA);
        if (this._pVertices == null)
            this._pVertices = new Array(lenV);
        else if (this._pVertices.length != lenV)
            this._pVertices.length = lenV;
        i = 0;
        j = 0;
        index = this.getOffset(LineSubGeometry.START_POSITION_DATA);
        stride = this.getStride(LineSubGeometry.START_POSITION_DATA);
        positions = this._pVertices;
        indices = new Array();
        while (i < startValues.length) {
            values = (index / stride & 1) ? endValues : startValues;
            positions[index] = values[i];
            positions[index + 1] = values[i + 1];
            positions[index + 2] = values[i + 2];
            values = (index / stride & 1) ? startValues : endValues;
            positions[index + 3] = values[i];
            positions[index + 4] = values[i + 1];
            positions[index + 5] = values[i + 2];
            if (++j == 4) {
                var o = index / stride - 3;
                indices.push(o, o + 1, o + 2, o + 3, o + 2, o + 1);
                j = 0;
                i += 3;
            }
            index += stride;
        }
        this.updateIndices(indices);
        this.pInvalidateBounds();
        this.notifyPositionsUpdate();
        this._positionsDirty = false;
    };
    /**
     * Updates the thickness.
     */
    LineSubGeometry.prototype.updateThickness = function (values) {
        var i;
        var j;
        var index;
        var offset;
        var stride;
        var thickness;
        this._thickness = values;
        if (values != null) {
            i = 0;
            j = 0;
            offset = this.getOffset(LineSubGeometry.THICKNESS_DATA);
            stride = this.getStride(LineSubGeometry.THICKNESS_DATA);
            thickness = this._pVertices;
            index = offset;
            while (i < values.length) {
                thickness[index] = (Math.floor(0.5 * (index - offset) / stride + 0.5) & 1) ? -values[i] : values[i];
                if (++j == 4) {
                    j = 0;
                    i++;
                }
                index += stride;
            }
        }
        this.notifyThicknessUpdate();
        this._thicknessDirty = false;
    };
    /**
     *
     */
    LineSubGeometry.prototype.updateColors = function (startValues, endValues) {
        var i;
        var j;
        var values;
        var index;
        var offset;
        var stride;
        var colors;
        this._startColors = startValues;
        this._endColors = endValues;
        //default to white
        if (this._startColors == null) {
            this._startColors = new Array(this._numSegments * 4);
            i = 0;
            while (i < this._startColors.length)
                this._startColors[i++] = 1;
        }
        if (this._endColors == null) {
            this._endColors = new Array(this._numSegments * 4);
            i = 0;
            while (i < this._endColors.length)
                this._endColors[i++] = 1;
        }
        i = 0;
        j = 0;
        offset = this.getOffset(LineSubGeometry.COLOR_DATA);
        stride = this.getStride(LineSubGeometry.COLOR_DATA);
        colors = this._pVertices;
        index = offset;
        while (i < this._startColors.length) {
            values = ((index - offset) / stride & 1) ? this._endColors : this._startColors;
            colors[index] = values[i];
            colors[index + 1] = values[i + 1];
            colors[index + 2] = values[i + 2];
            colors[index + 3] = values[i + 3];
            if (++j == 4) {
                j = 0;
                i += 4;
            }
            index += stride;
        }
        this.notifyColorsUpdate();
        this._colorsDirty = false;
    };
    /**
     *
     */
    LineSubGeometry.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._startPositions = null;
        this._endPositions = null;
        this._thickness = null;
        this._startColors = null;
        this._endColors = null;
    };
    /**
     * @protected
     */
    LineSubGeometry.prototype.pInvalidateBounds = function () {
        if (this.parentGeometry)
            this.parentGeometry.iInvalidateBounds(this);
    };
    /**
     * Clones the current object
     * @return An exact duplicate of the current object.
     */
    LineSubGeometry.prototype.clone = function () {
        var clone = new LineSubGeometry();
        clone.updateIndices(this._pIndices.concat());
        clone.updatePositions(this._startPositions.concat(), this._endPositions.concat());
        clone.updateThickness(this._thickness.concat());
        clone.updatePositions(this._startPositions.concat(), this._endPositions.concat());
        return clone;
    };
    LineSubGeometry.prototype._pNotifyVerticesUpdate = function () {
        this._pStrideOffsetDirty = true;
        this.notifyPositionsUpdate();
        this.notifyThicknessUpdate();
        this.notifyColorsUpdate();
    };
    LineSubGeometry.prototype.notifyPositionsUpdate = function () {
        if (this._positionsDirty)
            return;
        this._positionsDirty = true;
        if (!this._positionsUpdated)
            this._positionsUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, TriangleSubGeometry.POSITION_DATA);
        this.dispatchEvent(this._positionsUpdated);
    };
    LineSubGeometry.prototype.notifyThicknessUpdate = function () {
        if (this._thicknessDirty)
            return;
        this._thicknessDirty = true;
        if (!this._thicknessUpdated)
            this._thicknessUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, LineSubGeometry.THICKNESS_DATA);
        this.dispatchEvent(this._thicknessUpdated);
    };
    LineSubGeometry.prototype.notifyColorsUpdate = function () {
        if (this._colorsDirty)
            return;
        this._colorsDirty = true;
        if (!this._colorUpdated)
            this._colorUpdated = new SubGeometryEvent(SubGeometryEvent.VERTICES_UPDATED, LineSubGeometry.COLOR_DATA);
        this.dispatchEvent(this._colorUpdated);
    };
    LineSubGeometry.VERTEX_DATA = "vertices";
    LineSubGeometry.START_POSITION_DATA = "startPositions";
    LineSubGeometry.END_POSITION_DATA = "endPositions";
    LineSubGeometry.THICKNESS_DATA = "thickness";
    LineSubGeometry.COLOR_DATA = "colors";
    //TODO - move these to StageGL
    LineSubGeometry.POSITION_FORMAT = "float3";
    LineSubGeometry.COLOR_FORMAT = "float4";
    LineSubGeometry.THICKNESS_FORMAT = "float1";
    return LineSubGeometry;
})(SubGeometryBase);
module.exports = LineSubGeometry;


},{"awayjs-display/lib/base/LineSubMesh":260,"awayjs-display/lib/base/SubGeometryBase":262,"awayjs-display/lib/base/TriangleSubGeometry":265,"awayjs-display/lib/events/SubGeometryEvent":277}],260:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AssetType = require("awayjs-core/lib/library/AssetType");
var SubMeshBase = require("awayjs-display/lib/base/SubMeshBase");
/**
 * LineSubMesh wraps a LineSubGeometry as a scene graph instantiation. A LineSubMesh is owned by a Mesh object.
 *
 *
 * @see away.base.LineSubGeometry
 * @see away.entities.Mesh
 *
 * @class away.base.LineSubMesh
 */
var LineSubMesh = (function (_super) {
    __extends(LineSubMesh, _super);
    /**
     * Creates a new LineSubMesh object
     * @param subGeometry The LineSubGeometry object which provides the geometry data for this LineSubMesh.
     * @param parentMesh The Mesh object to which this LineSubMesh belongs.
     * @param material An optional material used to render this LineSubMesh.
     */
    function LineSubMesh(subGeometry, parentMesh, material) {
        if (material === void 0) { material = null; }
        _super.call(this);
        this._pParentMesh = parentMesh;
        this._subGeometry = subGeometry;
        this.material = material;
    }
    Object.defineProperty(LineSubMesh.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return AssetType.LINE_SUB_MESH;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSubMesh.prototype, "subGeometry", {
        /**
         * The LineSubGeometry object which provides the geometry data for this LineSubMesh.
         */
        get: function () {
            return this._subGeometry;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    LineSubMesh.prototype.dispose = function () {
        this.material = null;
        _super.prototype.dispose.call(this);
    };
    LineSubMesh.prototype._iCollectRenderable = function (renderer) {
        renderer.applyLineSubMesh(this);
    };
    return LineSubMesh;
})(SubMeshBase);
module.exports = LineSubMesh;


},{"awayjs-core/lib/library/AssetType":321,"awayjs-display/lib/base/SubMeshBase":263}],261:[function(require,module,exports){
module.exports=require(60)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/OrientationMode.js":60}],262:[function(require,module,exports){
module.exports=require(158)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/SubGeometryBase.js":158,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/library/NamedAssetBase":322,"awayjs-display/lib/events/SubGeometryEvent":277}],263:[function(require,module,exports){
module.exports=require(159)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/SubMeshBase.js":159,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/library/NamedAssetBase":322}],264:[function(require,module,exports){
module.exports=require(61)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/Transform.js":61,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Matrix3DUtils":314,"awayjs-core/lib/geom/Vector3D":320}],265:[function(require,module,exports){
module.exports=require(161)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/TriangleSubGeometry.js":161,"awayjs-core/lib/geom/Vector3D":320,"awayjs-display/lib/base/SubGeometryBase":262,"awayjs-display/lib/base/TriangleSubMesh":266,"awayjs-display/lib/events/SubGeometryEvent":277}],266:[function(require,module,exports){
module.exports=require(162)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/TriangleSubMesh.js":162,"awayjs-core/lib/library/AssetType":321,"awayjs-display/lib/base/SubMeshBase":263}],267:[function(require,module,exports){
module.exports=require(62)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/containers/DisplayObjectContainer.js":62,"awayjs-core/lib/errors/ArgumentError":302,"awayjs-core/lib/errors/Error":303,"awayjs-core/lib/errors/RangeError":305,"awayjs-core/lib/library/AssetType":321,"awayjs-display/lib/base/DisplayObject":257}],268:[function(require,module,exports){
module.exports=require(65)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/Camera.js":65,"awayjs-core/lib/bounds/NullBounds":300,"awayjs-core/lib/events/ProjectionEvent":309,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Plane3D":316,"awayjs-core/lib/library/AssetType":321,"awayjs-core/lib/projections/PerspectiveProjection":325,"awayjs-display/lib/containers/DisplayObjectContainer":267,"awayjs-display/lib/events/CameraEvent":272,"awayjs-display/lib/partition/CameraNode":285}],269:[function(require,module,exports){
module.exports=require(66)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/DirectionalLight.js":66,"awayjs-core/lib/bounds/NullBounds":300,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Vector3D":320,"awayjs-display/lib/base/LightBase":258,"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper":283,"awayjs-display/lib/partition/DirectionalLightNode":286}],270:[function(require,module,exports){
module.exports=require(67)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/LightProbe.js":67,"awayjs-core/lib/bounds/NullBounds":300,"awayjs-core/lib/errors/Error":303,"awayjs-display/lib/base/LightBase":258,"awayjs-display/lib/partition/LightProbeNode":288}],271:[function(require,module,exports){
module.exports=require(68)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/PointLight.js":68,"awayjs-core/lib/bounds/BoundingSphere":298,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Vector3D":320,"awayjs-display/lib/base/LightBase":258,"awayjs-display/lib/materials/shadowmappers/CubeMapShadowMapper":282,"awayjs-display/lib/partition/PointLightNode":290}],272:[function(require,module,exports){
module.exports=require(69)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/CameraEvent.js":69,"awayjs-core/lib/events/Event":307}],273:[function(require,module,exports){
module.exports=require(70)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/DisplayObjectEvent.js":70,"awayjs-core/lib/events/Event":307}],274:[function(require,module,exports){
module.exports=require(71)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/LightEvent.js":71,"awayjs-core/lib/events/Event":307}],275:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var MaterialEvent = (function (_super) {
    __extends(MaterialEvent, _super);
    function MaterialEvent(type) {
        _super.call(this, type);
    }
    MaterialEvent.SIZE_CHANGED = "sizeChanged";
    return MaterialEvent;
})(Event);
module.exports = MaterialEvent;


},{"awayjs-core/lib/events/Event":307}],276:[function(require,module,exports){
module.exports=require(74)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/SceneEvent.js":74,"awayjs-core/lib/events/Event":307}],277:[function(require,module,exports){
module.exports=require(168)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/events/SubGeometryEvent.js":168,"awayjs-core/lib/events/Event":307}],278:[function(require,module,exports){
/**
 * Enumeration class for defining which lighting types affect the specific material
 * lighting component (diffuse and specular). This can be useful if, for example, you
 * want to use light probes for diffuse global lighting, but want specular reflections from
 * traditional light sources without those affecting the diffuse light.
 *
 * @see away.materials.ColorMaterial.diffuseLightSources
 * @see away.materials.ColorMaterial.specularLightSources
 * @see away.materials.TextureMaterial.diffuseLightSources
 * @see away.materials.TextureMaterial.specularLightSources
 */
var LightSources = (function () {
    function LightSources() {
    }
    /**
     * Defines normal lights are to be used as the source for the lighting
     * component.
     */
    LightSources.LIGHTS = 0x01;
    /**
     * Defines that global lighting probes are to be used as the source for the
     * lighting component.
     */
    LightSources.PROBES = 0x02;
    /**
     * Defines that both normal and global lighting probes  are to be used as the
     * source for the lighting component. This is equivalent to LightSources.LIGHTS | LightSources.PROBES.
     */
    LightSources.ALL = 0x03;
    return LightSources;
})();
module.exports = LightSources;


},{}],279:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var AssetType = require("awayjs-core/lib/library/AssetType");
var NamedAssetBase = require("awayjs-core/lib/library/NamedAssetBase");
var BlendMode = require("awayjs-display/lib/base/BlendMode");
var MaterialEvent = require("awayjs-display/lib/events/MaterialEvent");
/**
 * MaterialBase forms an abstract base class for any material.
 * A material consists of several passes, each of which constitutes at least one render call. Several passes could
 * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
 * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
 * subsurface scattering, or rendering a depth map for specialized self-shadowing).
 *
 * Away3D provides default materials trough SinglePassMaterialBase and TriangleMaterial, which use modular
 * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
 * shaders, or entire new material frameworks.
 */
var MaterialBase = (function (_super) {
    __extends(MaterialBase, _super);
    /**
     * Creates a new MaterialBase object.
     */
    function MaterialBase() {
        var _this = this;
        _super.call(this);
        this._materialPassData = new Array();
        this._materialData = new Array();
        this._pAlphaThreshold = 0;
        this._pAnimateUVs = false;
        this._enableLightFallOff = true;
        this._specularLightSources = 0x01;
        this._diffuseLightSources = 0x03;
        /**
         * An id for this material used to sort the renderables by shader program, which reduces Program state changes.
         *
         * @private
         */
        this._iMaterialId = 0;
        this._iBaseScreenPassIndex = 0;
        this._bothSides = false; // update
        this._pScreenPassesInvalid = true;
        this._pBlendMode = BlendMode.NORMAL;
        this._numPasses = 0;
        this._mipmap = false;
        this._smooth = true;
        this._repeat = false;
        this._color = 0xFFFFFF;
        this._pHeight = 1;
        this._pWidth = 1;
        this._pRequiresBlending = false;
        this._iMaterialId = Number(this.id);
        this._owners = new Array();
        this._passes = new Array();
        this._onPassChangeDelegate = function (event) { return _this.onPassChange(event); };
        this._onLightChangeDelegate = function (event) { return _this.onLightsChange(event); };
        this.alphaPremultiplied = false; //TODO: work out why this is different for WebGL
    }
    Object.defineProperty(MaterialBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AssetType.MATERIAL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "height", {
        /**
         *
         */
        get: function () {
            return this._pHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "animationSet", {
        /**
         *
         */
        get: function () {
            return this._animationSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "lightPicker", {
        /**
         * The light picker used by the material to provide lights to the material if it supports lighting.
         *
         * @see LightPickerBase
         * @see StaticLightPicker
         */
        get: function () {
            return this._pLightPicker;
        },
        set: function (value) {
            if (this._pLightPicker == value)
                return;
            if (this._pLightPicker)
                this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightChangeDelegate);
            this._pLightPicker = value;
            if (this._pLightPicker)
                this._pLightPicker.addEventListener(Event.CHANGE, this._onLightChangeDelegate);
            this._pInvalidateScreenPasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "mipmap", {
        /**
         * Indicates whether or not any used textures should use mipmapping. Defaults to true.
         */
        get: function () {
            return this._mipmap;
        },
        set: function (value) {
            if (this._mipmap == value)
                return;
            this._mipmap = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "smooth", {
        /**
         * Indicates whether or not any used textures should use smoothing.
         */
        get: function () {
            return this._smooth;
        },
        set: function (value) {
            if (this._smooth == value)
                return;
            this._smooth = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "repeat", {
        /**
         * Indicates whether or not any used textures should be tiled. If set to false, texture samples are clamped to
         * the texture's borders when the uv coordinates are outside the [0, 1] interval.
         */
        get: function () {
            return this._repeat;
        },
        set: function (value) {
            if (this._repeat == value)
                return;
            this._repeat = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "color", {
        /**
         * The diffuse reflectivity color of the surface.
         */
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (this._color == value)
                return;
            this._color = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "texture", {
        /**
         * The texture object to use for the albedo colour.
         */
        get: function () {
            return this._pTexture;
        },
        set: function (value) {
            if (this._pTexture == value)
                return;
            this._pTexture = value;
            this._pInvalidatePasses();
            this._pHeight = this._pTexture.height;
            this._pWidth = this._pTexture.width;
            this._pNotifySizeChanged();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "animateUVs", {
        /**
         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
         */
        get: function () {
            return this._pAnimateUVs;
        },
        set: function (value) {
            if (this._pAnimateUVs == value)
                return;
            this._pAnimateUVs = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "enableLightFallOff", {
        /**
         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
         * compatibility for constrained mode.
         */
        get: function () {
            return this._enableLightFallOff;
        },
        set: function (value) {
            if (this._enableLightFallOff == value)
                return;
            this._enableLightFallOff = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "diffuseLightSources", {
        /**
         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
         * and/or light probes for diffuse reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._diffuseLightSources;
        },
        set: function (value) {
            if (this._diffuseLightSources == value)
                return;
            this._diffuseLightSources = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "specularLightSources", {
        /**
         * Define which light source types to use for specular reflections. This allows choosing between regular lights
         * and/or light probes for specular reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._specularLightSources;
        },
        set: function (value) {
            if (this._specularLightSources == value)
                return;
            this._specularLightSources = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cleans up resources owned by the material, including passes. Textures are not owned by the material since they
     * could be used by other materials and will not be disposed.
     */
    MaterialBase.prototype.dispose = function () {
        var i;
        var len;
        this._pClearScreenPasses();
        len = this._materialData.length;
        for (i = 0; i < len; i++)
            this._materialData[i].dispose();
        this._materialData = new Array();
        len = this._materialPassData.length;
        for (i = 0; i < len; i++)
            this._materialPassData[i].dispose();
        this._materialPassData = new Array();
    };
    Object.defineProperty(MaterialBase.prototype, "bothSides", {
        /**
         * Defines whether or not the material should cull triangles facing away from the camera.
         */
        get: function () {
            return this._bothSides;
        },
        set: function (value) {
            if (this._bothSides = value)
                return;
            this._bothSides = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "blendMode", {
        /**
         * The blend mode to use when drawing this renderable. The following blend modes are supported:
         * <ul>
         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
         * <li>BlendMode.MULTIPLY</li>
         * <li>BlendMode.ADD</li>
         * <li>BlendMode.ALPHA</li>
         * </ul>
         */
        get: function () {
            return this._pBlendMode;
        },
        set: function (value) {
            if (this._pBlendMode == value)
                return;
            this._pBlendMode = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
        /**
         * Indicates whether visible textures (or other pixels) used by this material have
         * already been premultiplied. Toggle this if you are seeing black halos around your
         * blended alpha edges.
         */
        get: function () {
            return this._alphaPremultiplied;
        },
        set: function (value) {
            if (this._alphaPremultiplied == value)
                return;
            this._alphaPremultiplied = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "alphaThreshold", {
        /**
         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
         * invisible or entirely opaque, often used with textures for foliage, etc.
         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
         */
        get: function () {
            return this._pAlphaThreshold;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            if (this._pAlphaThreshold == value)
                return;
            this._pAlphaThreshold = value;
            this._pInvalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "requiresBlending", {
        /**
         * Indicates whether or not the material requires alpha blending during rendering.
         */
        get: function () {
            return this._pRequiresBlending;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "width", {
        /**
         *
         */
        get: function () {
            return this._pWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the render state for a pass that is independent of the rendered object. This needs to be called before
     * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
     * @param pass The pass data to activate.
     * @param stage The Stage object which is currently used for rendering.
     * @param camera The camera from which the scene is viewed.
     * @private
     */
    MaterialBase.prototype._iActivatePass = function (pass, stage, camera) {
        pass.materialPass._iActivate(pass, stage, camera);
    };
    /**
     * Clears the render state for a pass. This needs to be called before activating another pass.
     * @param pass The pass to deactivate.
     * @param stage The Stage used for rendering
     *
     * @internal
     */
    MaterialBase.prototype._iDeactivatePass = function (pass, stage) {
        pass.materialPass._iDeactivate(pass, stage);
    };
    /**
     * Renders the current pass. Before calling renderPass, activatePass needs to be called with the same index.
     * @param pass The pass used to render the renderable.
     * @param renderable The IRenderable object to draw.
     * @param stage The Stage object used for rendering.
     * @param entityCollector The EntityCollector object that contains the visible scene data.
     * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
     * camera.viewProjection as it includes the scaling factors when rendering to textures.
     *
     * @internal
     */
    MaterialBase.prototype._iRenderPass = function (pass, renderable, stage, camera, viewProjection) {
        if (this._pLightPicker)
            this._pLightPicker.collectLights(renderable);
        pass.materialPass._iRender(pass, renderable, stage, camera, viewProjection);
    };
    //
    // MATERIAL MANAGEMENT
    //
    /**
     * Mark an IMaterialOwner as owner of this material.
     * Assures we're not using the same material across renderables with different animations, since the
     * Programs depend on animation. This method needs to be called when a material is assigned.
     *
     * @param owner The IMaterialOwner that had this material assigned
     *
     * @internal
     */
    MaterialBase.prototype.iAddOwner = function (owner) {
        this._owners.push(owner);
        var animationSet;
        var animator = owner.animator;
        if (animator)
            animationSet = animator.animationSet;
        if (owner.animator) {
            if (this._animationSet && animationSet != this._animationSet) {
                throw new Error("A Material instance cannot be shared across material owners with different animation sets");
            }
            else {
                if (this._animationSet != animationSet) {
                    this._animationSet = animationSet;
                    this.invalidateAnimation();
                }
            }
        }
    };
    /**
     * Removes an IMaterialOwner as owner.
     * @param owner
     *
     * @internal
     */
    MaterialBase.prototype.iRemoveOwner = function (owner) {
        this._owners.splice(this._owners.indexOf(owner), 1);
        if (this._owners.length == 0) {
            this._animationSet = null;
            this.invalidateAnimation();
        }
    };
    Object.defineProperty(MaterialBase.prototype, "iOwners", {
        /**
         * A list of the IMaterialOwners that use this material
         *
         * @private
         */
        get: function () {
            return this._owners;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The amount of passes used by the material.
     *
     * @private
     */
    MaterialBase.prototype._iNumScreenPasses = function () {
        return this._numPasses;
    };
    Object.defineProperty(MaterialBase.prototype, "_iScreenPasses", {
        /**
         * A list of the screen passes used in this material
         *
         * @private
         */
        get: function () {
            return this._passes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
     *
     * @private
     */
    MaterialBase.prototype._pInvalidatePasses = function () {
        var len = this._materialPassData.length;
        for (var i = 0; i < len; i++)
            this._materialPassData[i].invalidate();
        this.invalidateMaterial();
    };
    /**
     * Flags that the screen passes have become invalid and need possible re-ordering / adding / deleting
     */
    MaterialBase.prototype._pInvalidateScreenPasses = function () {
        this._pScreenPassesInvalid = true;
    };
    /**
     * Removes a pass from the material.
     * @param pass The pass to be removed.
     */
    MaterialBase.prototype._pRemoveScreenPass = function (pass) {
        pass.removeEventListener(Event.CHANGE, this._onPassChangeDelegate);
        this._passes.splice(this._passes.indexOf(pass), 1);
        this._numPasses--;
    };
    /**
     * Removes all passes from the material
     */
    MaterialBase.prototype._pClearScreenPasses = function () {
        for (var i = 0; i < this._numPasses; ++i)
            this._passes[i].removeEventListener(Event.CHANGE, this._onPassChangeDelegate);
        this._passes.length = this._numPasses = 0;
    };
    /**
     * Adds a pass to the material
     * @param pass
     */
    MaterialBase.prototype._pAddScreenPass = function (pass) {
        this._passes[this._numPasses++] = pass;
        pass.lightPicker = this._pLightPicker;
        pass.addEventListener(Event.CHANGE, this._onPassChangeDelegate);
        this.invalidateMaterial();
    };
    MaterialBase.prototype._iAddMaterialData = function (materialData) {
        this._materialData.push(materialData);
        return materialData;
    };
    MaterialBase.prototype._iRemoveMaterialData = function (materialData) {
        this._materialData.splice(this._materialData.indexOf(materialData), 1);
        return materialData;
    };
    /**
     * Performs any processing that needs to occur before any of its passes are used.
     *
     * @private
     */
    MaterialBase.prototype._iUpdateMaterial = function () {
    };
    /**
     * Listener for when a pass's shader code changes. It recalculates the render order id.
     */
    MaterialBase.prototype.onPassChange = function (event) {
        this.invalidateMaterial();
    };
    MaterialBase.prototype.invalidateAnimation = function () {
        var len = this._materialData.length;
        for (var i = 0; i < len; i++)
            this._materialData[i].invalidateAnimation();
    };
    MaterialBase.prototype.invalidateMaterial = function () {
        var len = this._materialData.length;
        for (var i = 0; i < len; i++)
            this._materialData[i].invalidateMaterial();
    };
    /**
     * Called when the light picker's configuration changed.
     */
    MaterialBase.prototype.onLightsChange = function (event) {
        this._pInvalidateScreenPasses();
    };
    MaterialBase.prototype._pNotifySizeChanged = function () {
        if (!this._sizeChanged)
            this._sizeChanged = new MaterialEvent(MaterialEvent.SIZE_CHANGED);
        this.dispatchEvent(this._sizeChanged);
    };
    MaterialBase.prototype._iAddMaterialPassData = function (materialPassData) {
        this._materialPassData.push(materialPassData);
        return materialPassData;
    };
    MaterialBase.prototype._iRemoveMaterialPassData = function (materialPassData) {
        this._materialPassData.splice(this._materialPassData.indexOf(materialPassData), 1);
        return materialPassData;
    };
    return MaterialBase;
})(NamedAssetBase);
module.exports = MaterialBase;


},{"awayjs-core/lib/events/Event":307,"awayjs-core/lib/library/AssetType":321,"awayjs-core/lib/library/NamedAssetBase":322,"awayjs-display/lib/base/BlendMode":256,"awayjs-display/lib/events/MaterialEvent":275}],280:[function(require,module,exports){
module.exports=require(76)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/lightpickers/LightPickerBase.js":76,"awayjs-core/lib/library/AssetType":321,"awayjs-core/lib/library/NamedAssetBase":322}],281:[function(require,module,exports){
module.exports=require(77)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/lightpickers/StaticLightPicker.js":77,"awayjs-core/lib/events/Event":307,"awayjs-display/lib/entities/DirectionalLight":269,"awayjs-display/lib/entities/LightProbe":270,"awayjs-display/lib/entities/PointLight":271,"awayjs-display/lib/events/LightEvent":274,"awayjs-display/lib/materials/lightpickers/LightPickerBase":280}],282:[function(require,module,exports){
module.exports=require(78)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/shadowmappers/CubeMapShadowMapper.js":78,"awayjs-core/lib/errors/PartialImplementationError":304,"awayjs-display/lib/entities/Camera":268,"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase":284}],283:[function(require,module,exports){
module.exports=require(79)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper.js":79,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/projections/FreeMatrixProjection":324,"awayjs-display/lib/entities/Camera":268,"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase":284}],284:[function(require,module,exports){
module.exports=require(80)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/shadowmappers/ShadowMapperBase.js":80,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/textures/RenderTexture":328,"awayjs-display/lib/traverse/ShadowCasterCollector":295}],285:[function(require,module,exports){
module.exports=require(81)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/CameraNode.js":81,"awayjs-display/lib/partition/EntityNode":287}],286:[function(require,module,exports){
module.exports=require(82)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/DirectionalLightNode.js":82,"awayjs-display/lib/partition/EntityNode":287}],287:[function(require,module,exports){
module.exports=require(83)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/EntityNode.js":83,"awayjs-core/lib/errors/PartialImplementationError":304,"awayjs-display/lib/partition/NodeBase":289}],288:[function(require,module,exports){
module.exports=require(84)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/LightProbeNode.js":84,"awayjs-display/lib/partition/EntityNode":287}],289:[function(require,module,exports){
module.exports=require(85)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/NodeBase.js":85}],290:[function(require,module,exports){
module.exports=require(88)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/PointLightNode.js":88,"awayjs-display/lib/partition/EntityNode":287}],291:[function(require,module,exports){
module.exports=require(89)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pick/PickingCollisionVO.js":89}],292:[function(require,module,exports){
module.exports=require(91)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pool/EntityListItem.js":91}],293:[function(require,module,exports){
module.exports=require(92)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pool/EntityListItemPool.js":92,"awayjs-display/lib/pool/EntityListItem":292}],294:[function(require,module,exports){
module.exports=require(93)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/traverse/CollectorBase.js":93,"awayjs-display/lib/pool/EntityListItemPool":293}],295:[function(require,module,exports){
module.exports=require(95)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/traverse/ShadowCasterCollector.js":95,"awayjs-display/lib/traverse/CollectorBase":294}],296:[function(require,module,exports){
module.exports=require(2)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/base/BitmapData.js":2,"awayjs-core/lib/geom/Rectangle":319,"awayjs-core/lib/utils/ColorUtils":331}],297:[function(require,module,exports){
module.exports=require(97)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/AxisAlignedBoundingBox.js":97,"awayjs-core/lib/bounds/BoundingVolumeBase":299,"awayjs-core/lib/geom/Matrix3DUtils":314,"awayjs-core/lib/geom/PlaneClassification":317,"awayjs-core/lib/geom/Vector3D":320}],298:[function(require,module,exports){
module.exports=require(98)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/BoundingSphere.js":98,"awayjs-core/lib/bounds/BoundingVolumeBase":299,"awayjs-core/lib/geom/PlaneClassification":317,"awayjs-core/lib/geom/Vector3D":320}],299:[function(require,module,exports){
module.exports=require(99)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/BoundingVolumeBase.js":99,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/geom/Box":310}],300:[function(require,module,exports){
module.exports=require(100)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/NullBounds.js":100,"awayjs-core/lib/bounds/BoundingVolumeBase":299,"awayjs-core/lib/geom/PlaneClassification":317}],301:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":303}],302:[function(require,module,exports){
module.exports=require(4)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/ArgumentError.js":4,"awayjs-core/lib/errors/Error":303}],303:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],304:[function(require,module,exports){
module.exports=require(6)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/PartialImplementationError.js":6,"awayjs-core/lib/errors/Error":303}],305:[function(require,module,exports){
module.exports=require(105)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/errors/RangeError.js":105,"awayjs-core/lib/errors/Error":303}],306:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":307}],307:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],308:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],309:[function(require,module,exports){
module.exports=require(109)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/events/ProjectionEvent.js":109,"awayjs-core/lib/events/Event":307}],310:[function(require,module,exports){
module.exports=require(110)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Box.js":110,"awayjs-core/lib/geom/Vector3D":320}],311:[function(require,module,exports){
module.exports=require(111)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/MathConsts.js":111}],312:[function(require,module,exports){
module.exports=require(16)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Matrix.js":16,"awayjs-core/lib/errors/ArgumentError":302,"awayjs-core/lib/geom/Point":318}],313:[function(require,module,exports){
module.exports=require(113)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3D.js":113,"awayjs-core/lib/errors/ArgumentError":302,"awayjs-core/lib/geom/Orientation3D":315,"awayjs-core/lib/geom/Vector3D":320}],314:[function(require,module,exports){
module.exports=require(114)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3DUtils.js":114,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Vector3D":320}],315:[function(require,module,exports){
module.exports=require(115)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Orientation3D.js":115}],316:[function(require,module,exports){
module.exports=require(116)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Plane3D.js":116,"awayjs-core/lib/geom/PlaneClassification":317}],317:[function(require,module,exports){
module.exports=require(117)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/PlaneClassification.js":117}],318:[function(require,module,exports){
module.exports=require(17)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Point.js":17}],319:[function(require,module,exports){
module.exports=require(18)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Rectangle.js":18,"awayjs-core/lib/geom/Point":318}],320:[function(require,module,exports){
module.exports=require(19)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Vector3D.js":19}],321:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],322:[function(require,module,exports){
module.exports=require(31)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/NamedAssetBase.js":31,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/events/AssetEvent":306,"awayjs-core/lib/events/EventDispatcher":308}],323:[function(require,module,exports){
module.exports=require(123)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/CoordinateSystem.js":123}],324:[function(require,module,exports){
module.exports=require(124)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/FreeMatrixProjection.js":124,"awayjs-core/lib/projections/PerspectiveProjection":325,"awayjs-core/lib/projections/ProjectionBase":326}],325:[function(require,module,exports){
module.exports=require(125)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/PerspectiveProjection.js":125,"awayjs-core/lib/geom/Vector3D":320,"awayjs-core/lib/projections/CoordinateSystem":323,"awayjs-core/lib/projections/ProjectionBase":326}],326:[function(require,module,exports){
module.exports=require(126)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/ProjectionBase.js":126,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/events/EventDispatcher":308,"awayjs-core/lib/events/ProjectionEvent":309,"awayjs-core/lib/geom/Matrix3D":313,"awayjs-core/lib/geom/Rectangle":319}],327:[function(require,module,exports){
module.exports=require(46)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/MipmapGenerator.js":46,"awayjs-core/lib/base/BitmapData":296,"awayjs-core/lib/geom/Matrix":312,"awayjs-core/lib/geom/Rectangle":319}],328:[function(require,module,exports){
module.exports=require(128)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/textures/RenderTexture.js":128,"awayjs-core/lib/errors/Error":303,"awayjs-core/lib/textures/Texture2DBase":329,"awayjs-core/lib/utils/TextureUtils":332}],329:[function(require,module,exports){
module.exports=require(47)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/Texture2DBase.js":47,"awayjs-core/lib/errors/AbstractMethodError":301,"awayjs-core/lib/textures/MipmapGenerator":327,"awayjs-core/lib/textures/TextureProxyBase":330}],330:[function(require,module,exports){
module.exports=require(48)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/TextureProxyBase.js":48,"awayjs-core/lib/library/AssetType":321,"awayjs-core/lib/library/NamedAssetBase":322}],331:[function(require,module,exports){
module.exports=require(51)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ColorUtils.js":51}],332:[function(require,module,exports){
module.exports=require(54)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/TextureUtils.js":54}],333:[function(require,module,exports){
var Description = require("awayjs-stagegl/lib/aglsl/Description");
var Header = require("awayjs-stagegl/lib/aglsl/Header");
var Mapping = require("awayjs-stagegl/lib/aglsl/Mapping");
var Token = require("awayjs-stagegl/lib/aglsl/Token");
var AGALTokenizer = (function () {
    function AGALTokenizer() {
    }
    AGALTokenizer.prototype.decribeAGALByteArray = function (bytes) {
        var header = new Header();
        if (bytes.readUnsignedByte() != 0xa0) {
            throw "Bad AGAL: Missing 0xa0 magic byte.";
        }
        header.version = bytes.readUnsignedInt();
        if (header.version >= 0x10) {
            bytes.readUnsignedByte();
            header.version >>= 1;
        }
        if (bytes.readUnsignedByte() != 0xa1) {
            throw "Bad AGAL: Missing 0xa1 magic byte.";
        }
        header.progid = bytes.readUnsignedByte();
        switch (header.progid) {
            case 1:
                header.type = "fragment";
                break;
            case 0:
                header.type = "vertex";
                break;
            case 2:
                header.type = "cpu";
                break;
            default:
                header.type = "";
                break;
        }
        var desc = new Description();
        var tokens = [];
        while (bytes.position < bytes.length) {
            var token = new Token();
            token.opcode = bytes.readUnsignedInt();
            var lutentry = Mapping.agal2glsllut[token.opcode];
            if (!lutentry) {
                throw "Opcode not valid or not implemented yet: " + token.opcode;
            }
            if (lutentry.matrixheight) {
                desc.hasmatrix = true;
            }
            if (lutentry.dest) {
                token.dest.regnum = bytes.readUnsignedShort();
                token.dest.mask = bytes.readUnsignedByte();
                token.dest.regtype = bytes.readUnsignedByte();
                desc.regwrite[token.dest.regtype][token.dest.regnum] |= token.dest.mask;
            }
            else {
                token.dest = null;
                bytes.readUnsignedInt();
            }
            if (lutentry.a) {
                this.readReg(token.a, 1, desc, bytes);
            }
            else {
                token.a = null;
                bytes.readUnsignedInt();
                bytes.readUnsignedInt();
            }
            if (lutentry.b) {
                this.readReg(token.b, lutentry.matrixheight | 0, desc, bytes);
            }
            else {
                token.b = null;
                bytes.readUnsignedInt();
                bytes.readUnsignedInt();
            }
            tokens.push(token);
        }
        desc.header = header;
        desc.tokens = tokens;
        return desc;
    };
    AGALTokenizer.prototype.readReg = function (s, mh, desc, bytes) {
        s.regnum = bytes.readUnsignedShort();
        s.indexoffset = bytes.readByte();
        s.swizzle = bytes.readUnsignedByte();
        s.regtype = bytes.readUnsignedByte();
        desc.regread[s.regtype][s.regnum] = 0xf; // sould be swizzle to mask? should be |=                                                 
        if (s.regtype == 0x5) {
            // sampler
            s.lodbiad = s.indexoffset;
            s.indexoffset = undefined;
            s.swizzle = undefined;
            // sampler 
            s.readmode = bytes.readUnsignedByte();
            s.dim = s.readmode >> 4;
            s.readmode &= 0xf;
            s.special = bytes.readUnsignedByte();
            s.wrap = s.special >> 4;
            s.special &= 0xf;
            s.mipmap = bytes.readUnsignedByte();
            s.filter = s.mipmap >> 4;
            s.mipmap &= 0xf;
            desc.samplers[s.regnum] = s;
        }
        else {
            s.indexregtype = bytes.readUnsignedByte();
            s.indexselect = bytes.readUnsignedByte();
            s.indirectflag = bytes.readUnsignedByte();
        }
        if (s.indirectflag) {
            desc.hasindirect = true;
        }
        if (!s.indirectflag && mh) {
            for (var mhi = 0; mhi < mh; mhi++) {
                desc.regread[s.regtype][s.regnum + mhi] = desc.regread[s.regtype][s.regnum];
            }
        }
    };
    return AGALTokenizer;
})();
module.exports = AGALTokenizer;


},{"awayjs-stagegl/lib/aglsl/Description":335,"awayjs-stagegl/lib/aglsl/Header":337,"awayjs-stagegl/lib/aglsl/Mapping":338,"awayjs-stagegl/lib/aglsl/Token":341}],334:[function(require,module,exports){
var Mapping = require("awayjs-stagegl/lib/aglsl/Mapping");
var ContextStage3D = require("awayjs-stagegl/lib/base/ContextStage3D");
var AGLSLParser = (function () {
    function AGLSLParser() {
    }
    AGLSLParser.prototype.parse = function (desc) {
        var header = "";
        var body = "";
        header += "precision highp float;\n";
        var tag = desc.header.type[0]; //TODO
        // declare uniforms
        if (desc.header.type == "vertex") {
            header += "uniform float yflip;\n";
        }
        if (!desc.hasindirect) {
            for (var i = 0; i < desc.regread[0x1].length; i++) {
                if (desc.regread[0x1][i]) {
                    header += "uniform vec4 " + tag + "c" + i + ";\n";
                }
            }
        }
        else {
            header += "uniform vec4 " + tag + "carrr[" + ContextStage3D.maxvertexconstants + "];\n"; // use max const count instead
        }
        for (var i = 0; i < desc.regread[0x2].length || i < desc.regwrite[0x2].length; i++) {
            if (desc.regread[0x2][i] || desc.regwrite[0x2][i]) {
                header += "vec4 " + tag + "t" + i + ";\n";
            }
        }
        for (var i = 0; i < desc.regread[0x0].length; i++) {
            if (desc.regread[0x0][i]) {
                header += "attribute vec4 va" + i + ";\n";
            }
        }
        for (var i = 0; i < desc.regread[0x4].length || i < desc.regwrite[0x4].length; i++) {
            if (desc.regread[0x4][i] || desc.regwrite[0x4][i]) {
                header += "varying vec4 vi" + i + ";\n";
            }
        }
        // declare samplers
        var samptype = ["2D", "Cube", "3D", ""];
        for (var i = 0; i < desc.samplers.length; i++) {
            if (desc.samplers[i]) {
                header += "uniform sampler" + samptype[desc.samplers[i].dim & 3] + " fs" + i + ";\n";
            }
        }
        // extra gl fluff: setup position and depth adjust temps
        if (desc.header.type == "vertex") {
            header += "vec4 outpos;\n";
        }
        if (desc.writedepth) {
            header += "vec4 tmp_FragDepth;\n";
        }
        //if ( desc.hasmatrix ) 
        //    header += "vec4 tmp_matrix;\n";
        // start body of code
        body += "void main() {\n";
        for (var i = 0; i < desc.tokens.length; i++) {
            var lutentry = Mapping.agal2glsllut[desc.tokens[i].opcode];
            if (!lutentry) {
                throw "Opcode not valid or not implemented yet: ";
            }
            var sublines = lutentry.matrixheight || 1;
            for (var sl = 0; sl < sublines; sl++) {
                var line = "  " + lutentry.s;
                if (desc.tokens[i].dest) {
                    if (lutentry.matrixheight) {
                        if (((desc.tokens[i].dest.mask >> sl) & 1) != 1) {
                            continue;
                        }
                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
                        var destcaststring = "float";
                        var destmaskstring = ["x", "y", "z", "w"][sl];
                        destregstring += "." + destmaskstring;
                    }
                    else {
                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
                        var destcaststring;
                        var destmaskstring;
                        if (desc.tokens[i].dest.mask != 0xf) {
                            var ndest = 0;
                            destmaskstring = "";
                            if (desc.tokens[i].dest.mask & 1) {
                                ndest++;
                                destmaskstring += "x";
                            }
                            if (desc.tokens[i].dest.mask & 2) {
                                ndest++;
                                destmaskstring += "y";
                            }
                            if (desc.tokens[i].dest.mask & 4) {
                                ndest++;
                                destmaskstring += "z";
                            }
                            if (desc.tokens[i].dest.mask & 8) {
                                ndest++;
                                destmaskstring += "w";
                            }
                            destregstring += "." + destmaskstring;
                            switch (ndest) {
                                case 1:
                                    destcaststring = "float";
                                    break;
                                case 2:
                                    destcaststring = "vec2";
                                    break;
                                case 3:
                                    destcaststring = "vec3";
                                    break;
                                default:
                                    throw "Unexpected destination mask";
                            }
                        }
                        else {
                            destcaststring = "vec4";
                            destmaskstring = "xyzw";
                        }
                    }
                    line = line.replace("%dest", destregstring);
                    line = line.replace("%cast", destcaststring);
                    line = line.replace("%dm", destmaskstring);
                }
                var dwm = 0xf;
                if (!lutentry.ndwm && lutentry.dest && desc.tokens[i].dest) {
                    dwm = desc.tokens[i].dest.mask;
                }
                if (desc.tokens[i].a) {
                    line = line.replace("%a", this.sourcetostring(desc.tokens[i].a, 0, dwm, lutentry.scalar, desc, tag));
                }
                if (desc.tokens[i].b) {
                    line = line.replace("%b", this.sourcetostring(desc.tokens[i].b, sl, dwm, lutentry.scalar, desc, tag));
                    if (desc.tokens[i].b.regtype == 0x5) {
                        // sampler dim
                        var texdim = ["2D", "Cube", "3D"][desc.tokens[i].b.dim];
                        var texsize = ["vec2", "vec3", "vec3"][desc.tokens[i].b.dim];
                        line = line.replace("%texdim", texdim);
                        line = line.replace("%texsize", texsize);
                        var texlod = "";
                        line = line.replace("%lod", texlod);
                    }
                }
                body += line;
            }
        }
        // adjust z from opengl range of -1..1 to 0..1 as in d3d, this also enforces a left handed coordinate system
        if (desc.header.type == "vertex") {
            body += "  gl_Position = vec4(outpos.x, outpos.y, outpos.z*2.0 - outpos.w, outpos.w);\n";
        }
        // clamp fragment depth
        if (desc.writedepth) {
            body += "  gl_FragDepth = clamp(tmp_FragDepth,0.0,1.0);\n";
        }
        // close main
        body += "}\n";
        return header + body;
    };
    AGLSLParser.prototype.regtostring = function (regtype, regnum, desc, tag) {
        switch (regtype) {
            case 0x0:
                return "va" + regnum;
            case 0x1:
                if (desc.hasindirect && desc.header.type == "vertex") {
                    return "vcarrr[" + regnum + "]";
                }
                else {
                    return tag + "c" + regnum;
                }
            case 0x2:
                return tag + "t" + regnum;
            case 0x3:
                return desc.header.type == "vertex" ? "outpos" : "gl_FragColor";
            case 0x4:
                return "vi" + regnum;
            case 0x5:
                return "fs" + regnum;
            case 0x6:
                return "tmp_FragDepth";
            default:
                throw "Unknown register type";
        }
    };
    AGLSLParser.prototype.sourcetostring = function (s, subline, dwm, isscalar, desc, tag) {
        var swiz = ["x", "y", "z", "w"];
        var r;
        if (s.indirectflag) {
            r = "vcarrr[int(" + this.regtostring(s.indexregtype, s.regnum, desc, tag) + "." + swiz[s.indexselect] + ")";
            var realofs = subline + s.indexoffset;
            if (realofs < 0)
                r += realofs.toString();
            if (realofs > 0)
                r += "+" + realofs.toString();
            r += "]";
        }
        else {
            r = this.regtostring(s.regtype, s.regnum + subline, desc, tag);
        }
        // samplers never add swizzle        
        if (s.regtype == 0x5) {
            return r;
        }
        // scalar, first component only
        if (isscalar) {
            return r + "." + swiz[(s.swizzle >> 0) & 3];
        }
        // identity
        if (s.swizzle == 0xe4 && dwm == 0xf) {
            return r;
        }
        // with destination write mask folded in
        r += ".";
        if (dwm & 1)
            r += swiz[(s.swizzle >> 0) & 3];
        if (dwm & 2)
            r += swiz[(s.swizzle >> 2) & 3];
        if (dwm & 4)
            r += swiz[(s.swizzle >> 4) & 3];
        if (dwm & 8)
            r += swiz[(s.swizzle >> 6) & 3];
        return r;
    };
    return AGLSLParser;
})();
module.exports = AGLSLParser;


},{"awayjs-stagegl/lib/aglsl/Mapping":338,"awayjs-stagegl/lib/base/ContextStage3D":363}],335:[function(require,module,exports){
var Header = require("awayjs-stagegl/lib/aglsl/Header");
var Description = (function () {
    function Description() {
        this.regread = [
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ];
        this.regwrite = [
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ];
        this.hasindirect = false;
        this.writedepth = false;
        this.hasmatrix = false;
        this.samplers = [];
        // added due to dynamic assignment 3*0xFFFFFFuuuu
        this.tokens = [];
        this.header = new Header();
    }
    return Description;
})();
module.exports = Description;


},{"awayjs-stagegl/lib/aglsl/Header":337}],336:[function(require,module,exports){
var Destination = (function () {
    function Destination() {
        this.mask = 0;
        this.regnum = 0;
        this.regtype = 0;
        this.dim = 0;
    }
    return Destination;
})();
module.exports = Destination;


},{}],337:[function(require,module,exports){
var Header = (function () {
    function Header() {
        this.progid = 0;
        this.version = 0;
        this.type = "";
    }
    return Header;
})();
module.exports = Header;


},{}],338:[function(require,module,exports){
var OpLUT = require("awayjs-stagegl/lib/aglsl/OpLUT");
var Mapping = (function () {
    //TODO: get rid of hack that fixes including definition file
    function Mapping(include) {
    }
    Mapping.agal2glsllut = [
        new OpLUT("%dest = %cast(%a);\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(%a + %b);\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(%a - %b);\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(%a * %b);\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(%a / %b);\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(1.0) / %a;\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(min(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(max(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(fract(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(sqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(inversesqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(pow(abs(%a),%b));\n", 0, true, true, true, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(log2(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(exp2(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(normalize(vec3( %a ) ));\n", 0, true, true, false, null, null, true, null, null, null),
        new OpLUT("%dest = %cast(sin(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(cos(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(cross(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
        new OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
        new OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
        new OpLUT("%dest = %cast(abs(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(%a * -1.0);\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(clamp(%a,0.0,1.0));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", null, true, true, true, 3, 3, true, null, null, null),
        new OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 4, true, null, null, null),
        new OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 3, true, null, null, null),
        new OpLUT("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("if (float(%a)==float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
        new OpLUT("if (float(%a)!=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
        new OpLUT("if (float(%a)>=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
        new OpLUT("if (float(%a)<float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
        new OpLUT("} else {;\n", 0, false, false, false, null, null, null, null, null, null),
        new OpLUT("};\n", 0, false, false, false, null, null, null, null, null, null),
        new OpLUT(null, null, null, null, false, null, null, null, null, null, null),
        new OpLUT(null, null, null, null, false, null, null, null, null, null, null),
        new OpLUT(null, null, null, null, false, null, null, null, null, null, null),
        new OpLUT(null, null, null, null, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(texture%texdimLod(%b,%texsize(%a)).%dm);\n", null, true, true, true, null, null, null, null, true, null),
        new OpLUT("if ( float(%a)<0.0 ) discard;\n", null, false, true, false, null, null, null, true, null, null),
        new OpLUT("%dest = %cast(texture%texdim(%b,%texsize(%a)%lod).%dm);\n", null, true, true, true, null, null, true, null, true, true),
        new OpLUT("%dest = %cast(greaterThanEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null),
        new OpLUT("%dest = %cast(lessThan(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null),
        new OpLUT("%dest = %cast(sign(%a));\n", 0, true, true, false, null, null, null, null, null, null),
        new OpLUT("%dest = %cast(equal(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null),
        new OpLUT("%dest = %cast(notEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null)
    ];
    return Mapping;
})();
module.exports = Mapping;


},{"awayjs-stagegl/lib/aglsl/OpLUT":339}],339:[function(require,module,exports){
var OpLUT = (function () {
    function OpLUT(s, flags, dest, a, b, matrixwidth, matrixheight, ndwm, scaler, dm, lod) {
        this.s = s;
        this.flags = flags;
        this.dest = dest;
        this.a = a;
        this.b = b;
        this.matrixwidth = matrixwidth;
        this.matrixheight = matrixheight;
        this.ndwm = ndwm;
        this.scalar = scaler;
        this.dm = dm;
        this.lod = lod;
    }
    return OpLUT;
})();
module.exports = OpLUT;


},{}],340:[function(require,module,exports){
var Sampler = (function () {
    function Sampler() {
        this.lodbias = 0;
        this.dim = 0;
        this.readmode = 0;
        this.special = 0;
        this.wrap = 0;
        this.mipmap = 0;
        this.filter = 0;
    }
    return Sampler;
})();
module.exports = Sampler;


},{}],341:[function(require,module,exports){
var Destination = require("awayjs-stagegl/lib/aglsl/Destination");
var Token = (function () {
    function Token() {
        this.dest = new Destination();
        this.opcode = 0;
        this.a = new Destination();
        this.b = new Destination();
    }
    return Token;
})();
module.exports = Token;


},{"awayjs-stagegl/lib/aglsl/Destination":336}],342:[function(require,module,exports){
var OpcodeMap = require("awayjs-stagegl/lib/aglsl/assembler/OpcodeMap");
var Part = require("awayjs-stagegl/lib/aglsl/assembler/Part");
var RegMap = require("awayjs-stagegl/lib/aglsl/assembler/RegMap");
var SamplerMap = require("awayjs-stagegl/lib/aglsl/assembler/SamplerMap");
var AGALMiniAssembler = (function () {
    function AGALMiniAssembler() {
        this.r = {};
        this.cur = new Part();
    }
    AGALMiniAssembler.prototype.assemble = function (source, ext_part, ext_version) {
        if (ext_part === void 0) { ext_part = null; }
        if (ext_version === void 0) { ext_version = null; }
        if (!ext_version) {
            ext_version = 1;
        }
        if (ext_part) {
            this.addHeader(ext_part, ext_version);
        }
        var lines = source.replace(/[\f\n\r\v]+/g, "\n").split("\n"); // handle breaks, then split into lines
        for (var i in lines) {
            this.processLine(lines[i], i);
        }
        return this.r;
    };
    AGALMiniAssembler.prototype.processLine = function (line, linenr) {
        var startcomment = line.search("//"); // remove comments
        if (startcomment != -1) {
            line = line.slice(0, startcomment);
        }
        line = line.replace(/^\s+|\s+$/g, ""); // remove outer space
        if (!(line.length > 0)) {
            return;
        }
        var optsi = line.search(/<.*>/g); // split of options part <*> if there
        var opts = null;
        if (optsi != -1) {
            opts = line.slice(optsi).match(/([\w\.\-\+]+)/gi);
            line = line.slice(0, optsi);
        }
        // get opcode/command				            
        var tokens = line.match(/([\w\.\+\[\]]+)/gi); // get tokens in line
        if (!tokens || tokens.length < 1) {
            if (line.length >= 3) {
                console.log("Warning: bad line " + linenr + ": " + line);
            }
            return;
        }
        switch (tokens[0]) {
            case "part":
                this.addHeader(tokens[1], Number(tokens[2]));
                break;
            case "endpart":
                if (!this.cur) {
                    throw "Unexpected endpart";
                }
                this.cur.data.position = 0;
                this.cur = null;
                return;
            default:
                if (!this.cur) {
                    console.log("Warning: bad line " + linenr + ": " + line + " (Outside of any part definition)");
                    return;
                }
                if (this.cur.name == "comment") {
                    return;
                }
                var op = OpcodeMap.map[tokens[0]];
                if (!op) {
                    throw "Bad opcode " + tokens[0] + " " + linenr + ": " + line;
                }
                // console.log( 'AGALMiniAssembler' , 'op' , op );
                this.emitOpcode(this.cur, op.opcode);
                var ti = 1;
                if (op.dest && op.dest != "none") {
                    if (!this.emitDest(this.cur, tokens[ti++], op.dest)) {
                        throw "Bad destination register " + tokens[ti - 1] + " " + linenr + ": " + line;
                    }
                }
                else {
                    this.emitZeroDword(this.cur);
                }
                if (op.a && op.a.format != "none") {
                    if (!this.emitSource(this.cur, tokens[ti++], op.a))
                        throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
                }
                else {
                    this.emitZeroQword(this.cur);
                }
                if (op.b && op.b.format != "none") {
                    if (op.b.format == "sampler") {
                        if (!this.emitSampler(this.cur, tokens[ti++], op.b, opts)) {
                            throw "Bad sampler register " + tokens[ti - 1] + " " + linenr + ": " + line;
                        }
                    }
                    else {
                        if (!this.emitSource(this.cur, tokens[ti++], op.b)) {
                            throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
                        }
                    }
                }
                else {
                    this.emitZeroQword(this.cur);
                }
                break;
        }
    };
    AGALMiniAssembler.prototype.emitHeader = function (pr) {
        pr.data.writeUnsignedByte(0xa0); // tag version
        pr.data.writeUnsignedInt(pr.version);
        if (pr.version >= 0x10) {
            pr.data.writeUnsignedByte(0); // align, for higher versions
        }
        pr.data.writeUnsignedByte(0xa1); // tag program id
        switch (pr.name) {
            case "fragment":
                pr.data.writeUnsignedByte(1);
                break;
            case "vertex":
                pr.data.writeUnsignedByte(0);
                break;
            case "cpu":
                pr.data.writeUnsignedByte(2);
                break;
            default:
                pr.data.writeUnsignedByte(0xff);
                break;
        }
    };
    AGALMiniAssembler.prototype.emitOpcode = function (pr, opcode) {
        pr.data.writeUnsignedInt(opcode);
        //console.log ( "Emit opcode: ", opcode ); 
    };
    AGALMiniAssembler.prototype.emitZeroDword = function (pr) {
        pr.data.writeUnsignedInt(0);
    };
    AGALMiniAssembler.prototype.emitZeroQword = function (pr) {
        pr.data.writeUnsignedInt(0);
        pr.data.writeUnsignedInt(0);
    };
    AGALMiniAssembler.prototype.emitDest = function (pr, token, opdest) {
        //console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map' , RegMap.map);
        var reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:mask
        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'reg' , reg , reg[1] , RegMap.map[reg[1]] );
        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map[reg[1]]' , RegMap.map[reg[1]] , 'bool' , !RegMap.map[reg[1]] ) ;
        if (!RegMap.map[reg[1]])
            return false;
        var em = { num: reg[2] ? reg[2] : 0, code: RegMap.map[reg[1]].code, mask: this.stringToMask(reg[3]) };
        pr.data.writeUnsignedShort(em.num);
        pr.data.writeUnsignedByte(em.mask);
        pr.data.writeUnsignedByte(em.code);
        //console.log ( "  Emit dest: ", em );
        return true;
    };
    AGALMiniAssembler.prototype.stringToMask = function (s) {
        if (!s)
            return 0xf;
        var r = 0;
        if (s.indexOf("x") != -1)
            r |= 1;
        if (s.indexOf("y") != -1)
            r |= 2;
        if (s.indexOf("z") != -1)
            r |= 4;
        if (s.indexOf("w") != -1)
            r |= 8;
        return r;
    };
    AGALMiniAssembler.prototype.stringToSwizzle = function (s) {
        if (!s) {
            return 0xe4;
        }
        var chartoindex = { x: 0, y: 1, z: 2, w: 3 };
        var sw = 0;
        if (s.charAt(0) != ".") {
            throw "Missing . for swizzle";
        }
        if (s.length > 1) {
            sw |= chartoindex[s.charAt(1)];
        }
        if (s.length > 2) {
            sw |= chartoindex[s.charAt(2)] << 2;
        }
        else {
            sw |= (sw & 3) << 2;
        }
        if (s.length > 3) {
            sw |= chartoindex[s.charAt(3)] << 4;
        }
        else {
            sw |= (sw & (3 << 2)) << 2;
        }
        if (s.length > 4) {
            sw |= chartoindex[s.charAt(4)] << 6;
        }
        else {
            sw |= (sw & (3 << 4)) << 2;
        }
        return sw;
    };
    AGALMiniAssembler.prototype.emitSampler = function (pr, token, opsrc, opts) {
        var reg = token.match(/fs(\d*)/i); // g1:regnum
        if (!reg || !reg[1]) {
            return false;
        }
        pr.data.writeUnsignedShort(parseInt(reg[1]));
        pr.data.writeUnsignedByte(0); // bias
        pr.data.writeUnsignedByte(0);
        /*
         pr.data.writeUnsignedByte ( 0x5 );
         pr.data.writeUnsignedByte ( 0 );   // readmode, dim
         pr.data.writeUnsignedByte ( 0 );   // special, wrap
         pr.data.writeUnsignedByte ( 0 );   // mip, filter
         */
        var samplerbits = 0x5;
        var sampleroptset = 0;
        for (var i = 0; i < opts.length; i++) {
            var o = SamplerMap.map[opts[i].toLowerCase()];
            //console.log( 'AGALMiniAssembler' , 'emitSampler' , 'SampleMap opt:' , o , '<-------- WATCH FOR THIS');
            if (o) {
                if (((sampleroptset >> o.shift) & o.mask) != 0) {
                    console.log("Warning, duplicate sampler option");
                }
                sampleroptset |= o.mask << o.shift;
                samplerbits &= ~(o.mask << o.shift);
                samplerbits |= o.value << o.shift;
            }
            else {
                console.log("Warning, unknown sampler option: ", opts[i]);
            }
        }
        pr.data.writeUnsignedInt(samplerbits);
        return true;
    };
    AGALMiniAssembler.prototype.emitSource = function (pr, token, opsrc) {
        var indexed = token.match(/vc\[(v[tcai])(\d+)\.([xyzw])([\+\-]\d+)?\](\.[xyzw]{1,4})?/i); // g1: indexregname, g2:indexregnum, g3:select, [g4:offset], [g5:swizzle]
        var reg;
        if (indexed) {
            if (!RegMap.map[indexed[1]]) {
                return false;
            }
            var selindex = { x: 0, y: 1, z: 2, w: 3 };
            var em = { num: indexed[2] | 0, code: RegMap.map[indexed[1]].code, swizzle: this.stringToSwizzle(indexed[5]), select: selindex[indexed[3]], offset: indexed[4] | 0 };
            pr.data.writeUnsignedShort(em.num);
            pr.data.writeByte(em.offset);
            pr.data.writeUnsignedByte(em.swizzle);
            pr.data.writeUnsignedByte(0x1); // constant reg
            pr.data.writeUnsignedByte(em.code);
            pr.data.writeUnsignedByte(em.select);
            pr.data.writeUnsignedByte(1 << 7);
        }
        else {
            reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:swizzle
            if (!RegMap.map[reg[1]]) {
                return false;
            }
            var em = { num: reg[2] | 0, code: RegMap.map[reg[1]].code, swizzle: this.stringToSwizzle(reg[3]) };
            pr.data.writeUnsignedShort(em.num);
            pr.data.writeUnsignedByte(0);
            pr.data.writeUnsignedByte(em.swizzle);
            pr.data.writeUnsignedByte(em.code);
            pr.data.writeUnsignedByte(0);
            pr.data.writeUnsignedByte(0);
            pr.data.writeUnsignedByte(0);
        }
        return true;
    };
    AGALMiniAssembler.prototype.addHeader = function (partname, version) {
        if (!version) {
            version = 1;
        }
        if (this.r[partname] == undefined) {
            this.r[partname] = new Part(partname, version);
            this.emitHeader(this.r[partname]);
        }
        else if (this.r[partname].version != version) {
            throw "Multiple versions for part " + partname;
        }
        this.cur = this.r[partname];
    };
    return AGALMiniAssembler;
})();
module.exports = AGALMiniAssembler;


},{"awayjs-stagegl/lib/aglsl/assembler/OpcodeMap":346,"awayjs-stagegl/lib/aglsl/assembler/Part":347,"awayjs-stagegl/lib/aglsl/assembler/RegMap":348,"awayjs-stagegl/lib/aglsl/assembler/SamplerMap":350}],343:[function(require,module,exports){
var FS = (function () {
    function FS() {
    }
    return FS;
})();
module.exports = FS;


},{}],344:[function(require,module,exports){
var Flags = (function () {
    function Flags() {
    }
    return Flags;
})();
module.exports = Flags;


},{}],345:[function(require,module,exports){
var Flags = require("awayjs-stagegl/lib/aglsl/assembler/Flags");
var FS = require("awayjs-stagegl/lib/aglsl/assembler/FS");
/**
 *
 */
var Opcode = (function () {
    function Opcode(dest, aformat, asize, bformat, bsize, opcode, simple, horizontal, fragonly, matrix) {
        this.a = new FS();
        this.b = new FS();
        this.flags = new Flags();
        this.dest = dest;
        this.a.format = aformat;
        this.a.size = asize;
        this.b.format = bformat;
        this.b.size = bsize;
        this.opcode = opcode;
        this.flags.simple = simple;
        this.flags.horizontal = horizontal;
        this.flags.fragonly = fragonly;
        this.flags.matrix = matrix;
    }
    return Opcode;
})();
module.exports = Opcode;


},{"awayjs-stagegl/lib/aglsl/assembler/FS":343,"awayjs-stagegl/lib/aglsl/assembler/Flags":344}],346:[function(require,module,exports){
var Opcode = require("awayjs-stagegl/lib/aglsl/assembler/Opcode");
var OpcodeMap = (function () {
    function OpcodeMap() {
    }
    Object.defineProperty(OpcodeMap, "map", {
        get: function () {
            if (!OpcodeMap._map) {
                OpcodeMap._map = new Array();
                OpcodeMap._map['mov'] = new Opcode("vector", "vector", 4, "none", 0, 0x00, true, null, null, null);
                OpcodeMap._map['add'] = new Opcode("vector", "vector", 4, "vector", 4, 0x01, true, null, null, null);
                OpcodeMap._map['sub'] = new Opcode("vector", "vector", 4, "vector", 4, 0x02, true, null, null, null);
                OpcodeMap._map['mul'] = new Opcode("vector", "vector", 4, "vector", 4, 0x03, true, null, null, null);
                OpcodeMap._map['div'] = new Opcode("vector", "vector", 4, "vector", 4, 0x04, true, null, null, null);
                OpcodeMap._map['rcp'] = new Opcode("vector", "vector", 4, "none", 0, 0x05, true, null, null, null);
                OpcodeMap._map['min'] = new Opcode("vector", "vector", 4, "vector", 4, 0x06, true, null, null, null);
                OpcodeMap._map['max'] = new Opcode("vector", "vector", 4, "vector", 4, 0x07, true, null, null, null);
                OpcodeMap._map['frc'] = new Opcode("vector", "vector", 4, "none", 0, 0x08, true, null, null, null);
                OpcodeMap._map['sqt'] = new Opcode("vector", "vector", 4, "none", 0, 0x09, true, null, null, null);
                OpcodeMap._map['rsq'] = new Opcode("vector", "vector", 4, "none", 0, 0x0a, true, null, null, null);
                OpcodeMap._map['pow'] = new Opcode("vector", "vector", 4, "vector", 4, 0x0b, true, null, null, null);
                OpcodeMap._map['log'] = new Opcode("vector", "vector", 4, "none", 0, 0x0c, true, null, null, null);
                OpcodeMap._map['exp'] = new Opcode("vector", "vector", 4, "none", 0, 0x0d, true, null, null, null);
                OpcodeMap._map['nrm'] = new Opcode("vector", "vector", 4, "none", 0, 0x0e, true, null, null, null);
                OpcodeMap._map['sin'] = new Opcode("vector", "vector", 4, "none", 0, 0x0f, true, null, null, null);
                OpcodeMap._map['cos'] = new Opcode("vector", "vector", 4, "none", 0, 0x10, true, null, null, null);
                OpcodeMap._map['crs'] = new Opcode("vector", "vector", 4, "vector", 4, 0x11, true, true, null, null);
                OpcodeMap._map['dp3'] = new Opcode("vector", "vector", 4, "vector", 4, 0x12, true, true, null, null);
                OpcodeMap._map['dp4'] = new Opcode("vector", "vector", 4, "vector", 4, 0x13, true, true, null, null);
                OpcodeMap._map['abs'] = new Opcode("vector", "vector", 4, "none", 0, 0x14, true, null, null, null);
                OpcodeMap._map['neg'] = new Opcode("vector", "vector", 4, "none", 0, 0x15, true, null, null, null);
                OpcodeMap._map['sat'] = new Opcode("vector", "vector", 4, "none", 0, 0x16, true, null, null, null);
                OpcodeMap._map['ted'] = new Opcode("vector", "vector", 4, "sampler", 1, 0x26, true, null, true, null);
                OpcodeMap._map['kil'] = new Opcode("none", "scalar", 1, "none", 0, 0x27, true, null, true, null);
                OpcodeMap._map['tex'] = new Opcode("vector", "vector", 4, "sampler", 1, 0x28, true, null, true, null);
                OpcodeMap._map['m33'] = new Opcode("vector", "matrix", 3, "vector", 3, 0x17, true, null, null, true);
                OpcodeMap._map['m44'] = new Opcode("vector", "matrix", 4, "vector", 4, 0x18, true, null, null, true);
                OpcodeMap._map['m43'] = new Opcode("vector", "matrix", 3, "vector", 4, 0x19, true, null, null, true);
                OpcodeMap._map['sge'] = new Opcode("vector", "vector", 4, "vector", 4, 0x29, true, null, null, null);
                OpcodeMap._map['slt'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2a, true, null, null, null);
                OpcodeMap._map['sgn'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2b, true, null, null, null);
                OpcodeMap._map['seq'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2c, true, null, null, null);
                OpcodeMap._map['sne'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2d, true, null, null, null);
            }
            return OpcodeMap._map;
        },
        enumerable: true,
        configurable: true
    });
    return OpcodeMap;
})();
module.exports = OpcodeMap;


},{"awayjs-stagegl/lib/aglsl/assembler/Opcode":345}],347:[function(require,module,exports){
var ByteArray = require("awayjs-core/lib/utils/ByteArray");
var Part = (function () {
    function Part(name, version) {
        if (name === void 0) { name = null; }
        if (version === void 0) { version = null; }
        this.name = "";
        this.version = 0;
        this.name = name;
        this.version = version;
        this.data = new ByteArray();
    }
    return Part;
})();
module.exports = Part;


},{"awayjs-core/lib/utils/ByteArray":459}],348:[function(require,module,exports){
var Reg = (function () {
    function Reg(code, desc) {
        this.code = code;
        this.desc = desc;
    }
    return Reg;
})();
var RegMap = (function () {
    /*
     public static va:Reg = new Reg( 0x00, "vertex attribute" );
     public static fc:Reg = new Reg( 0x01, "fragment constant" );
     public static vc:Reg = new Reg( 0x01, "vertex constant" );
     public static ft:Reg = new Reg( 0x02, "fragment temporary" );
     public static vt:Reg = new Reg( 0x02, "vertex temporary" );
     public static vo:Reg = new Reg( 0x03, "vertex output" );
     public static op:Reg = new Reg( 0x03, "vertex output" );
     public static fd:Reg = new Reg( 0x03, "fragment depth output" );
     public static fo:Reg = new Reg( 0x03, "fragment output" );
     public static oc:Reg = new Reg( 0x03, "fragment output" );
     public static v: Reg = new Reg( 0x04, "varying" );
     public static vi:Reg = new Reg( 0x04, "varying output" );
     public static fi:Reg = new Reg( 0x04, "varying input" );
     public static fs:Reg = new Reg( 0x05, "sampler" );
     */
    function RegMap() {
    }
    Object.defineProperty(RegMap, "map", {
        get: function () {
            if (!RegMap._map) {
                RegMap._map = new Array();
                RegMap._map['va'] = new Reg(0x00, "vertex attribute");
                RegMap._map['fc'] = new Reg(0x01, "fragment constant");
                RegMap._map['vc'] = new Reg(0x01, "vertex constant");
                RegMap._map['ft'] = new Reg(0x02, "fragment temporary");
                RegMap._map['vt'] = new Reg(0x02, "vertex temporary");
                RegMap._map['vo'] = new Reg(0x03, "vertex output");
                RegMap._map['op'] = new Reg(0x03, "vertex output");
                RegMap._map['fd'] = new Reg(0x03, "fragment depth output");
                RegMap._map['fo'] = new Reg(0x03, "fragment output");
                RegMap._map['oc'] = new Reg(0x03, "fragment output");
                RegMap._map['v'] = new Reg(0x04, "varying");
                RegMap._map['vi'] = new Reg(0x04, "varying output");
                RegMap._map['fi'] = new Reg(0x04, "varying input");
                RegMap._map['fs'] = new Reg(0x05, "sampler");
            }
            return RegMap._map;
        },
        enumerable: true,
        configurable: true
    });
    return RegMap;
})();
module.exports = RegMap;


},{}],349:[function(require,module,exports){
var Sampler = (function () {
    function Sampler(shift, mask, value) {
        this.shift = shift;
        this.mask = mask;
        this.value = value;
    }
    return Sampler;
})();
module.exports = Sampler;


},{}],350:[function(require,module,exports){
var Sampler = require("awayjs-stagegl/lib/aglsl/assembler/Sampler");
var SamplerMap = (function () {
    /*
     public static map =     [ new Sampler( 8, 0xf, 0 ),
     new Sampler( 8, 0xf, 5 ),
     new Sampler( 8, 0xf, 4 ),
     new Sampler( 8, 0xf, 1 ),
     new Sampler( 8, 0xf, 2 ),
     new Sampler( 8, 0xf, 1 ),
     new Sampler( 8, 0xf, 2 ),

     // dimension
     new Sampler( 12, 0xf, 0 ),
     new Sampler( 12, 0xf, 1 ),
     new Sampler( 12, 0xf, 2 ),

     // special
     new Sampler( 16, 1, 1 ),
     new Sampler( 16, 4, 4 ),

     // repeat
     new Sampler( 20, 0xf, 0 ),
     new Sampler( 20, 0xf, 1 ),
     new Sampler( 20, 0xf, 1 ),

     // mip
     new Sampler( 24, 0xf, 0 ),
     new Sampler( 24, 0xf, 0 ),
     new Sampler( 24, 0xf, 1 ),
     new Sampler( 24, 0xf, 2 ),

     // filter
     new Sampler( 28, 0xf, 0 ),
     new Sampler( 28, 0xf, 1 ) ]
     */
    /*
     public static rgba: Sampler = new Sampler( 8, 0xf, 0 );
     public static rg: Sampler = new Sampler( 8, 0xf, 5 );
     public static r: Sampler = new Sampler( 8, 0xf, 4 );
     public static compressed: Sampler = new Sampler( 8, 0xf, 1 );
     public static compressed_alpha: Sampler = new Sampler( 8, 0xf, 2 );
     public static dxt1: Sampler = new Sampler( 8, 0xf, 1 );
     public static dxt5: Sampler = new Sampler( 8, 0xf, 2 );

     // dimension
     public static sampler2d: Sampler = new Sampler( 12, 0xf, 0 );
     public static cube: Sampler = new Sampler( 12, 0xf, 1 );
     public static sampler3d: Sampler = new Sampler( 12, 0xf, 2 );

     // special
     public static centroid: Sampler = new Sampler( 16, 1, 1 );
     public static ignoresampler: Sampler = new Sampler( 16, 4, 4 );

     // repeat
     public static clamp: Sampler = new Sampler( 20, 0xf, 0 );
     public static repeat: Sampler = new Sampler( 20, 0xf, 1 );
     public static wrap: Sampler = new Sampler( 20, 0xf, 1 );

     // mip
     public static nomip: Sampler = new Sampler( 24, 0xf, 0 );
     public static mipnone: Sampler = new Sampler( 24, 0xf, 0 );
     public static mipnearest: Sampler = new Sampler( 24, 0xf, 1 );
     public static miplinear: Sampler = new Sampler( 24, 0xf, 2 );

     // filter
     public static nearest: Sampler = new Sampler( 28, 0xf, 0 );
     public static linear: Sampler = new Sampler( 28, 0xf, 1 );
     */
    function SamplerMap() {
    }
    Object.defineProperty(SamplerMap, "map", {
        get: function () {
            if (!SamplerMap._map) {
                SamplerMap._map = new Array();
                SamplerMap._map['rgba'] = new Sampler(8, 0xf, 0);
                SamplerMap._map['rg'] = new Sampler(8, 0xf, 5);
                SamplerMap._map['r'] = new Sampler(8, 0xf, 4);
                SamplerMap._map['compressed'] = new Sampler(8, 0xf, 1);
                SamplerMap._map['compressed_alpha'] = new Sampler(8, 0xf, 2);
                SamplerMap._map['dxt1'] = new Sampler(8, 0xf, 1);
                SamplerMap._map['dxt5'] = new Sampler(8, 0xf, 2);
                // dimension
                SamplerMap._map['2d'] = new Sampler(12, 0xf, 0);
                SamplerMap._map['cube'] = new Sampler(12, 0xf, 1);
                SamplerMap._map['3d'] = new Sampler(12, 0xf, 2);
                // special
                SamplerMap._map['centroid'] = new Sampler(16, 1, 1);
                SamplerMap._map['ignoresampler'] = new Sampler(16, 4, 4);
                // repeat
                SamplerMap._map['clamp'] = new Sampler(20, 0xf, 0);
                SamplerMap._map['repeat'] = new Sampler(20, 0xf, 1);
                SamplerMap._map['wrap'] = new Sampler(20, 0xf, 1);
                // mip
                SamplerMap._map['nomip'] = new Sampler(24, 0xf, 0);
                SamplerMap._map['mipnone'] = new Sampler(24, 0xf, 0);
                SamplerMap._map['mipnearest'] = new Sampler(24, 0xf, 1);
                SamplerMap._map['miplinear'] = new Sampler(24, 0xf, 2);
                // filter
                SamplerMap._map['nearest'] = new Sampler(28, 0xf, 0);
                SamplerMap._map['linear'] = new Sampler(28, 0xf, 1);
            }
            return SamplerMap._map;
        },
        enumerable: true,
        configurable: true
    });
    return SamplerMap;
})();
module.exports = SamplerMap;


},{"awayjs-stagegl/lib/aglsl/assembler/Sampler":349}],351:[function(require,module,exports){
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var RenderTexture = require("awayjs-core/lib/textures/RenderTexture");
var AGALMiniAssembler = require("awayjs-stagegl/lib/aglsl/assembler/AGALMiniAssembler");
var TextureDataPool = require("awayjs-stagegl/lib/pool/TextureDataPool");
var ProgramDataPool = require("awayjs-stagegl/lib/pool/ProgramDataPool");
var MaterialDataPool = require("awayjs-stagegl/lib/pool/MaterialDataPool");
var ContextGLClearMask = require("awayjs-stagegl/lib/base/ContextGLClearMask");
var ContextGLTextureFormat = require("awayjs-stagegl/lib/base/ContextGLTextureFormat");
/**
 * Stage provides a proxy class to handle the creation and attachment of the Context
 * (and in turn the back buffer) it uses. Stage should never be created directly,
 * but requested through StageManager.
 *
 * @see away.managers.StageManager
 *
 */
var ContextGLBase = (function () {
    function ContextGLBase(stageIndex) {
        this._programData = new Array();
        this._numUsedStreams = 0;
        this._numUsedTextures = 0;
        //private static _frameEventDriver:Shape = new Shape(); // TODO: add frame driver / request animation frame
        this._stageIndex = -1;
        this._antiAlias = 0;
        this._renderTarget = null;
        this._renderSurfaceSelector = 0;
        this._stageIndex = stageIndex;
        this._texturePool = new TextureDataPool(this);
        this._materialDataPool = new MaterialDataPool(this);
        this._programDataPool = new ProgramDataPool(this);
    }
    Object.defineProperty(ContextGLBase.prototype, "container", {
        get: function () {
            return this._pContainer;
        },
        enumerable: true,
        configurable: true
    });
    ContextGLBase.prototype.setRenderTarget = function (target, enableDepthAndStencil, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        if (this._renderTarget === target && surfaceSelector == this._renderSurfaceSelector && this._enableDepthAndStencil == enableDepthAndStencil)
            return;
        this._renderTarget = target;
        this._renderSurfaceSelector = surfaceSelector;
        this._enableDepthAndStencil = enableDepthAndStencil;
        if (target instanceof RenderTexture) {
            this.setRenderToTexture(this.getRenderTexture(target), enableDepthAndStencil, this._antiAlias, surfaceSelector);
        }
        else {
            this.setRenderToBackBuffer();
            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
        }
    };
    ContextGLBase.prototype.getRenderTexture = function (textureProxy) {
        var textureData = this._texturePool.getItem(textureProxy);
        if (!textureData.texture)
            textureData.texture = this.createTexture(textureProxy.width, textureProxy.height, ContextGLTextureFormat.BGRA, true);
        return textureData.texture;
    };
    ContextGLBase.prototype.getProgram = function (materialPassData) {
        //check key doesn't need re-concatenating
        if (!materialPassData.key.length) {
            materialPassData.key = materialPassData.animationVertexCode + materialPassData.vertexCode + "---" + materialPassData.fragmentCode + materialPassData.animationFragmentCode + materialPassData.postAnimationFragmentCode;
        }
        else {
            return materialPassData.programData;
        }
        var programData = this._programDataPool.getItem(materialPassData.key);
        //check program data hasn't changed, keep count of program usages
        if (materialPassData.programData != programData) {
            if (materialPassData.programData)
                materialPassData.programData.dispose();
            materialPassData.programData = programData;
            programData.usages++;
        }
        return programData;
    };
    /**
     *
     * @param material
     */
    ContextGLBase.prototype.getMaterial = function (material, profile) {
        var materialData = this._materialDataPool.getItem(material);
        if (materialData.invalidAnimation) {
            materialData.invalidAnimation = false;
            var materialDataPasses = materialData.getMaterialPasses(profile);
            var enabledGPUAnimation = this.getEnabledGPUAnimation(material, materialDataPasses);
            var renderOrderId = 0;
            var mult = 1;
            var materialPassData;
            var len = materialDataPasses.length;
            for (var i = 0; i < len; i++) {
                materialPassData = materialDataPasses[i];
                if (materialPassData.usesAnimation != enabledGPUAnimation) {
                    materialPassData.usesAnimation = enabledGPUAnimation;
                    materialPassData.key == "";
                }
                if (materialPassData.key == "")
                    this.calcAnimationCode(material, materialPassData);
                renderOrderId += this.getProgram(materialPassData).id * mult;
                mult *= 1000;
            }
            materialData.renderOrderId = renderOrderId;
        }
        return materialData;
    };
    /**
     * Assigns an attribute stream
     *
     * @param index The attribute stream index for the vertex shader
     * @param buffer
     * @param offset
     * @param stride
     * @param format
     */
    ContextGLBase.prototype.activateBuffer = function (index, buffer, offset, format) {
        if (!buffer.contexts[this._stageIndex])
            buffer.contexts[this._stageIndex] = this;
        if (!buffer.buffers[this._stageIndex]) {
            buffer.buffers[this._stageIndex] = this.createVertexBuffer(buffer.data.length / buffer.dataPerVertex, buffer.dataPerVertex);
            buffer.invalid[this._stageIndex] = true;
        }
        if (buffer.invalid[this._stageIndex]) {
            buffer.buffers[this._stageIndex].uploadFromArray(buffer.data, 0, buffer.data.length / buffer.dataPerVertex);
            buffer.invalid[this._stageIndex] = false;
        }
        this.setVertexBufferAt(index, buffer.buffers[this._stageIndex], offset, format);
    };
    ContextGLBase.prototype.disposeVertexData = function (buffer) {
        buffer.buffers[this._stageIndex].dispose();
        buffer.buffers[this._stageIndex] = null;
    };
    ContextGLBase.prototype.activateRenderTexture = function (index, textureProxy) {
        this.setTextureAt(index, this.getRenderTexture(textureProxy));
    };
    ContextGLBase.prototype.activateMaterialPass = function (materialPassData, stage, camera) {
        var shaderObject = materialPassData.shaderObject;
        for (var i = shaderObject.numUsedStreams; i < this._numUsedStreams; i++)
            this.setVertexBufferAt(i, null);
        for (var i = shaderObject.numUsedTextures; i < this._numUsedTextures; i++)
            this.setTextureAt(i, null);
        if (materialPassData.usesAnimation)
            materialPassData.material.animationSet.activate(shaderObject, stage);
        //activate shader object
        shaderObject.iActivate(stage, camera);
        //check program data is uploaded
        var programData = this.getProgram(materialPassData);
        if (!programData.program) {
            programData.program = this.createProgram();
            var vertexByteCode = (new AGALMiniAssembler().assemble("part vertex 1\n" + materialPassData.animationVertexCode + materialPassData.vertexCode + "endpart"))['vertex'].data;
            var fragmentByteCode = (new AGALMiniAssembler().assemble("part fragment 1\n" + materialPassData.fragmentCode + materialPassData.animationFragmentCode + materialPassData.postAnimationFragmentCode + "endpart"))['fragment'].data;
            programData.program.upload(vertexByteCode, fragmentByteCode);
        }
        //set program data
        this.setProgram(programData.program);
    };
    ContextGLBase.prototype.deactivateMaterialPass = function (materialPassData, stage) {
        var shaderObject = materialPassData.shaderObject;
        if (materialPassData.usesAnimation)
            materialPassData.material.animationSet.deactivate(shaderObject, stage);
        materialPassData.shaderObject.iDeactivate(stage);
        this._numUsedStreams = shaderObject.numUsedStreams;
        this._numUsedTextures = shaderObject.numUsedTextures;
    };
    ContextGLBase.prototype.activateTexture = function (index, textureProxy) {
        var textureData = this._texturePool.getItem(textureProxy);
        if (!textureData.texture) {
            textureData.texture = this.createTexture(textureProxy.width, textureProxy.height, ContextGLTextureFormat.BGRA, true);
            textureData.invalid = true;
        }
        if (textureData.invalid) {
            textureData.invalid = false;
            if (textureProxy.generateMipmaps) {
                var mipmapData = textureProxy._iGetMipmapData();
                var len = mipmapData.length;
                for (var i = 0; i < len; i++)
                    textureData.texture.uploadFromData(mipmapData[i], i);
            }
            else {
                textureData.texture.uploadFromData(textureProxy._iGetTextureData(), 0);
            }
        }
        this.setTextureAt(index, textureData.texture);
    };
    ContextGLBase.prototype.activateCubeTexture = function (index, textureProxy) {
        var textureData = this._texturePool.getItem(textureProxy);
        if (!textureData.texture) {
            textureData.texture = this.createCubeTexture(textureProxy.size, ContextGLTextureFormat.BGRA, false);
            textureData.invalid = true;
        }
        if (textureData.invalid) {
            textureData.invalid = false;
            for (var i = 0; i < 6; ++i) {
                if (textureProxy.generateMipmaps) {
                    var mipmapData = textureProxy._iGetMipmapData(i);
                    var len = mipmapData.length;
                    for (var j = 0; j < len; j++)
                        textureData.texture.uploadFromData(mipmapData[j], i, j);
                }
                else {
                    textureData.texture.uploadFromData(textureProxy._iGetTextureData(i), i, 0);
                }
            }
        }
        this.setTextureAt(index, textureData.texture);
    };
    /**
     * Retrieves the VertexBuffer object that contains triangle indices.
     * @param context The ContextWeb for which we request the buffer
     * @return The VertexBuffer object that contains triangle indices.
     */
    ContextGLBase.prototype.getIndexBuffer = function (buffer) {
        if (!buffer.contexts[this._stageIndex])
            buffer.contexts[this._stageIndex] = this;
        if (!buffer.buffers[this._stageIndex]) {
            buffer.buffers[this._stageIndex] = this.createIndexBuffer(buffer.data.length);
            buffer.invalid[this._stageIndex] = true;
        }
        if (buffer.invalid[this._stageIndex]) {
            buffer.buffers[this._stageIndex].uploadFromArray(buffer.data, 0, buffer.data.length);
            buffer.invalid[this._stageIndex] = false;
        }
        return buffer.buffers[this._stageIndex];
    };
    ContextGLBase.prototype.disposeIndexData = function (buffer) {
        buffer.buffers[this._stageIndex].dispose();
        buffer.buffers[this._stageIndex] = null;
    };
    ContextGLBase.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = ContextGLClearMask.ALL; }
    };
    ContextGLBase.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
        this._width = width;
        this._height = height;
    };
    ContextGLBase.prototype.createIndexBuffer = function (numIndices) {
        throw new AbstractMethodError();
    };
    ContextGLBase.prototype.createVertexBuffer = function (numVertices, data32PerVertex) {
        throw new AbstractMethodError();
    };
    ContextGLBase.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        throw new AbstractMethodError();
    };
    ContextGLBase.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        throw new AbstractMethodError();
    };
    ContextGLBase.prototype.createProgram = function () {
        throw new AbstractMethodError();
    };
    ContextGLBase.prototype.dispose = function () {
    };
    ContextGLBase.prototype.present = function () {
    };
    ContextGLBase.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (antiAlias === void 0) { antiAlias = 0; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
    };
    ContextGLBase.prototype.setRenderToBackBuffer = function () {
    };
    ContextGLBase.prototype.setScissorRectangle = function (rectangle) {
    };
    ContextGLBase.prototype.setTextureAt = function (sampler, texture) {
    };
    ContextGLBase.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        if (bufferOffset === void 0) { bufferOffset = 0; }
        if (format === void 0) { format = null; }
    };
    ContextGLBase.prototype.setProgram = function (program) {
    };
    ContextGLBase.prototype.registerProgram = function (programData) {
        var i = 0;
        while (this._programData[i] != null)
            i++;
        this._programData[i] = programData;
        programData.id = i;
    };
    ContextGLBase.prototype.unRegisterProgram = function (programData) {
        this._programData[programData.id] = null;
        programData.id = -1;
    };
    /**
     * test if animation will be able to run on gpu BEFORE compiling materials
     * test if the shader objects supports animating the animation set in the vertex shader
     * if any object using this material fails to support accelerated animations for any of the shader objects,
     * we should do everything on cpu (otherwise we have the cost of both gpu + cpu animations)
     */
    ContextGLBase.prototype.getEnabledGPUAnimation = function (material, materialDataPasses) {
        if (material.animationSet) {
            material.animationSet.resetGPUCompatibility();
            var owners = material.iOwners;
            var numOwners = owners.length;
            var len = materialDataPasses.length;
            for (var i = 0; i < len; i++)
                for (var j = 0; j < numOwners; j++)
                    if (owners[j].animator)
                        owners[j].animator.testGPUCompatibility(materialDataPasses[i].shaderObject);
            return !material.animationSet.usesCPU;
        }
        return false;
    };
    ContextGLBase.prototype.calcAnimationCode = function (material, materialPassData) {
        //reset key so that the program is re-calculated
        materialPassData.key = "";
        materialPassData.animationVertexCode = "";
        materialPassData.animationFragmentCode = "";
        var shaderObject = materialPassData.shaderObject;
        //check to see if GPU animation is used
        if (materialPassData.usesAnimation) {
            var animationSet = material.animationSet;
            materialPassData.animationVertexCode += animationSet.getAGALVertexCode(shaderObject);
            if (shaderObject.uvDependencies > 0 && !shaderObject.usesUVTransform)
                materialPassData.animationVertexCode += animationSet.getAGALUVCode(shaderObject);
            if (shaderObject.usesFragmentAnimation)
                materialPassData.animationFragmentCode += animationSet.getAGALFragmentCode(shaderObject, materialPassData.shadedTarget);
            animationSet.doneAGALCode(shaderObject);
        }
        else {
            // simply write attributes to targets, do not animate them
            // projection will pick up on targets[0] to do the projection
            var len = shaderObject.animatableAttributes.length;
            for (var i = 0; i < len; ++i)
                materialPassData.animationVertexCode += "mov " + shaderObject.animationTargetRegisters[i] + ", " + shaderObject.animatableAttributes[i] + "\n";
            if (shaderObject.uvDependencies > 0 && !shaderObject.usesUVTransform)
                materialPassData.animationVertexCode += "mov " + shaderObject.uvTarget + "," + shaderObject.uvSource + "\n";
        }
    };
    return ContextGLBase;
})();
module.exports = ContextGLBase;


},{"awayjs-core/lib/errors/AbstractMethodError":438,"awayjs-core/lib/textures/RenderTexture":456,"awayjs-stagegl/lib/aglsl/assembler/AGALMiniAssembler":342,"awayjs-stagegl/lib/base/ContextGLClearMask":353,"awayjs-stagegl/lib/base/ContextGLTextureFormat":359,"awayjs-stagegl/lib/pool/MaterialDataPool":420,"awayjs-stagegl/lib/pool/ProgramDataPool":424,"awayjs-stagegl/lib/pool/TextureDataPool":428}],352:[function(require,module,exports){
module.exports=require(192)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLBlendFactor.js":192}],353:[function(require,module,exports){
var ContextGLClearMask = (function () {
    function ContextGLClearMask() {
    }
    ContextGLClearMask.COLOR = 1;
    ContextGLClearMask.DEPTH = 2;
    ContextGLClearMask.STENCIL = 4;
    ContextGLClearMask.ALL = ContextGLClearMask.COLOR | ContextGLClearMask.DEPTH | ContextGLClearMask.STENCIL;
    return ContextGLClearMask;
})();
module.exports = ContextGLClearMask;


},{}],354:[function(require,module,exports){
module.exports=require(193)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLCompareMode.js":193}],355:[function(require,module,exports){
module.exports=require(194)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLMipFilter.js":194}],356:[function(require,module,exports){
module.exports=require(195)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLProfile.js":195}],357:[function(require,module,exports){
module.exports=require(196)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLProgramType.js":196}],358:[function(require,module,exports){
module.exports=require(197)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLTextureFilter.js":197}],359:[function(require,module,exports){
module.exports=require(198)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLTextureFormat.js":198}],360:[function(require,module,exports){
module.exports=require(199)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLTriangleFace.js":199}],361:[function(require,module,exports){
var ContextGLVertexBufferFormat = (function () {
    function ContextGLVertexBufferFormat() {
    }
    ContextGLVertexBufferFormat.BYTES_4 = "bytes4";
    ContextGLVertexBufferFormat.FLOAT_1 = "float1";
    ContextGLVertexBufferFormat.FLOAT_2 = "float2";
    ContextGLVertexBufferFormat.FLOAT_3 = "float3";
    ContextGLVertexBufferFormat.FLOAT_4 = "float4";
    return ContextGLVertexBufferFormat;
})();
module.exports = ContextGLVertexBufferFormat;


},{}],362:[function(require,module,exports){
module.exports=require(200)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/base/ContextGLWrapMode.js":200}],363:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var swfobject = require("awayjs-stagegl/lib/swfobject");
var Sampler = require("awayjs-stagegl/lib/aglsl/Sampler");
var ContextGLBase = require("awayjs-stagegl/lib/base/ContextGLBase");
var ContextGLClearMask = require("awayjs-stagegl/lib/base/ContextGLClearMask");
var ContextGLProgramType = require("awayjs-stagegl/lib/base/ContextGLProgramType");
var CubeTextureFlash = require("awayjs-stagegl/lib/base/CubeTextureFlash");
var IndexBufferFlash = require("awayjs-stagegl/lib/base/IndexBufferFlash");
var OpCodes = require("awayjs-stagegl/lib/base/OpCodes");
var ProgramFlash = require("awayjs-stagegl/lib/base/ProgramFlash");
var TextureFlash = require("awayjs-stagegl/lib/base/TextureFlash");
var VertexBufferFlash = require("awayjs-stagegl/lib/base/VertexBufferFlash");
var ContextStage3D = (function (_super) {
    __extends(ContextStage3D, _super);
    //TODO: get rid of hack that fixes including definition file
    function ContextStage3D(container, stageIndex, callback, include) {
        _super.call(this, stageIndex);
        this._cmdStream = "";
        this._resources = new Array();
        var swfVersionStr = "11.0.0";
        // To use express install, set to playerProductInstall.swf, otherwise the empty string.
        var flashvars = {
            id: container.id
        };
        var params = {
            quality: "high",
            bgcolor: "#ffffff",
            allowscriptaccess: "sameDomain",
            allowfullscreen: "true",
            wmode: "direct"
        };
        this._errorCheckingEnabled = false;
        this._iDriverInfo = "Unknown";
        var attributes = {
            salign: "tl",
            id: container.id,
            name: container["name"] //TODO: needed?
        };
        this._oldCanvas = container.cloneNode(); // keep the old one to restore on dispose
        this._oldParent = container.parentNode;
        var context3dObj = this;
        ContextStage3D.contexts[container.id] = this;
        function callbackSWFObject(callbackInfo) {
            if (!callbackInfo.success)
                return;
            context3dObj._pContainer = callbackInfo.ref;
            context3dObj._iCallback = callback;
        }
        swfobject.embedSWF("libs/molehill_js_flashbridge.swf", container.id, String(container.width), String(container.height), swfVersionStr, "", flashvars, params, attributes, callbackSWFObject);
    }
    Object.defineProperty(ContextStage3D.prototype, "container", {
        get: function () {
            return this._pContainer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextStage3D.prototype, "driverInfo", {
        get: function () {
            return this._iDriverInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextStage3D.prototype, "errorCheckingEnabled", {
        get: function () {
            return this._errorCheckingEnabled;
        },
        set: function (value) {
            if (this._errorCheckingEnabled == value)
                return;
            this._errorCheckingEnabled = value;
            this.addStream(String.fromCharCode(OpCodes.enableErrorChecking, value ? OpCodes.trueValue : OpCodes.falseValue));
            this.execute();
        },
        enumerable: true,
        configurable: true
    });
    ContextStage3D.prototype._iAddResource = function (resource) {
        this._resources.push(resource);
    };
    ContextStage3D.prototype._iRemoveResource = function (resource) {
        this._resources.splice(this._resources.indexOf(resource));
    };
    ContextStage3D.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO:streaming
        return new TextureFlash(this, width, height, format, optimizeForRenderToTexture);
    };
    ContextStage3D.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO:streaming
        return new CubeTextureFlash(this, size, format, optimizeForRenderToTexture);
    };
    ContextStage3D.prototype.setTextureAt = function (sampler, texture) {
        if (texture) {
            this.addStream(String.fromCharCode(OpCodes.setTextureAt) + sampler + "," + texture.id + ",");
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.clearTextureAt) + sampler.toString() + ",");
        }
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
        //nothing to do here
    };
    ContextStage3D.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail) {
        if (triangleFace === void 0) { triangleFace = "frontAndBack"; }
        if (compareMode === void 0) { compareMode = "always"; }
        if (actionOnBothPass === void 0) { actionOnBothPass = "keep"; }
        if (actionOnDepthFail === void 0) { actionOnDepthFail = "keep"; }
        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = "keep"; }
        this.addStream(String.fromCharCode(OpCodes.setStencilActions) + triangleFace + "$" + compareMode + "$" + actionOnBothPass + "$" + actionOnDepthFail + "$" + actionOnDepthPassStencilFail + "$");
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
        if (readMask === void 0) { readMask = 255; }
        if (writeMask === void 0) { writeMask = 255; }
        this.addStream(String.fromCharCode(OpCodes.setStencilReferenceValue, referenceValue + OpCodes.intMask, readMask + OpCodes.intMask, writeMask + OpCodes.intMask));
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
        //TODO implement coordinateSystem option
        this.addStream(String.fromCharCode(OpCodes.setCulling) + triangleFaceToCull + "$");
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.drawTriangles = function (indexBuffer, firstIndex, numTriangles) {
        if (firstIndex === void 0) { firstIndex = 0; }
        if (numTriangles === void 0) { numTriangles = -1; }
        firstIndex = firstIndex || 0;
        if (!numTriangles || numTriangles < 0)
            numTriangles = indexBuffer.numIndices / 3;
        this.addStream(String.fromCharCode(OpCodes.drawTriangles, indexBuffer.id + OpCodes.intMask) + firstIndex + "," + numTriangles + ",");
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setProgramConstantsFromMatrix = function (programType, firstRegister, matrix, transposedMatrix) {
        //this._gl.uniformMatrix4fv(this._gl.getUniformLocation(this._currentProgram.glProgram, this._uniformLocationNameDictionary[programType]), !transposedMatrix, new Float32Array(matrix.rawData));
        if (transposedMatrix === void 0) { transposedMatrix = false; }
        //TODO remove special case for WebGL matrix calls?
        var d = matrix.rawData;
        if (transposedMatrix) {
            this.setProgramConstantsFromArray(programType, firstRegister, [d[0], d[4], d[8], d[12]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 1, [d[1], d[5], d[9], d[13]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 2, [d[2], d[6], d[10], d[14]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 3, [d[3], d[7], d[11], d[15]], 1);
        }
        else {
            this.setProgramConstantsFromArray(programType, firstRegister, [d[0], d[1], d[2], d[3]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 1, [d[4], d[5], d[6], d[7]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 2, [d[8], d[9], d[10], d[11]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 3, [d[12], d[13], d[14], d[15]], 1);
        }
    };
    ContextStage3D.prototype.setProgramConstantsFromArray = function (programType, firstRegister, data, numRegisters) {
        if (numRegisters === void 0) { numRegisters = -1; }
        var startIndex;
        var target = (programType == ContextGLProgramType.VERTEX) ? OpCodes.trueValue : OpCodes.falseValue;
        for (var i = 0; i < numRegisters; i++) {
            startIndex = i * 4;
            this.addStream(String.fromCharCode(OpCodes.setProgramConstant, target, (firstRegister + i) + OpCodes.intMask) + data[startIndex] + "," + data[startIndex + 1] + "," + data[startIndex + 2] + "," + data[startIndex + 3] + ",");
            if (ContextStage3D.debug)
                this.execute();
        }
    };
    ContextStage3D.prototype.setProgram = function (program) {
        this.addStream(String.fromCharCode(OpCodes.setProgram, program.id + OpCodes.intMask));
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.present = function () {
        this.addStream(String.fromCharCode(OpCodes.present));
        this.execute();
    };
    ContextStage3D.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = ContextGLClearMask.ALL; }
        this.addStream(String.fromCharCode(OpCodes.clear) + red + "," + green + "," + blue + "," + alpha + "," + depth + "," + stencil + "," + mask + ",");
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.createProgram = function () {
        return new ProgramFlash(this);
    };
    ContextStage3D.prototype.createVertexBuffer = function (numVertices, data32PerVertex) {
        return new VertexBufferFlash(this, numVertices, data32PerVertex);
    };
    ContextStage3D.prototype.createIndexBuffer = function (numIndices) {
        return new IndexBufferFlash(this, numIndices);
    };
    ContextStage3D.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
        _super.prototype.configureBackBuffer.call(this, width, height, antiAlias, enableDepthAndStencil);
        //TODO: add Anitalias setting
        this.addStream(String.fromCharCode(OpCodes.configureBackBuffer) + width + "," + height + ",");
    };
    ContextStage3D.prototype.drawToBitmapData = function (destination) {
        //TODO
    };
    ContextStage3D.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        if (bufferOffset === void 0) { bufferOffset = 0; }
        if (format === void 0) { format = null; }
        if (buffer) {
            this.addStream(String.fromCharCode(OpCodes.setVertexBufferAt, index + OpCodes.intMask) + buffer.id + "," + bufferOffset + "," + format + "$");
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.clearVertexBufferAt, index + OpCodes.intMask));
        }
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setColorMask = function (red, green, blue, alpha) {
        this.addStream(String.fromCharCode(OpCodes.setColorMask, red ? OpCodes.trueValue : OpCodes.falseValue, green ? OpCodes.trueValue : OpCodes.falseValue, blue ? OpCodes.trueValue : OpCodes.falseValue, alpha ? OpCodes.trueValue : OpCodes.falseValue));
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
        this.addStream(String.fromCharCode(OpCodes.setBlendFactors) + sourceFactor + "$" + destinationFactor + "$");
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (antiAlias === void 0) { antiAlias = 0; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        if (target === null || target === undefined) {
            this.addStream(String.fromCharCode(OpCodes.clearRenderToTexture));
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.setRenderToTexture, enableDepthAndStencil ? OpCodes.trueValue : OpCodes.falseValue) + target.id + "," + (antiAlias || 0) + ",");
        }
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setRenderToBackBuffer = function () {
        this.addStream(String.fromCharCode(OpCodes.clearRenderToTexture));
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setScissorRectangle = function (rectangle) {
        if (rectangle) {
            this.addStream(String.fromCharCode(OpCodes.setScissorRect) + rectangle.x + "," + rectangle.y + "," + rectangle.width + "," + rectangle.height + ",");
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.clearScissorRect));
        }
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.setDepthTest = function (depthMask, passCompareMode) {
        this.addStream(String.fromCharCode(OpCodes.setDepthTest, depthMask ? OpCodes.trueValue : OpCodes.falseValue) + passCompareMode + "$");
        if (ContextStage3D.debug)
            this.execute();
    };
    ContextStage3D.prototype.dispose = function () {
        if (this._pContainer == null)
            return;
        console.log("Context3D dispose, releasing " + this._resources.length + " resources.");
        while (this._resources.length)
            this._resources[0].dispose();
        if (this._pContainer) {
            // encode command
            this.addStream(String.fromCharCode(OpCodes.disposeContext));
            this.execute();
            swfobject.removeSWF(this._oldCanvas.id);
            if (this._oldCanvas && this._oldParent) {
                this._oldParent.appendChild(this._oldCanvas);
                this._oldParent = null;
            }
            this._pContainer = null;
        }
        this._oldCanvas = null;
    };
    ContextStage3D.prototype.addStream = function (stream) {
        this._cmdStream += stream;
    };
    ContextStage3D.prototype.execute = function () {
        if (ContextStage3D.logStream)
            console.log(this._cmdStream);
        var result = this._pContainer["CallFunction"]("<invoke name=\"execStage3dOpStream\" returntype=\"javascript\"><arguments><string>" + this._cmdStream + "</string></arguments></invoke>");
        if (Number(result) <= -3)
            throw "Exec stream failed";
        this._cmdStream = "";
        return Number(result);
    };
    ContextStage3D.contexts = new Object();
    ContextStage3D.maxvertexconstants = 128;
    ContextStage3D.maxfragconstants = 28;
    ContextStage3D.maxtemp = 8;
    ContextStage3D.maxstreams = 8;
    ContextStage3D.maxtextures = 8;
    ContextStage3D.defaultsampler = new Sampler();
    ContextStage3D.debug = false;
    ContextStage3D.logStream = false;
    return ContextStage3D;
})(ContextGLBase);
/**
* global function for flash callback
*/
function mountain_js_context_available(id, driverInfo) {
    var ctx = ContextStage3D.contexts[id];
    if (ctx._iCallback) {
        ctx._iDriverInfo = driverInfo;
        // get out of the current JS stack frame and call back from flash player
        var timeOutId = window.setTimeout(function () {
            window.clearTimeout(timeOutId);
            try {
                ctx._iCallback(ctx);
            }
            catch (e) {
                console.log("Callback failed during flash initialization with '" + e.toString() + "'");
            }
        }, 1);
    }
}
module.exports = ContextStage3D;


},{"awayjs-stagegl/lib/aglsl/Sampler":340,"awayjs-stagegl/lib/base/ContextGLBase":351,"awayjs-stagegl/lib/base/ContextGLClearMask":353,"awayjs-stagegl/lib/base/ContextGLProgramType":357,"awayjs-stagegl/lib/base/CubeTextureFlash":365,"awayjs-stagegl/lib/base/IndexBufferFlash":367,"awayjs-stagegl/lib/base/OpCodes":369,"awayjs-stagegl/lib/base/ProgramFlash":370,"awayjs-stagegl/lib/base/TextureFlash":376,"awayjs-stagegl/lib/base/VertexBufferFlash":378,"awayjs-stagegl/lib/swfobject":436}],364:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
var ByteArray = require("awayjs-core/lib/utils/ByteArray");
var ContextGLBase = require("awayjs-stagegl/lib/base/ContextGLBase");
var ContextGLBlendFactor = require("awayjs-stagegl/lib/base/ContextGLBlendFactor");
var ContextGLClearMask = require("awayjs-stagegl/lib/base/ContextGLClearMask");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLProgramType = require("awayjs-stagegl/lib/base/ContextGLProgramType");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLTriangleFace = require("awayjs-stagegl/lib/base/ContextGLTriangleFace");
var ContextGLVertexBufferFormat = require("awayjs-stagegl/lib/base/ContextGLVertexBufferFormat");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var CubeTextureWebGL = require("awayjs-stagegl/lib/base/CubeTextureWebGL");
var IndexBufferWebGL = require("awayjs-stagegl/lib/base/IndexBufferWebGL");
var ProgramWebGL = require("awayjs-stagegl/lib/base/ProgramWebGL");
var TextureWebGL = require("awayjs-stagegl/lib/base/TextureWebGL");
var SamplerState = require("awayjs-stagegl/lib/base/SamplerState");
var VertexBufferWebGL = require("awayjs-stagegl/lib/base/VertexBufferWebGL");
var ContextWebGL = (function (_super) {
    __extends(ContextWebGL, _super);
    function ContextWebGL(canvas, stageIndex) {
        _super.call(this, stageIndex);
        this._blendFactorDictionary = new Object();
        this._depthTestDictionary = new Object();
        this._textureIndexDictionary = new Array(8);
        this._textureTypeDictionary = new Object();
        this._wrapDictionary = new Object();
        this._filterDictionary = new Object();
        this._mipmapFilterDictionary = new Object();
        this._uniformLocationNameDictionary = new Object();
        this._vertexBufferDimensionDictionary = new Object();
        this._indexBufferList = new Array();
        this._vertexBufferList = new Array();
        this._textureList = new Array();
        this._programList = new Array();
        this._samplerStates = new Array(8);
        this._pContainer = canvas;
        try {
            this._gl = canvas.getContext("experimental-webgl", { premultipliedAlpha: false, alpha: false });
            if (!this._gl)
                this._gl = canvas.getContext("webgl", { premultipliedAlpha: false, alpha: false });
        }
        catch (e) {
        }
        if (this._gl) {
            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_SUCCESS ) );
            //setup shortcut dictionaries
            this._blendFactorDictionary[ContextGLBlendFactor.ONE] = this._gl.ONE;
            this._blendFactorDictionary[ContextGLBlendFactor.DESTINATION_ALPHA] = this._gl.DST_ALPHA;
            this._blendFactorDictionary[ContextGLBlendFactor.DESTINATION_COLOR] = this._gl.DST_COLOR;
            this._blendFactorDictionary[ContextGLBlendFactor.ONE] = this._gl.ONE;
            this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA] = this._gl.ONE_MINUS_DST_ALPHA;
            this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR] = this._gl.ONE_MINUS_DST_COLOR;
            this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA] = this._gl.ONE_MINUS_SRC_ALPHA;
            this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR] = this._gl.ONE_MINUS_SRC_COLOR;
            this._blendFactorDictionary[ContextGLBlendFactor.SOURCE_ALPHA] = this._gl.SRC_ALPHA;
            this._blendFactorDictionary[ContextGLBlendFactor.SOURCE_COLOR] = this._gl.SRC_COLOR;
            this._blendFactorDictionary[ContextGLBlendFactor.ZERO] = this._gl.ZERO;
            this._depthTestDictionary[ContextGLCompareMode.ALWAYS] = this._gl.ALWAYS;
            this._depthTestDictionary[ContextGLCompareMode.EQUAL] = this._gl.EQUAL;
            this._depthTestDictionary[ContextGLCompareMode.GREATER] = this._gl.GREATER;
            this._depthTestDictionary[ContextGLCompareMode.GREATER_EQUAL] = this._gl.GEQUAL;
            this._depthTestDictionary[ContextGLCompareMode.LESS] = this._gl.LESS;
            this._depthTestDictionary[ContextGLCompareMode.LESS_EQUAL] = this._gl.LEQUAL;
            this._depthTestDictionary[ContextGLCompareMode.NEVER] = this._gl.NEVER;
            this._depthTestDictionary[ContextGLCompareMode.NOT_EQUAL] = this._gl.NOTEQUAL;
            this._textureIndexDictionary[0] = this._gl.TEXTURE0;
            this._textureIndexDictionary[1] = this._gl.TEXTURE1;
            this._textureIndexDictionary[2] = this._gl.TEXTURE2;
            this._textureIndexDictionary[3] = this._gl.TEXTURE3;
            this._textureIndexDictionary[4] = this._gl.TEXTURE4;
            this._textureIndexDictionary[5] = this._gl.TEXTURE5;
            this._textureIndexDictionary[6] = this._gl.TEXTURE6;
            this._textureIndexDictionary[7] = this._gl.TEXTURE7;
            this._textureTypeDictionary["texture2d"] = this._gl.TEXTURE_2D;
            this._textureTypeDictionary["textureCube"] = this._gl.TEXTURE_CUBE_MAP;
            this._wrapDictionary[ContextGLWrapMode.REPEAT] = this._gl.REPEAT;
            this._wrapDictionary[ContextGLWrapMode.CLAMP] = this._gl.CLAMP_TO_EDGE;
            this._filterDictionary[ContextGLTextureFilter.LINEAR] = this._gl.LINEAR;
            this._filterDictionary[ContextGLTextureFilter.NEAREST] = this._gl.NEAREST;
            this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR] = new Object();
            this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR][ContextGLMipFilter.MIPNEAREST] = this._gl.LINEAR_MIPMAP_NEAREST;
            this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR][ContextGLMipFilter.MIPLINEAR] = this._gl.LINEAR_MIPMAP_LINEAR;
            this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR][ContextGLMipFilter.MIPNONE] = this._gl.LINEAR;
            this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST] = new Object();
            this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST][ContextGLMipFilter.MIPNEAREST] = this._gl.NEAREST_MIPMAP_NEAREST;
            this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST][ContextGLMipFilter.MIPLINEAR] = this._gl.NEAREST_MIPMAP_LINEAR;
            this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST][ContextGLMipFilter.MIPNONE] = this._gl.NEAREST;
            this._uniformLocationNameDictionary[ContextGLProgramType.VERTEX] = "vc";
            this._uniformLocationNameDictionary[ContextGLProgramType.FRAGMENT] = "fc";
            this._vertexBufferDimensionDictionary[ContextGLVertexBufferFormat.FLOAT_1] = 1;
            this._vertexBufferDimensionDictionary[ContextGLVertexBufferFormat.FLOAT_2] = 2;
            this._vertexBufferDimensionDictionary[ContextGLVertexBufferFormat.FLOAT_3] = 3;
            this._vertexBufferDimensionDictionary[ContextGLVertexBufferFormat.FLOAT_4] = 4;
            this._vertexBufferDimensionDictionary[ContextGLVertexBufferFormat.BYTES_4] = 4;
        }
        else {
            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
            alert("WebGL is not available.");
        }
        for (var i = 0; i < ContextWebGL.MAX_SAMPLERS; ++i) {
            this._samplerStates[i] = new SamplerState();
            this._samplerStates[i].wrap = this._gl.REPEAT;
            this._samplerStates[i].filter = this._gl.LINEAR;
            this._samplerStates[i].mipfilter = this._gl.LINEAR;
        }
    }
    Object.defineProperty(ContextWebGL.prototype, "container", {
        get: function () {
            return this._pContainer;
        },
        enumerable: true,
        configurable: true
    });
    ContextWebGL.prototype.gl = function () {
        return this._gl;
    };
    ContextWebGL.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = ContextGLClearMask.ALL; }
        if (!this._drawing) {
            this.updateBlendStatus();
            this._drawing = true;
        }
        var glmask = 0;
        if (mask & ContextGLClearMask.COLOR)
            glmask |= this._gl.COLOR_BUFFER_BIT;
        if (mask & ContextGLClearMask.STENCIL)
            glmask |= this._gl.STENCIL_BUFFER_BIT;
        if (mask & ContextGLClearMask.DEPTH)
            glmask |= this._gl.DEPTH_BUFFER_BIT;
        this._gl.clearColor(red, green, blue, alpha);
        this._gl.clearDepth(depth);
        this._gl.clearStencil(stencil);
        this._gl.clear(glmask);
    };
    ContextWebGL.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
        _super.prototype.configureBackBuffer.call(this, width, height, antiAlias, enableDepthAndStencil);
        if (enableDepthAndStencil) {
            this._gl.enable(this._gl.STENCIL_TEST);
            this._gl.enable(this._gl.DEPTH_TEST);
        }
        this._gl.viewport['width'] = width;
        this._gl.viewport['height'] = height;
        this._gl.viewport(0, 0, width, height);
    };
    ContextWebGL.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        var texture = new CubeTextureWebGL(this._gl, size);
        this._textureList.push(texture);
        return texture;
    };
    ContextWebGL.prototype.createIndexBuffer = function (numIndices) {
        var indexBuffer = new IndexBufferWebGL(this._gl, numIndices);
        this._indexBufferList.push(indexBuffer);
        return indexBuffer;
    };
    ContextWebGL.prototype.createProgram = function () {
        var program = new ProgramWebGL(this._gl);
        this._programList.push(program);
        return program;
    };
    ContextWebGL.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO streaming
        var texture = new TextureWebGL(this._gl, width, height);
        this._textureList.push(texture);
        return texture;
    };
    ContextWebGL.prototype.createVertexBuffer = function (numVertices, data32PerVertex) {
        var vertexBuffer = new VertexBufferWebGL(this._gl, numVertices, data32PerVertex);
        this._vertexBufferList.push(vertexBuffer);
        return vertexBuffer;
    };
    ContextWebGL.prototype.dispose = function () {
        var i;
        for (i = 0; i < this._indexBufferList.length; ++i)
            this._indexBufferList[i].dispose();
        this._indexBufferList = null;
        for (i = 0; i < this._vertexBufferList.length; ++i)
            this._vertexBufferList[i].dispose();
        this._vertexBufferList = null;
        for (i = 0; i < this._textureList.length; ++i)
            this._textureList[i].dispose();
        this._textureList = null;
        for (i = 0; i < this._programList.length; ++i)
            this._programList[i].dispose();
        for (i = 0; i < this._samplerStates.length; ++i)
            this._samplerStates[i] = null;
        this._programList = null;
    };
    ContextWebGL.prototype.drawToBitmapData = function (destination) {
        var arrayBuffer = new ArrayBuffer(destination.width * destination.height * 4);
        this._gl.readPixels(0, 0, destination.width, destination.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, new Uint8Array(arrayBuffer));
        var byteArray = new ByteArray();
        byteArray.setArrayBuffer(arrayBuffer);
        destination.setPixels(new Rectangle(0, 0, destination.width, destination.height), byteArray);
    };
    ContextWebGL.prototype.drawTriangles = function (indexBuffer, firstIndex, numTriangles) {
        if (firstIndex === void 0) { firstIndex = 0; }
        if (numTriangles === void 0) { numTriangles = -1; }
        if (!this._drawing)
            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
        this._gl.drawElements(this._gl.TRIANGLES, (numTriangles == -1) ? indexBuffer.numIndices : numTriangles * 3, this._gl.UNSIGNED_SHORT, firstIndex);
    };
    ContextWebGL.prototype.present = function () {
        this._drawing = false;
    };
    ContextWebGL.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
        this._blendEnabled = true;
        this._blendSourceFactor = this._blendFactorDictionary[sourceFactor];
        this._blendDestinationFactor = this._blendFactorDictionary[destinationFactor];
        this.updateBlendStatus();
    };
    ContextWebGL.prototype.setColorMask = function (red, green, blue, alpha) {
        this._gl.colorMask(red, green, blue, alpha);
    };
    ContextWebGL.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
        if (triangleFaceToCull == ContextGLTriangleFace.NONE) {
            this._gl.disable(this._gl.CULL_FACE);
        }
        else {
            this._gl.enable(this._gl.CULL_FACE);
            switch (triangleFaceToCull) {
                case ContextGLTriangleFace.BACK:
                    this._gl.cullFace((coordinateSystem == "leftHanded") ? this._gl.FRONT : this._gl.BACK);
                    break;
                case ContextGLTriangleFace.FRONT:
                    this._gl.cullFace((coordinateSystem == "leftHanded") ? this._gl.BACK : this._gl.FRONT);
                    break;
                case ContextGLTriangleFace.FRONT_AND_BACK:
                    this._gl.cullFace(this._gl.FRONT_AND_BACK);
                    break;
                default:
                    throw "Unknown ContextGLTriangleFace type.";
            }
        }
    };
    // TODO ContextGLCompareMode
    ContextWebGL.prototype.setDepthTest = function (depthMask, passCompareMode) {
        this._gl.depthFunc(this._depthTestDictionary[passCompareMode]);
        this._gl.depthMask(depthMask);
    };
    ContextWebGL.prototype.setProgram = function (program) {
        //TODO decide on construction/reference resposibilities
        this._currentProgram = program;
        program.focusProgram();
    };
    ContextWebGL.prototype.setProgramConstantsFromMatrix = function (programType, firstRegister, matrix, transposedMatrix) {
        //this._gl.uniformMatrix4fv(this._gl.getUniformLocation(this._currentProgram.glProgram, this._uniformLocationNameDictionary[programType]), !transposedMatrix, new Float32Array(matrix.rawData));
        if (transposedMatrix === void 0) { transposedMatrix = false; }
        //TODO remove special case for WebGL matrix calls?
        var d = matrix.rawData;
        if (transposedMatrix) {
            this.setProgramConstantsFromArray(programType, firstRegister, [d[0], d[4], d[8], d[12]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 1, [d[1], d[5], d[9], d[13]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 2, [d[2], d[6], d[10], d[14]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 3, [d[3], d[7], d[11], d[15]], 1);
        }
        else {
            this.setProgramConstantsFromArray(programType, firstRegister, [d[0], d[1], d[2], d[3]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 1, [d[4], d[5], d[6], d[7]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 2, [d[8], d[9], d[10], d[11]], 1);
            this.setProgramConstantsFromArray(programType, firstRegister + 3, [d[12], d[13], d[14], d[15]], 1);
        }
    };
    ContextWebGL.prototype.setProgramConstantsFromArray = function (programType, firstRegister, data, numRegisters) {
        if (numRegisters === void 0) { numRegisters = -1; }
        var locationName = this._uniformLocationNameDictionary[programType];
        var startIndex;
        for (var i = 0; i < numRegisters; i++) {
            startIndex = i * 4;
            this._gl.uniform4f(this._gl.getUniformLocation(this._currentProgram.glProgram, locationName + (firstRegister + i)), data[startIndex], data[startIndex + 1], data[startIndex + 2], data[startIndex + 3]);
        }
    };
    ContextWebGL.prototype.setScissorRectangle = function (rectangle) {
        if (!rectangle) {
            this._gl.disable(this._gl.SCISSOR_TEST);
            return;
        }
        this._gl.enable(this._gl.SCISSOR_TEST);
        this._gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    ContextWebGL.prototype.setTextureAt = function (sampler, texture) {
        var samplerState = this._samplerStates[sampler];
        if (this._activeTexture != sampler && (texture || samplerState.type)) {
            this._activeTexture = sampler;
            this._gl.activeTexture(this._textureIndexDictionary[sampler]);
        }
        if (!texture) {
            if (samplerState.type) {
                this._gl.bindTexture(samplerState.type, null);
                samplerState.type = null;
            }
            return;
        }
        var textureType = this._textureTypeDictionary[texture.textureType];
        samplerState.type = textureType;
        this._gl.bindTexture(textureType, texture.glTexture);
        this._gl.uniform1i(this._gl.getUniformLocation(this._currentProgram.glProgram, "fs" + sampler), sampler);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, samplerState.mipfilter);
    };
    ContextWebGL.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
        if (0 <= sampler && sampler < ContextWebGL.MAX_SAMPLERS) {
            this._samplerStates[sampler].wrap = this._wrapDictionary[wrap];
            this._samplerStates[sampler].filter = this._filterDictionary[filter];
            this._samplerStates[sampler].mipfilter = this._mipmapFilterDictionary[filter][mipfilter];
        }
        else {
            throw "Sampler is out of bounds.";
        }
    };
    ContextWebGL.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        if (bufferOffset === void 0) { bufferOffset = 0; }
        if (format === void 0) { format = null; }
        var location = this._currentProgram ? this._gl.getAttribLocation(this._currentProgram.glProgram, "va" + index) : -1;
        if (!buffer) {
            if (location > -1)
                this._gl.disableVertexAttribArray(location);
            return;
        }
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer.glBuffer);
        this._gl.enableVertexAttribArray(location);
        this._gl.vertexAttribPointer(location, this._vertexBufferDimensionDictionary[format], this._gl.FLOAT, false, buffer.data32PerVertex * 4, bufferOffset * 4);
    };
    ContextWebGL.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (antiAlias === void 0) { antiAlias = 0; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        var texture = target;
        var frameBuffer = texture.frameBuffer;
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
        if (enableDepthAndStencil) {
            this._gl.enable(this._gl.STENCIL_TEST);
            this._gl.enable(this._gl.DEPTH_TEST);
        }
        this._gl.viewport(0, 0, texture.width, texture.height);
    };
    ContextWebGL.prototype.setRenderToBackBuffer = function () {
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
    };
    ContextWebGL.prototype.updateBlendStatus = function () {
        if (this._blendEnabled) {
            this._gl.enable(this._gl.BLEND);
            this._gl.blendEquation(this._gl.FUNC_ADD);
            this._gl.blendFunc(this._blendSourceFactor, this._blendDestinationFactor);
        }
        else {
            this._gl.disable(this._gl.BLEND);
        }
    };
    ContextWebGL.MAX_SAMPLERS = 8;
    ContextWebGL.modulo = 0;
    return ContextWebGL;
})(ContextGLBase);
module.exports = ContextWebGL;


},{"awayjs-core/lib/geom/Rectangle":450,"awayjs-core/lib/utils/ByteArray":459,"awayjs-stagegl/lib/base/ContextGLBase":351,"awayjs-stagegl/lib/base/ContextGLBlendFactor":352,"awayjs-stagegl/lib/base/ContextGLClearMask":353,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLProgramType":357,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLTriangleFace":360,"awayjs-stagegl/lib/base/ContextGLVertexBufferFormat":361,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/base/CubeTextureWebGL":366,"awayjs-stagegl/lib/base/IndexBufferWebGL":368,"awayjs-stagegl/lib/base/ProgramWebGL":371,"awayjs-stagegl/lib/base/SamplerState":373,"awayjs-stagegl/lib/base/TextureWebGL":377,"awayjs-stagegl/lib/base/VertexBufferWebGL":379}],365:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BitmapData = require("awayjs-core/lib/base/BitmapData");
var ByteArrayBase = require("awayjs-core/lib/utils/ByteArrayBase");
var OpCodes = require("awayjs-stagegl/lib/base/OpCodes");
var ResourceBaseFlash = require("awayjs-stagegl/lib/base/ResourceBaseFlash");
var CubeTextureFlash = (function (_super) {
    __extends(CubeTextureFlash, _super);
    function CubeTextureFlash(context, size, format, forRTT, streaming) {
        if (streaming === void 0) { streaming = false; }
        _super.call(this);
        this._context = context;
        this._size = size;
        this._context.addStream(String.fromCharCode(OpCodes.initCubeTexture, (forRTT ? OpCodes.trueValue : OpCodes.falseValue)) + size + "," + streaming + "," + format + "$");
        this._pId = this._context.execute();
        this._context._iAddResource(this);
    }
    Object.defineProperty(CubeTextureFlash.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    CubeTextureFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeCubeTexture) + this._pId.toString() + ",");
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    CubeTextureFlash.prototype.uploadFromData = function (data, side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        if (data instanceof BitmapData) {
            data = data.imageData.data;
        }
        else if (data instanceof HTMLImageElement) {
            var can = document.createElement("canvas");
            var w = data.width;
            var h = data.height;
            can.width = w;
            can.height = h;
            var ctx = can.getContext("2d");
            ctx.drawImage(data, 0, 0);
            data = ctx.getImageData(0, 0, w, h).data;
        }
        var pos = 0;
        var bytes = ByteArrayBase.internalGetBase64String(data.length, function () {
            return data[pos++];
        }, null);
        this._context.addStream(String.fromCharCode(OpCodes.uploadBytesCubeTexture) + this._pId + "," + miplevel + "," + side + "," + (this.size >> miplevel) + "," + bytes + "%");
        this._context.execute();
    };
    CubeTextureFlash.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
    };
    return CubeTextureFlash;
})(ResourceBaseFlash);
module.exports = CubeTextureFlash;


},{"awayjs-core/lib/base/BitmapData":437,"awayjs-core/lib/utils/ByteArrayBase":460,"awayjs-stagegl/lib/base/OpCodes":369,"awayjs-stagegl/lib/base/ResourceBaseFlash":372}],366:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BitmapData = require("awayjs-core/lib/base/BitmapData");
var TextureBaseWebGL = require("awayjs-stagegl/lib/base/TextureBaseWebGL");
var CubeTextureWebGL = (function (_super) {
    __extends(CubeTextureWebGL, _super);
    function CubeTextureWebGL(gl, size) {
        _super.call(this, gl);
        this._textureSelectorDictionary = new Array(6);
        this.textureType = "textureCube";
        this._size = size;
        this._texture = this._gl.createTexture();
        this._textureSelectorDictionary[0] = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        this._textureSelectorDictionary[1] = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
        this._textureSelectorDictionary[2] = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
        this._textureSelectorDictionary[3] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
        this._textureSelectorDictionary[4] = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
        this._textureSelectorDictionary[5] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
    }
    CubeTextureWebGL.prototype.dispose = function () {
        this._gl.deleteTexture(this._texture);
    };
    CubeTextureWebGL.prototype.uploadFromData = function (data, side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        if (data instanceof BitmapData)
            data = data.imageData;
        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._texture);
        this._gl.texImage2D(this._textureSelectorDictionary[side], miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
    };
    CubeTextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
    };
    Object.defineProperty(CubeTextureWebGL.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CubeTextureWebGL.prototype, "glTexture", {
        get: function () {
            return this._texture;
        },
        enumerable: true,
        configurable: true
    });
    return CubeTextureWebGL;
})(TextureBaseWebGL);
module.exports = CubeTextureWebGL;


},{"awayjs-core/lib/base/BitmapData":437,"awayjs-stagegl/lib/base/TextureBaseWebGL":375}],367:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var OpCodes = require("awayjs-stagegl/lib/base/OpCodes");
var ResourceBaseFlash = require("awayjs-stagegl/lib/base/ResourceBaseFlash");
var IndexBufferFlash = (function (_super) {
    __extends(IndexBufferFlash, _super);
    function IndexBufferFlash(context, numIndices) {
        _super.call(this);
        this._context = context;
        this._numIndices = numIndices;
        this._context.addStream(String.fromCharCode(OpCodes.initIndexBuffer, numIndices + OpCodes.intMask));
        this._pId = this._context.execute();
        this._context._iAddResource(this);
    }
    IndexBufferFlash.prototype.uploadFromArray = function (data, startOffset, count) {
        this._context.addStream(String.fromCharCode(OpCodes.uploadArrayIndexBuffer, this._pId + OpCodes.intMask) + data.join() + "#" + startOffset + "," + count + ",");
        this._context.execute();
    };
    IndexBufferFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeIndexBuffer, this._pId + OpCodes.intMask));
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    Object.defineProperty(IndexBufferFlash.prototype, "numIndices", {
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    return IndexBufferFlash;
})(ResourceBaseFlash);
module.exports = IndexBufferFlash;


},{"awayjs-stagegl/lib/base/OpCodes":369,"awayjs-stagegl/lib/base/ResourceBaseFlash":372}],368:[function(require,module,exports){
var IndexBufferWebGL = (function () {
    function IndexBufferWebGL(gl, numIndices) {
        this._gl = gl;
        this._buffer = this._gl.createBuffer();
        this._numIndices = numIndices;
    }
    IndexBufferWebGL.prototype.uploadFromArray = function (data, startOffset, count) {
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
        // TODO add index offsets
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
    };
    IndexBufferWebGL.prototype.dispose = function () {
        this._gl.deleteBuffer(this._buffer);
    };
    Object.defineProperty(IndexBufferWebGL.prototype, "numIndices", {
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexBufferWebGL.prototype, "glBuffer", {
        get: function () {
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    return IndexBufferWebGL;
})();
module.exports = IndexBufferWebGL;


},{}],369:[function(require,module,exports){
var OpCodes = (function () {
    function OpCodes() {
    }
    OpCodes.trueValue = 32;
    OpCodes.falseValue = 33;
    OpCodes.intMask = 63;
    OpCodes.drawTriangles = 41;
    OpCodes.setProgramConstant = 42;
    OpCodes.setProgram = 43;
    OpCodes.present = 44;
    OpCodes.clear = 45;
    OpCodes.initProgram = 46;
    OpCodes.initVertexBuffer = 47;
    OpCodes.initIndexBuffer = 48;
    OpCodes.configureBackBuffer = 49;
    OpCodes.uploadArrayIndexBuffer = 50;
    OpCodes.uploadArrayVertexBuffer = 51;
    OpCodes.uploadAGALBytesProgram = 52;
    OpCodes.setVertexBufferAt = 53;
    OpCodes.uploadBytesIndexBuffer = 54;
    OpCodes.uploadBytesVertexBuffer = 55;
    OpCodes.setColorMask = 56;
    OpCodes.setDepthTest = 57;
    OpCodes.disposeProgram = 58;
    OpCodes.disposeContext = 59;
    // must skip 60 '<' as it will invalidate xml being passed over the bridge
    OpCodes.disposeVertexBuffer = 61;
    // must skip 62 '>' as it will invalidate xml being passed over the bridge
    OpCodes.disposeIndexBuffer = 63;
    OpCodes.initTexture = 64;
    OpCodes.setTextureAt = 65;
    OpCodes.uploadBytesTexture = 66;
    OpCodes.disposeTexture = 67;
    OpCodes.setCulling = 68;
    OpCodes.setScissorRect = 69;
    OpCodes.clearScissorRect = 70;
    OpCodes.setBlendFactors = 71;
    OpCodes.setRenderToTexture = 72;
    OpCodes.clearTextureAt = 73;
    OpCodes.clearVertexBufferAt = 74;
    OpCodes.setStencilActions = 75;
    OpCodes.setStencilReferenceValue = 76;
    OpCodes.initCubeTexture = 77;
    OpCodes.disposeCubeTexture = 78;
    OpCodes.uploadBytesCubeTexture = 79;
    OpCodes.clearRenderToTexture = 80;
    OpCodes.enableErrorChecking = 81;
    return OpCodes;
})();
module.exports = OpCodes;


},{}],370:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextStage3D = require("awayjs-stagegl/lib/base/ContextStage3D");
var OpCodes = require("awayjs-stagegl/lib/base/OpCodes");
var ResourceBaseFlash = require("awayjs-stagegl/lib/base/ResourceBaseFlash");
var ProgramFlash = (function (_super) {
    __extends(ProgramFlash, _super);
    function ProgramFlash(context) {
        _super.call(this);
        this._context = context;
        this._context.addStream(String.fromCharCode(OpCodes.initProgram));
        this._pId = this._context.execute();
        this._context._iAddResource(this);
    }
    ProgramFlash.prototype.upload = function (vertexProgram, fragmentProgram) {
        this._context.addStream(String.fromCharCode(OpCodes.uploadAGALBytesProgram, this._pId + OpCodes.intMask) + vertexProgram.readBase64String(vertexProgram.length) + "%" + fragmentProgram.readBase64String(fragmentProgram.length) + "%");
        if (ContextStage3D.debug)
            this._context.execute();
    };
    ProgramFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeProgram, this._pId + OpCodes.intMask));
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    return ProgramFlash;
})(ResourceBaseFlash);
module.exports = ProgramFlash;


},{"awayjs-stagegl/lib/base/ContextStage3D":363,"awayjs-stagegl/lib/base/OpCodes":369,"awayjs-stagegl/lib/base/ResourceBaseFlash":372}],371:[function(require,module,exports){
var AGALTokenizer = require("awayjs-stagegl/lib/aglsl/AGALTokenizer");
var AGLSLParser = require("awayjs-stagegl/lib/aglsl/AGLSLParser");
var ProgramWebGL = (function () {
    function ProgramWebGL(gl) {
        this._gl = gl;
        this._program = this._gl.createProgram();
    }
    ProgramWebGL.prototype.upload = function (vertexProgram, fragmentProgram) {
        var vertexString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(vertexProgram));
        var fragmentString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(fragmentProgram));
        this._vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
        this._fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
        this._gl.shaderSource(this._vertexShader, vertexString);
        this._gl.compileShader(this._vertexShader);
        if (!this._gl.getShaderParameter(this._vertexShader, this._gl.COMPILE_STATUS)) {
            throw new Error(this._gl.getShaderInfoLog(this._vertexShader));
            return;
        }
        this._gl.shaderSource(this._fragmentShader, fragmentString);
        this._gl.compileShader(this._fragmentShader);
        if (!this._gl.getShaderParameter(this._fragmentShader, this._gl.COMPILE_STATUS)) {
            throw new Error(this._gl.getShaderInfoLog(this._fragmentShader));
            return;
        }
        this._gl.attachShader(this._program, this._vertexShader);
        this._gl.attachShader(this._program, this._fragmentShader);
        this._gl.linkProgram(this._program);
        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
            throw new Error(this._gl.getProgramInfoLog(this._program));
        }
    };
    ProgramWebGL.prototype.dispose = function () {
        this._gl.deleteProgram(this._program);
    };
    ProgramWebGL.prototype.focusProgram = function () {
        this._gl.useProgram(this._program);
    };
    Object.defineProperty(ProgramWebGL.prototype, "glProgram", {
        get: function () {
            return this._program;
        },
        enumerable: true,
        configurable: true
    });
    ProgramWebGL._tokenizer = new AGALTokenizer();
    ProgramWebGL._aglslParser = new AGLSLParser();
    return ProgramWebGL;
})();
module.exports = ProgramWebGL;


},{"awayjs-stagegl/lib/aglsl/AGALTokenizer":333,"awayjs-stagegl/lib/aglsl/AGLSLParser":334}],372:[function(require,module,exports){
var ResourceBaseFlash = (function () {
    function ResourceBaseFlash() {
    }
    Object.defineProperty(ResourceBaseFlash.prototype, "id", {
        get: function () {
            return this._pId;
        },
        enumerable: true,
        configurable: true
    });
    ResourceBaseFlash.prototype.dispose = function () {
    };
    return ResourceBaseFlash;
})();
module.exports = ResourceBaseFlash;


},{}],373:[function(require,module,exports){
var SamplerState = (function () {
    function SamplerState() {
    }
    return SamplerState;
})();
module.exports = SamplerState;


},{}],374:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
var Event = require("awayjs-core/lib/events/Event");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var CSS = require("awayjs-core/lib/utils/CSS");
var ContextMode = require("awayjs-display/lib/display/ContextMode");
var StageEvent = require("awayjs-display/lib/events/StageEvent");
var ContextStage3D = require("awayjs-stagegl/lib/base/ContextStage3D");
var ContextWebGL = require("awayjs-stagegl/lib/base/ContextWebGL");
/**
 * Stage provides a proxy class to handle the creation and attachment of the Context
 * (and in turn the back buffer) it uses. Stage should never be created directly,
 * but requested through StageManager.
 *
 * @see away.managers.StageManager
 *
 */
var Stage = (function (_super) {
    __extends(Stage, _super);
    function Stage(container, stageIndex, stageManager, forceSoftware, profile) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = "baseline"; }
        _super.call(this);
        this._x = 0;
        this._y = 0;
        //private static _frameEventDriver:Shape = new Shape(); // TODO: add frame driver / request animation frame
        this._stageIndex = -1;
        this._antiAlias = 0;
        //private var _activeVertexBuffers : Vector.<VertexBuffer> = new Vector.<VertexBuffer>(8, true);
        //private var _activeTextures : Vector.<TextureBase> = new Vector.<TextureBase>(8, true);
        this._renderTarget = null;
        this._renderSurfaceSelector = 0;
        //private _mouse3DManager:away.managers.Mouse3DManager;
        //private _touch3DManager:Touch3DManager; //TODO: imeplement dependency Touch3DManager
        this._initialised = false;
        this._container = container;
        this._stageIndex = stageIndex;
        this._stageManager = stageManager;
        this._viewPort = new Rectangle();
        this._enableDepthAndStencil = true;
        CSS.setElementX(this._container, 0);
        CSS.setElementY(this._container, 0);
        this.visible = true;
    }
    /**
     * Requests a Context object to attach to the managed gl canvas.
     */
    Stage.prototype.requestContext = function (forceSoftware, profile, mode) {
        // If forcing software, we can be certain that the
        // returned Context will be running software mode.
        // If not, we can't be sure and should stick to the
        // old value (will likely be same if re-requesting.)
        var _this = this;
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = "baseline"; }
        if (mode === void 0) { mode = "auto"; }
        if (this._usesSoftwareRendering != null)
            this._usesSoftwareRendering = forceSoftware;
        this._profile = profile;
        try {
            if (mode == ContextMode.FLASH)
                new ContextStage3D(this._container, this._stageIndex, function (context) { return _this._callback(context); });
            else
                this._context = new ContextWebGL(this._container, this._stageIndex);
        }
        catch (e) {
            try {
                if (mode == ContextMode.AUTO)
                    new ContextStage3D(this._container, this._stageIndex, function (context) { return _this._callback(context); });
                else
                    this.dispatchEvent(new Event(Event.ERROR));
            }
            catch (e) {
                this.dispatchEvent(new Event(Event.ERROR));
            }
        }
        if (this._context)
            this._callback(this._context);
    };
    Object.defineProperty(Stage.prototype, "width", {
        /**
         * The width of the gl canvas
         */
        get: function () {
            return this._width;
        },
        set: function (val) {
            if (this._width == val)
                return;
            CSS.setElementWidth(this._container, val);
            this._width = this._viewPort.width = val;
            this._backBufferDirty = true;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "height", {
        /**
         * The height of the gl canvas
         */
        get: function () {
            return this._height;
        },
        set: function (val) {
            if (this._height == val)
                return;
            CSS.setElementHeight(this._container, val);
            this._height = this._viewPort.height = val;
            this._backBufferDirty = true;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "x", {
        /**
         * The x position of the gl canvas
         */
        get: function () {
            return this._x;
        },
        set: function (val) {
            if (this._x == val)
                return;
            CSS.setElementX(this._container, val);
            this._x = this._viewPort.x = val;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "y", {
        /**
         * The y position of the gl canvas
         */
        get: function () {
            return this._y;
        },
        set: function (val) {
            if (this._y == val)
                return;
            CSS.setElementY(this._container, val);
            this._y = this._viewPort.y = val;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "visible", {
        get: function () {
            return CSS.getElementVisibility(this._container);
        },
        set: function (val) {
            CSS.setElementVisibility(this._container, val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "container", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "context", {
        /**
         * The Context object associated with the given stage object.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Stage.prototype.notifyViewportUpdated = function () {
        if (this._viewportDirty)
            return;
        this._viewportDirty = true;
        //if (!this.hasEventListener(StageEvent.VIEWPORT_UPDATED))
        //return;
        //if (!_viewportUpdated)
        this._viewportUpdated = new StageEvent(StageEvent.VIEWPORT_UPDATED);
        this.dispatchEvent(this._viewportUpdated);
    };
    Stage.prototype.notifyEnterFrame = function () {
        //if (!hasEventListener(Event.ENTER_FRAME))
        //return;
        if (!this._enterFrame)
            this._enterFrame = new Event(Event.ENTER_FRAME);
        this.dispatchEvent(this._enterFrame);
    };
    Stage.prototype.notifyExitFrame = function () {
        //if (!hasEventListener(Event.EXIT_FRAME))
        //return;
        if (!this._exitFrame)
            this._exitFrame = new Event(Event.EXIT_FRAME);
        this.dispatchEvent(this._exitFrame);
    };
    Object.defineProperty(Stage.prototype, "profile", {
        get: function () {
            return this._profile;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the Stage object, freeing the Context attached to the Stage.
     */
    Stage.prototype.dispose = function () {
        this._stageManager.iRemoveStage(this);
        this.freeContext();
        this._stageManager = null;
        this._stageIndex = -1;
    };
    /**
     * Configures the back buffer associated with the Stage object.
     * @param backBufferWidth The width of the backbuffer.
     * @param backBufferHeight The height of the backbuffer.
     * @param antiAlias The amount of anti-aliasing to use.
     * @param enableDepthAndStencil Indicates whether the back buffer contains a depth and stencil buffer.
     */
    Stage.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil) {
        this.width = backBufferWidth;
        this.height = backBufferHeight;
        this._antiAlias = antiAlias;
        this._enableDepthAndStencil = enableDepthAndStencil;
        if (this._context)
            this._context.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil);
    };
    Object.defineProperty(Stage.prototype, "enableDepthAndStencil", {
        /*
         * Indicates whether the depth and stencil buffer is used
         */
        get: function () {
            return this._enableDepthAndStencil;
        },
        set: function (enableDepthAndStencil) {
            this._enableDepthAndStencil = enableDepthAndStencil;
            this._backBufferDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "renderTarget", {
        get: function () {
            return this._renderTarget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "renderSurfaceSelector", {
        get: function () {
            return this._renderSurfaceSelector;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Clear and reset the back buffer when using a shared context
     */
    Stage.prototype.clear = function () {
        if (!this._context)
            return;
        if (this._backBufferDirty) {
            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
            this._backBufferDirty = false;
        }
        this._context.clear((this._color & 0xff000000) >>> 24, (this._color & 0xff0000) >>> 16, (this._color & 0xff00) >>> 8, this._color & 0xff);
        this._bufferClear = true;
    };
    /**
     * Registers an event listener object with an EventDispatcher object so that the listener receives notification of an event. Special case for enterframe and exitframe events - will switch StageProxy into automatic render mode.
     * You can register event listeners on all nodes in the display list for a specific type of event, phase, and priority.
     *
     * @param type The type of event.
     * @param listener The listener function that processes the event.
     * @param useCapture Determines whether the listener works in the capture phase or the target and bubbling phases. If useCapture is set to true, the listener processes the event only during the capture phase and not in the target or bubbling phase. If useCapture is false, the listener processes the event only during the target or bubbling phase. To listen for the event in all three phases, call addEventListener twice, once with useCapture set to true, then again with useCapture set to false.
     * @param priority The priority level of the event listener. The priority is designated by a signed 32-bit integer. The higher the number, the higher the priority. All listeners with priority n are processed before listeners of priority n-1. If two or more listeners share the same priority, they are processed in the order in which they were added. The default priority is 0.
     * @param useWeakReference Determines whether the reference to the listener is strong or weak. A strong reference (the default) prevents your listener from being garbage-collected. A weak reference does not.
     */
    Stage.prototype.addEventListener = function (type, listener) {
        _super.prototype.addEventListener.call(this, type, listener);
        //away.Debug.throwPIR( 'StageProxy' , 'addEventListener' ,  'EnterFrame, ExitFrame');
        //if ((type == Event.ENTER_FRAME || type == Event.EXIT_FRAME) ){//&& ! this._frameEventDriver.hasEventListener(Event.ENTER_FRAME)){
        //_frameEventDriver.addEventListener(Event.ENTER_FRAME, onEnterFrame, useCapture, priority, useWeakReference);
        //}
        /* Original code
         if ((type == Event.ENTER_FRAME || type == Event.EXIT_FRAME) && ! _frameEventDriver.hasEventListener(Event.ENTER_FRAME)){

         _frameEventDriver.addEventListener(Event.ENTER_FRAME, onEnterFrame, useCapture, priority, useWeakReference);


         }
         */
    };
    /**
     * Removes a listener from the EventDispatcher object. Special case for enterframe and exitframe events - will switch StageProxy out of automatic render mode.
     * If there is no matching listener registered with the EventDispatcher object, a call to this method has no effect.
     *
     * @param type The type of event.
     * @param listener The listener object to remove.
     * @param useCapture Specifies whether the listener was registered for the capture phase or the target and bubbling phases. If the listener was registered for both the capture phase and the target and bubbling phases, two calls to removeEventListener() are required to remove both, one call with useCapture() set to true, and another call with useCapture() set to false.
     */
    Stage.prototype.removeEventListener = function (type, listener) {
        _super.prototype.removeEventListener.call(this, type, listener);
        /*
         // Remove the main rendering listener if no EnterFrame listeners remain
         if (    ! this.hasEventListener(Event.ENTER_FRAME , this.onEnterFrame , this )
         &&  ! this.hasEventListener(Event.EXIT_FRAME , this.onEnterFrame , this) ) //&& _frameEventDriver.hasEventListener(Event.ENTER_FRAME))
         {

         //_frameEventDriver.removeEventListener(Event.ENTER_FRAME, this.onEnterFrame, this );

         }
         */
    };
    Object.defineProperty(Stage.prototype, "scissorRect", {
        get: function () {
            return this._scissorRect;
        },
        set: function (value) {
            this._scissorRect = value;
            this._context.setScissorRectangle(this._scissorRect);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "stageIndex", {
        /**
         * The index of the Stage which is managed by this instance of StageProxy.
         */
        get: function () {
            return this._stageIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "usesSoftwareRendering", {
        /**
         * Indicates whether the Stage managed by this proxy is running in software mode.
         * Remember to wait for the CONTEXT_CREATED event before checking this property,
         * as only then will it be guaranteed to be accurate.
         */
        get: function () {
            return this._usesSoftwareRendering;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "antiAlias", {
        /**
         * The antiAliasing of the Stage.
         */
        get: function () {
            return this._antiAlias;
        },
        set: function (antiAlias) {
            this._antiAlias = antiAlias;
            this._backBufferDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "viewPort", {
        /**
         * A viewPort rectangle equivalent of the Stage size and position.
         */
        get: function () {
            this._viewportDirty = false;
            return this._viewPort;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "color", {
        /**
         * The background color of the Stage.
         */
        get: function () {
            return this._color;
        },
        set: function (color) {
            this._color = color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "bufferClear", {
        /**
         * The freshly cleared state of the backbuffer before any rendering
         */
        get: function () {
            return this._bufferClear;
        },
        set: function (newBufferClear) {
            this._bufferClear = newBufferClear;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Access to fire mouseevents across multiple layered view3D instances
     */
    //		public get mouse3DManager():Mouse3DManager
    //		{
    //			return this._mouse3DManager;
    //		}
    //
    //		public set mouse3DManager(value:Mouse3DManager)
    //		{
    //			this._mouse3DManager = value;
    //		}
    /* TODO: implement dependency Touch3DManager
     public get touch3DManager():Touch3DManager
     {
     return _touch3DManager;
     }

     public set touch3DManager(value:Touch3DManager)
     {
     _touch3DManager = value;
     }
     */
    /**
     * Frees the Context associated with this StageProxy.
     */
    Stage.prototype.freeContext = function () {
        if (this._context) {
            this._context.dispose();
            this.dispatchEvent(new StageEvent(StageEvent.CONTEXT_DISPOSED));
        }
        this._context = null;
        this._initialised = false;
    };
    /**
     * The Enter_Frame handler for processing the proxy.ENTER_FRAME and proxy.EXIT_FRAME event handlers.
     * Typically the proxy.ENTER_FRAME listener would render the layers for this Stage instance.
     */
    Stage.prototype.onEnterFrame = function (event) {
        if (!this._context)
            return;
        // Clear the stage instance
        this.clear();
        //notify the enterframe listeners
        this.notifyEnterFrame();
        // Call the present() to render the frame
        if (!this._context)
            this._context.present();
        //notify the exitframe listeners
        this.notifyExitFrame();
    };
    Stage.prototype.recoverFromDisposal = function () {
        if (!this._context)
            return false;
        //away.Debug.throwPIR( 'StageProxy' , 'recoverFromDisposal' , '' );
        /*
         if (this._iContext.driverInfo == "Disposed")
         {
         this._iContext = null;
         this.dispatchEvent(new StageEvent(StageEvent.CONTEXT_DISPOSED));
         return false;

         }
         */
        return true;
    };
    Stage.prototype._callback = function (context) {
        this._context = context;
        this._container = this._context.container;
        // Only configure back buffer if width and height have been set,
        // which they may not have been if View.render() has yet to be
        // invoked for the first time.
        if (this._width && this._height)
            this._context.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
        // Dispatch the appropriate event depending on whether context was
        // created for the first time or recreated after a device loss.
        this.dispatchEvent(new StageEvent(this._initialised ? StageEvent.CONTEXT_RECREATED : StageEvent.CONTEXT_CREATED));
        this._initialised = true;
    };
    return Stage;
})(EventDispatcher);
module.exports = Stage;


},{"awayjs-core/lib/events/Event":442,"awayjs-core/lib/events/EventDispatcher":443,"awayjs-core/lib/geom/Rectangle":450,"awayjs-core/lib/utils/CSS":461,"awayjs-display/lib/display/ContextMode":477,"awayjs-display/lib/events/StageEvent":488,"awayjs-stagegl/lib/base/ContextStage3D":363,"awayjs-stagegl/lib/base/ContextWebGL":364}],375:[function(require,module,exports){
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var TextureBaseWebGL = (function () {
    function TextureBaseWebGL(gl) {
        this.textureType = "";
        this._gl = gl;
    }
    TextureBaseWebGL.prototype.dispose = function () {
        throw "Abstract method must be overridden.";
    };
    Object.defineProperty(TextureBaseWebGL.prototype, "glTexture", {
        get: function () {
            throw new AbstractMethodError();
        },
        enumerable: true,
        configurable: true
    });
    return TextureBaseWebGL;
})();
module.exports = TextureBaseWebGL;


},{"awayjs-core/lib/errors/AbstractMethodError":438}],376:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BitmapData = require("awayjs-core/lib/base/BitmapData");
var ByteArrayBase = require("awayjs-core/lib/utils/ByteArrayBase");
var OpCodes = require("awayjs-stagegl/lib/base/OpCodes");
var ResourceBaseFlash = require("awayjs-stagegl/lib/base/ResourceBaseFlash");
var TextureFlash = (function (_super) {
    __extends(TextureFlash, _super);
    function TextureFlash(context, width, height, format, forRTT, streaming) {
        if (streaming === void 0) { streaming = false; }
        _super.call(this);
        this._context = context;
        this._width = width;
        this._height = height;
        this._context.addStream(String.fromCharCode(OpCodes.initTexture, (forRTT ? OpCodes.trueValue : OpCodes.falseValue)) + width + "," + height + "," + streaming + "," + format + "$");
        this._pId = this._context.execute();
        this._context._iAddResource(this);
    }
    Object.defineProperty(TextureFlash.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureFlash.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    TextureFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeTexture) + this._pId.toString() + ",");
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    TextureFlash.prototype.uploadFromData = function (data, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        if (data instanceof BitmapData) {
            data = data.imageData.data;
        }
        else if (data instanceof HTMLImageElement) {
            var can = document.createElement("canvas");
            var w = data.width;
            var h = data.height;
            can.width = w;
            can.height = h;
            var ctx = can.getContext("2d");
            ctx.drawImage(data, 0, 0);
            data = ctx.getImageData(0, 0, w, h).data;
        }
        var pos = 0;
        var bytes = ByteArrayBase.internalGetBase64String(data.length, function () {
            return data[pos++];
        }, null);
        this._context.addStream(String.fromCharCode(OpCodes.uploadBytesTexture) + this._pId + "," + miplevel + "," + (this._width >> miplevel) + "," + (this._height >> miplevel) + "," + bytes + "%");
        this._context.execute();
    };
    return TextureFlash;
})(ResourceBaseFlash);
module.exports = TextureFlash;


},{"awayjs-core/lib/base/BitmapData":437,"awayjs-core/lib/utils/ByteArrayBase":460,"awayjs-stagegl/lib/base/OpCodes":369,"awayjs-stagegl/lib/base/ResourceBaseFlash":372}],377:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var BitmapData = require("awayjs-core/lib/base/BitmapData");
var TextureBaseWebGL = require("awayjs-stagegl/lib/base/TextureBaseWebGL");
var TextureWebGL = (function (_super) {
    __extends(TextureWebGL, _super);
    function TextureWebGL(gl, width, height) {
        _super.call(this, gl);
        this.textureType = "texture2d";
        this._width = width;
        this._height = height;
        this._glTexture = this._gl.createTexture();
    }
    TextureWebGL.prototype.dispose = function () {
        this._gl.deleteTexture(this._glTexture);
    };
    Object.defineProperty(TextureWebGL.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureWebGL.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureWebGL.prototype, "frameBuffer", {
        get: function () {
            if (!this._frameBuffer) {
                this._frameBuffer = this._gl.createFramebuffer();
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
                var renderBuffer = this._gl.createRenderbuffer();
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT16, this._width, this._height);
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            }
            return this._frameBuffer;
        },
        enumerable: true,
        configurable: true
    });
    TextureWebGL.prototype.uploadFromData = function (data, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        if (data instanceof BitmapData)
            data = data.imageData;
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
        this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
        this._gl.bindTexture(this._gl.TEXTURE_2D, null);
    };
    TextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
        var ext = this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        //this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this)
    };
    Object.defineProperty(TextureWebGL.prototype, "glTexture", {
        get: function () {
            return this._glTexture;
        },
        enumerable: true,
        configurable: true
    });
    TextureWebGL.prototype.generateMipmaps = function () {
        //TODO: implement generating mipmaps
        //this._gl.bindTexture( this._gl.TEXTURE_2D, this._glTexture );
        //this._gl.generateMipmap(this._gl.TEXTURE_2D);
        //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
    };
    return TextureWebGL;
})(TextureBaseWebGL);
module.exports = TextureWebGL;


},{"awayjs-core/lib/base/BitmapData":437,"awayjs-stagegl/lib/base/TextureBaseWebGL":375}],378:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var OpCodes = require("awayjs-stagegl/lib/base/OpCodes");
var ResourceBaseFlash = require("awayjs-stagegl/lib/base/ResourceBaseFlash");
var VertexBufferFlash = (function (_super) {
    __extends(VertexBufferFlash, _super);
    function VertexBufferFlash(context, numVertices, data32PerVertex) {
        _super.call(this);
        this._context = context;
        this._numVertices = numVertices;
        this._data32PerVertex = data32PerVertex;
        this._context.addStream(String.fromCharCode(OpCodes.initVertexBuffer, data32PerVertex + OpCodes.intMask) + numVertices.toString() + ",");
        this._pId = this._context.execute();
        this._context._iAddResource(this);
    }
    VertexBufferFlash.prototype.uploadFromArray = function (data, startVertex, numVertices) {
        this._context.addStream(String.fromCharCode(OpCodes.uploadArrayVertexBuffer, this._pId + OpCodes.intMask) + data.join() + "#" + [startVertex, numVertices].join() + ",");
        this._context.execute();
    };
    Object.defineProperty(VertexBufferFlash.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferFlash.prototype, "data32PerVertex", {
        get: function () {
            return this._data32PerVertex;
        },
        enumerable: true,
        configurable: true
    });
    VertexBufferFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeVertexBuffer, this._pId + OpCodes.intMask));
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    return VertexBufferFlash;
})(ResourceBaseFlash);
module.exports = VertexBufferFlash;


},{"awayjs-stagegl/lib/base/OpCodes":369,"awayjs-stagegl/lib/base/ResourceBaseFlash":372}],379:[function(require,module,exports){
var VertexBufferWebGL = (function () {
    function VertexBufferWebGL(gl, numVertices, data32PerVertex) {
        this._gl = gl;
        this._buffer = this._gl.createBuffer();
        this._numVertices = numVertices;
        this._data32PerVertex = data32PerVertex;
    }
    VertexBufferWebGL.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
        //console.log( "** WARNING upload not fully implemented, startVertex & numVertices not considered." );
        // TODO add offsets , startVertex, numVertices * this._data32PerVertex
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
    };
    Object.defineProperty(VertexBufferWebGL.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferWebGL.prototype, "data32PerVertex", {
        get: function () {
            return this._data32PerVertex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferWebGL.prototype, "glBuffer", {
        get: function () {
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    VertexBufferWebGL.prototype.dispose = function () {
        this._gl.deleteBuffer(this._buffer);
    };
    return VertexBufferWebGL;
})();
module.exports = VertexBufferWebGL;


},{}],380:[function(require,module,exports){
module.exports=require(201)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/events/ShadingMethodEvent.js":201,"awayjs-core/lib/events/Event":442}],381:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
var Event = require("awayjs-core/lib/events/Event");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var TextureUtils = require("awayjs-core/lib/utils/TextureUtils");
var RTTBufferManager = (function (_super) {
    __extends(RTTBufferManager, _super);
    function RTTBufferManager(stage) {
        _super.call(this);
        this._viewWidth = -1;
        this._viewHeight = -1;
        this._textureWidth = -1;
        this._textureHeight = -1;
        this._buffersInvalid = true;
        this._renderToTextureRect = new Rectangle();
        this._stage = stage;
    }
    RTTBufferManager.getInstance = function (stage) {
        if (!stage)
            throw new Error("stage key cannot be null!");
        if (RTTBufferManager._instances == null)
            RTTBufferManager._instances = new Array();
        var rttBufferManager = RTTBufferManager.getRTTBufferManagerFromStage(stage);
        if (rttBufferManager == null) {
            rttBufferManager = new RTTBufferManager(stage);
            var vo = new RTTBufferManagerVO();
            vo.stage3d = stage;
            vo.rttbfm = rttBufferManager;
            RTTBufferManager._instances.push(vo);
        }
        return rttBufferManager;
    };
    RTTBufferManager.getRTTBufferManagerFromStage = function (stage) {
        var l = RTTBufferManager._instances.length;
        var r;
        for (var c = 0; c < l; c++) {
            r = RTTBufferManager._instances[c];
            if (r.stage3d === stage)
                return r.rttbfm;
        }
        return null;
    };
    RTTBufferManager.deleteRTTBufferManager = function (stage) {
        var l = RTTBufferManager._instances.length;
        var r;
        for (var c = 0; c < l; c++) {
            r = RTTBufferManager._instances[c];
            if (r.stage3d === stage) {
                RTTBufferManager._instances.splice(c, 1);
                return;
            }
        }
    };
    Object.defineProperty(RTTBufferManager.prototype, "textureRatioX", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._textureRatioX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "textureRatioY", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._textureRatioY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "viewWidth", {
        get: function () {
            return this._viewWidth;
        },
        set: function (value) {
            if (value == this._viewWidth)
                return;
            this._viewWidth = value;
            this._buffersInvalid = true;
            this._textureWidth = TextureUtils.getBestPowerOf2(this._viewWidth);
            if (this._textureWidth > this._viewWidth) {
                this._renderToTextureRect.x = Math.floor((this._textureWidth - this._viewWidth) * .5);
                this._renderToTextureRect.width = this._viewWidth;
            }
            else {
                this._renderToTextureRect.x = 0;
                this._renderToTextureRect.width = this._textureWidth;
            }
            this.dispatchEvent(new Event(Event.RESIZE));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "viewHeight", {
        get: function () {
            return this._viewHeight;
        },
        set: function (value) {
            if (value == this._viewHeight)
                return;
            this._viewHeight = value;
            this._buffersInvalid = true;
            this._textureHeight = TextureUtils.getBestPowerOf2(this._viewHeight);
            if (this._textureHeight > this._viewHeight) {
                this._renderToTextureRect.y = Math.floor((this._textureHeight - this._viewHeight) * .5);
                this._renderToTextureRect.height = this._viewHeight;
            }
            else {
                this._renderToTextureRect.y = 0;
                this._renderToTextureRect.height = this._textureHeight;
            }
            this.dispatchEvent(new Event(Event.RESIZE));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureVertexBuffer", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._renderToTextureVertexBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "renderToScreenVertexBuffer", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._renderToScreenVertexBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "indexBuffer", {
        get: function () {
            return this._indexBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureRect", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._renderToTextureRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "textureWidth", {
        get: function () {
            return this._textureWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "textureHeight", {
        get: function () {
            return this._textureHeight;
        },
        enumerable: true,
        configurable: true
    });
    RTTBufferManager.prototype.dispose = function () {
        RTTBufferManager.deleteRTTBufferManager(this._stage);
        if (this._indexBuffer) {
            this._indexBuffer.dispose();
            this._renderToScreenVertexBuffer.dispose();
            this._renderToTextureVertexBuffer.dispose();
            this._renderToScreenVertexBuffer = null;
            this._renderToTextureVertexBuffer = null;
            this._indexBuffer = null;
        }
    };
    // todo: place all this in a separate model, since it's used all over the place
    // maybe it even has a place in the core (together with screenRect etc)?
    // needs to be stored per view of course
    RTTBufferManager.prototype.updateRTTBuffers = function () {
        var context = this._stage.context;
        var textureVerts;
        var screenVerts;
        var x;
        var y;
        if (this._renderToTextureVertexBuffer == null)
            this._renderToTextureVertexBuffer = context.createVertexBuffer(4, 5);
        if (this._renderToScreenVertexBuffer == null)
            this._renderToScreenVertexBuffer = context.createVertexBuffer(4, 5);
        if (!this._indexBuffer) {
            this._indexBuffer = context.createIndexBuffer(6);
            this._indexBuffer.uploadFromArray([2, 1, 0, 3, 2, 0], 0, 6);
        }
        this._textureRatioX = x = Math.min(this._viewWidth / this._textureWidth, 1);
        this._textureRatioY = y = Math.min(this._viewHeight / this._textureHeight, 1);
        var u1 = (1 - x) * .5;
        var u2 = (x + 1) * .5;
        var v1 = (y + 1) * .5;
        var v2 = (1 - y) * .5;
        // last element contains indices for data per vertex that can be passed to the vertex shader if necessary (ie: frustum corners for deferred rendering)
        textureVerts = [-x, -y, u1, v1, 0, x, -y, u2, v1, 1, x, y, u2, v2, 2, -x, y, u1, v2, 3];
        screenVerts = [-1, -1, u1, v1, 0, 1, -1, u2, v1, 1, 1, 1, u2, v2, 2, -1, 1, u1, v2, 3];
        this._renderToTextureVertexBuffer.uploadFromArray(textureVerts, 0, 4);
        this._renderToScreenVertexBuffer.uploadFromArray(screenVerts, 0, 4);
        this._buffersInvalid = false;
    };
    return RTTBufferManager;
})(EventDispatcher);
var RTTBufferManagerVO = (function () {
    function RTTBufferManagerVO() {
    }
    return RTTBufferManagerVO;
})();
module.exports = RTTBufferManager;


},{"awayjs-core/lib/events/Event":442,"awayjs-core/lib/events/EventDispatcher":443,"awayjs-core/lib/geom/Rectangle":450,"awayjs-core/lib/utils/TextureUtils":463}],382:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var ArgumentError = require("awayjs-core/lib/errors/ArgumentError");
var StageEvent = require("awayjs-display/lib/events/StageEvent");
var Stage = require("awayjs-stagegl/lib/base/Stage");
/**
 * The StageManager class provides a multiton object that handles management for Stage objects.
 *
 * @see away.base.Stage
 */
var StageManager = (function (_super) {
    __extends(StageManager, _super);
    /**
     * Creates a new StageManager class.
     * @param stage The Stage object that contains the Stage objects to be managed.
     * @private
     */
    function StageManager() {
        var _this = this;
        _super.call(this);
        this._stages = new Array(StageManager.STAGE_MAX_QUANTITY);
        this._onContextCreatedDelegate = function (event) { return _this.onContextCreated(event); };
    }
    /**
     * Gets a StageManager instance for the given Stage object.
     * @param stage The Stage object that contains the Stage objects to be managed.
     * @return The StageManager instance for the given Stage object.
     */
    StageManager.getInstance = function () {
        if (this._instance == null)
            this._instance = new StageManager();
        return this._instance;
    };
    /**
     * Requests the Stage for the given index.
     *
     * @param index The index of the requested Stage.
     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
     * @param profile The compatibility profile, an enumeration of ContextProfile
     * @return The Stage for the given index.
     */
    StageManager.prototype.getStageAt = function (index, forceSoftware, profile, mode) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = "baseline"; }
        if (mode === void 0) { mode = "auto"; }
        if (index < 0 || index >= StageManager.STAGE_MAX_QUANTITY)
            throw new ArgumentError("Index is out of bounds [0.." + StageManager.STAGE_MAX_QUANTITY + "]");
        if (!this._stages[index]) {
            StageManager._numStages++;
            var canvas = document.createElement("canvas");
            canvas.id = "stage" + index;
            document.body.appendChild(canvas);
            var stage = this._stages[index] = new Stage(canvas, index, this, forceSoftware, profile);
            stage.addEventListener(StageEvent.CONTEXT_CREATED, this._onContextCreatedDelegate);
            stage.requestContext(forceSoftware, profile, mode);
        }
        return stage;
    };
    /**
     * Removes a Stage from the manager.
     * @param stage
     * @private
     */
    StageManager.prototype.iRemoveStage = function (stage) {
        StageManager._numStages--;
        stage.removeEventListener(StageEvent.CONTEXT_CREATED, this._onContextCreatedDelegate);
        this._stages[stage.stageIndex] = null;
    };
    /**
     * Get the next available stage. An error is thrown if there are no StageProxies available
     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
     * @param profile The compatibility profile, an enumeration of ContextProfile
     * @return The allocated stage
     */
    StageManager.prototype.getFreeStage = function (forceSoftware, profile, mode) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = "baseline"; }
        if (mode === void 0) { mode = "auto"; }
        var i = 0;
        var len = this._stages.length;
        while (i < len) {
            if (!this._stages[i])
                return this.getStageAt(i, forceSoftware, profile, mode);
            ++i;
        }
        return null;
    };
    Object.defineProperty(StageManager.prototype, "hasFreeStage", {
        /**
         * Checks if a new stage can be created and managed by the class.
         * @return true if there is one slot free for a new stage
         */
        get: function () {
            return StageManager._numStages < StageManager.STAGE_MAX_QUANTITY ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StageManager.prototype, "numSlotsFree", {
        /**
         * Returns the amount of stage objects that can be created and managed by the class
         * @return the amount of free slots
         */
        get: function () {
            return StageManager.STAGE_MAX_QUANTITY - StageManager._numStages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StageManager.prototype, "numSlotsUsed", {
        /**
         * Returns the amount of Stage objects currently managed by the class.
         * @return the amount of slots used
         */
        get: function () {
            return StageManager._numStages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StageManager.prototype, "numSlotsTotal", {
        /**
         * The maximum amount of Stage objects that can be managed by the class
         */
        get: function () {
            return this._stages.length;
        },
        enumerable: true,
        configurable: true
    });
    StageManager.prototype.onContextCreated = function (event) {
        //var stage:Stage = <Stage> e.target;
        //document.body.appendChild(stage.canvas)
    };
    StageManager.STAGE_MAX_QUANTITY = 8;
    StageManager._numStages = 0;
    return StageManager;
})(EventDispatcher);
module.exports = StageManager;


},{"awayjs-core/lib/errors/ArgumentError":439,"awayjs-core/lib/events/EventDispatcher":443,"awayjs-display/lib/events/StageEvent":488,"awayjs-stagegl/lib/base/Stage":374}],383:[function(require,module,exports){
module.exports=require(202)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/LineBasicMaterial.js":202,"awayjs-core/lib/geom/Matrix3D":446,"awayjs-display/lib/base/LineSubGeometry":468,"awayjs-stagegl/lib/base/ContextGLProgramType":357,"awayjs-stagegl/lib/materials/StageGLMaterialBase":384,"awayjs-stagegl/lib/materials/passes/LineBasicPass":408}],384:[function(require,module,exports){
module.exports=require(203)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/StageGLMaterialBase.js":203,"awayjs-display/lib/materials/MaterialBase":491}],385:[function(require,module,exports){
module.exports=require(204)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/TriangleBasicMaterial.js":204,"awayjs-core/lib/textures/Texture2DBase":457,"awayjs-display/lib/base/BlendMode":465,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/materials/TriangleMaterialBase":386,"awayjs-stagegl/lib/materials/passes/TriangleBasicPass":411}],386:[function(require,module,exports){
module.exports=require(205)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/TriangleMaterialBase.js":205,"awayjs-core/lib/geom/Matrix3DUtils":447,"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-stagegl/lib/base/ContextGLProgramType":357,"awayjs-stagegl/lib/materials/StageGLMaterialBase":384}],387:[function(require,module,exports){
module.exports=require(206)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/TriangleMaterialMode.js":206}],388:[function(require,module,exports){
module.exports=require(207)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/TriangleMethodMaterial.js":207,"awayjs-core/lib/geom/ColorTransform":444,"awayjs-core/lib/textures/Texture2DBase":457,"awayjs-display/lib/base/BlendMode":465,"awayjs-display/lib/materials/lightpickers/StaticLightPicker":493,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/materials/TriangleMaterialBase":386,"awayjs-stagegl/lib/materials/TriangleMaterialMode":387,"awayjs-stagegl/lib/materials/methods/AmbientBasicMethod":398,"awayjs-stagegl/lib/materials/methods/DiffuseBasicMethod":399,"awayjs-stagegl/lib/materials/methods/NormalBasicMethod":403,"awayjs-stagegl/lib/materials/methods/SpecularBasicMethod":405,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":410,"awayjs-stagegl/lib/materials/passes/TriangleMethodPass":412}],389:[function(require,module,exports){
module.exports=require(208)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/MethodVO.js":208}],390:[function(require,module,exports){
module.exports=require(209)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/RegisterPool.js":209,"awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement":397}],391:[function(require,module,exports){
module.exports=require(210)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase.js":210,"awayjs-stagegl/lib/materials/compilation/ShaderRegisterCache":395,"awayjs-stagegl/lib/materials/compilation/ShaderRegisterData":396,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":410}],392:[function(require,module,exports){
module.exports=require(211)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderLightingCompiler.js":211,"awayjs-display/lib/materials/LightSources":490,"awayjs-stagegl/lib/base/ContextGLProfile":356,"awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase":391}],393:[function(require,module,exports){
module.exports=require(212)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderLightingObject.js":212,"awayjs-stagegl/lib/materials/compilation/ShaderLightingCompiler":392,"awayjs-stagegl/lib/materials/compilation/ShaderObjectBase":394}],394:[function(require,module,exports){
module.exports=require(213)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderObjectBase.js":213,"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-stagegl/lib/base/ContextGLTriangleFace":360,"awayjs-stagegl/lib/materials/compilation/ShaderCompilerBase":391}],395:[function(require,module,exports){
module.exports=require(214)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderRegisterCache.js":214,"awayjs-stagegl/lib/materials/compilation/RegisterPool":390,"awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement":397}],396:[function(require,module,exports){
module.exports=require(215)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderRegisterData.js":215}],397:[function(require,module,exports){
module.exports=require(216)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/compilation/ShaderRegisterElement.js":216}],398:[function(require,module,exports){
module.exports=require(217)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/AmbientBasicMethod.js":217,"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":404,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],399:[function(require,module,exports){
module.exports=require(218)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/DiffuseBasicMethod.js":218,"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/methods/LightingMethodBase":402,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],400:[function(require,module,exports){
module.exports=require(219)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/EffectColorTransformMethod.js":219,"awayjs-stagegl/lib/materials/methods/EffectMethodBase":401}],401:[function(require,module,exports){
module.exports=require(220)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/EffectMethodBase.js":220,"awayjs-core/lib/errors/AbstractMethodError":438,"awayjs-core/lib/library/AssetType":452,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":404}],402:[function(require,module,exports){
module.exports=require(221)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/LightingMethodBase.js":221,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":404}],403:[function(require,module,exports){
module.exports=require(222)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/NormalBasicMethod.js":222,"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/methods/ShadingMethodBase":404,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],404:[function(require,module,exports){
module.exports=require(223)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/ShadingMethodBase.js":223,"awayjs-core/lib/library/NamedAssetBase":453,"awayjs-stagegl/lib/events/ShadingMethodEvent":380}],405:[function(require,module,exports){
module.exports=require(224)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/methods/SpecularBasicMethod.js":224,"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/methods/LightingMethodBase":402,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],406:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var MaterialPassBase = require("awayjs-stagegl/lib/materials/passes/MaterialPassBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * DepthMapPass is a pass that writes depth values to a depth map as a 32-bit value exploded over the 4 texture channels.
 * This is used to render shadow maps, depth maps, etc.
 */
var DepthMapPass = (function (_super) {
    __extends(DepthMapPass, _super);
    /**
     * Creates a new DepthMapPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function DepthMapPass() {
        _super.call(this);
    }
    /**
     * Initializes the unchanging constant data for this material.
     */
    DepthMapPass.prototype._iInitConstantData = function (shaderObject) {
        _super.prototype._iInitConstantData.call(this, shaderObject);
        var index = this._fragmentConstantsIndex;
        var data = shaderObject.fragmentConstantData;
        data[index] = 1.0;
        data[index + 1] = 255.0;
        data[index + 2] = 65025.0;
        data[index + 3] = 16581375.0;
        data[index + 4] = 1.0 / 255.0;
        data[index + 5] = 1.0 / 255.0;
        data[index + 6] = 1.0 / 255.0;
        data[index + 7] = 0.0;
    };
    DepthMapPass.prototype._iIncludeDependencies = function (shaderObject) {
        shaderObject.projectionDependencies++;
        if (shaderObject.alphaThreshold > 0)
            shaderObject.uvDependencies++;
    };
    /**
     * @inheritDoc
     */
    DepthMapPass.prototype._iGetFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        var code = "";
        var targetReg = sharedRegisters.shadedTarget;
        var diffuseInputReg = registerCache.getFreeTextureReg();
        var dataReg1 = registerCache.getFreeFragmentConstant();
        var dataReg2 = registerCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = dataReg1.index * 4;
        var temp1 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp1, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp2, 1);
        code += "div " + temp1 + ", " + sharedRegisters.projectionFragment + ", " + sharedRegisters.projectionFragment + ".w\n" + "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" + "frc " + temp1 + ", " + temp1 + "\n" + "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
        //codeF += "mov ft1.w, fc1.w	\n" +
        //    "mov ft0.w, fc0.x	\n";
        if (shaderObject.alphaThreshold > 0) {
            diffuseInputReg = registerCache.getFreeTextureReg();
            this._texturesIndex = diffuseInputReg.index;
            var albedo = registerCache.getFreeFragmentVectorTemp();
            code += ShaderCompilerHelper.getTex2DSampleCode(albedo, sharedRegisters, diffuseInputReg, shaderObject.texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);
            var cutOffReg = registerCache.getFreeFragmentConstant();
            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" + "kil " + albedo + ".w\n";
        }
        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
        registerCache.removeFragmentTempUsage(temp1);
        registerCache.removeFragmentTempUsage(temp2);
        return code;
    };
    DepthMapPass.prototype._iRender = function (pass, renderable, stage, camera, viewProjection) {
        //this.setRenderState(pass, renderable, stage, camera, viewProjection);
    };
    /**
     * @inheritDoc
     */
    DepthMapPass.prototype._iActivate = function (pass, stage, camera) {
        _super.prototype._iActivate.call(this, pass, stage, camera);
        var context = stage.context;
        var shaderObject = pass.shaderObject;
        if (shaderObject.alphaThreshold > 0) {
            context.setSamplerStateAt(this._texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            context.activateTexture(this._texturesIndex, shaderObject.texture);
            shaderObject.fragmentConstantData[this._fragmentConstantsIndex + 8] = pass.shaderObject.alphaThreshold;
        }
    };
    return DepthMapPass;
})(MaterialPassBase);
module.exports = DepthMapPass;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":409,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],407:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ContextGLMipFilter = require("awayjs-stagegl/lib/base/ContextGLMipFilter");
var ContextGLTextureFilter = require("awayjs-stagegl/lib/base/ContextGLTextureFilter");
var ContextGLWrapMode = require("awayjs-stagegl/lib/base/ContextGLWrapMode");
var MaterialPassBase = require("awayjs-stagegl/lib/materials/passes/MaterialPassBase");
var ShaderCompilerHelper = require("awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper");
/**
 * DistanceMapPass is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
 * This is used to render omnidirectional shadow maps.
 */
var DistanceMapPass = (function (_super) {
    __extends(DistanceMapPass, _super);
    /**
     * Creates a new DistanceMapPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function DistanceMapPass() {
        _super.call(this);
    }
    /**
     * Initializes the unchanging constant data for this material.
     */
    DistanceMapPass.prototype._iInitConstantData = function (shaderObject) {
        _super.prototype._iInitConstantData.call(this, shaderObject);
        var index = this._fragmentConstantsIndex;
        var data = shaderObject.fragmentConstantData;
        data[index + 4] = 1.0 / 255.0;
        data[index + 5] = 1.0 / 255.0;
        data[index + 6] = 1.0 / 255.0;
        data[index + 7] = 0.0;
    };
    DistanceMapPass.prototype._iIncludeDependencies = function (shaderObject) {
        shaderObject.projectionDependencies++;
        shaderObject.viewDirDependencies++;
        if (shaderObject.alphaThreshold > 0)
            shaderObject.uvDependencies++;
        shaderObject.addWorldSpaceDependencies(false);
    };
    /**
     * @inheritDoc
     */
    DistanceMapPass.prototype._iGetFragmentCode = function (shaderObject, registerCache, sharedRegisters) {
        var code;
        var targetReg = sharedRegisters.shadedTarget;
        var diffuseInputReg = registerCache.getFreeTextureReg();
        var dataReg1 = registerCache.getFreeFragmentConstant();
        var dataReg2 = registerCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = dataReg1.index * 4;
        var temp1 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp1, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp2, 1);
        // squared distance to view
        code = "dp3 " + temp1 + ".z, " + sharedRegisters.viewDirVarying + ".xyz, " + sharedRegisters.viewDirVarying + ".xyz\n" + "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" + "frc " + temp1 + ", " + temp1 + "\n" + "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
        if (shaderObject.alphaThreshold > 0) {
            diffuseInputReg = registerCache.getFreeTextureReg();
            this._texturesIndex = diffuseInputReg.index;
            var albedo = registerCache.getFreeFragmentVectorTemp();
            code += ShaderCompilerHelper.getTex2DSampleCode(albedo, sharedRegisters, diffuseInputReg, shaderObject.texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);
            var cutOffReg = registerCache.getFreeFragmentConstant();
            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" + "kil " + albedo + ".w\n";
        }
        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    DistanceMapPass.prototype._iActivate = function (pass, stage, camera) {
        _super.prototype._iActivate.call(this, pass, stage, camera);
        var context = stage.context;
        var shaderObject = pass.shaderObject;
        var f = camera.projection.far;
        f = 1 / (2 * f * f);
        // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
        var index = this._fragmentConstantsIndex;
        var data = shaderObject.fragmentConstantData;
        data[index] = 1.0 * f;
        data[index + 1] = 255.0 * f;
        data[index + 2] = 65025.0 * f;
        data[index + 3] = 16581375.0 * f;
        if (shaderObject.alphaThreshold > 0) {
            context.setSamplerStateAt(this._texturesIndex, shaderObject.repeatTextures ? ContextGLWrapMode.REPEAT : ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures ? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping ? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);
            context.activateTexture(this._texturesIndex, shaderObject.texture);
            data[index + 8] = pass.shaderObject.alphaThreshold;
        }
    };
    return DistanceMapPass;
})(MaterialPassBase);
module.exports = DistanceMapPass;


},{"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":409,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],408:[function(require,module,exports){
module.exports=require(225)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/passes/LineBasicPass.js":225,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":409}],409:[function(require,module,exports){
module.exports=require(226)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/passes/MaterialPassBase.js":226,"awayjs-core/lib/errors/ArgumentError":439,"awayjs-core/lib/events/Event":442,"awayjs-core/lib/library/NamedAssetBase":453,"awayjs-display/lib/base/BlendMode":465,"awayjs-stagegl/lib/base/ContextGLBlendFactor":352,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/materials/compilation/ShaderObjectBase":394,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":410}],410:[function(require,module,exports){
module.exports=require(227)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/passes/MaterialPassMode.js":227}],411:[function(require,module,exports){
module.exports=require(228)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/passes/TriangleBasicPass.js":228,"awayjs-stagegl/lib/base/ContextGLMipFilter":355,"awayjs-stagegl/lib/base/ContextGLTextureFilter":358,"awayjs-stagegl/lib/base/ContextGLWrapMode":362,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":409,"awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper":414}],412:[function(require,module,exports){
module.exports=require(229)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/passes/TriangleMethodPass.js":229,"awayjs-stagegl/lib/events/ShadingMethodEvent":380,"awayjs-stagegl/lib/materials/compilation/MethodVO":389,"awayjs-stagegl/lib/materials/compilation/ShaderLightingObject":393,"awayjs-stagegl/lib/materials/compilation/ShaderObjectBase":394,"awayjs-stagegl/lib/materials/methods/EffectColorTransformMethod":400,"awayjs-stagegl/lib/materials/passes/MaterialPassBase":409,"awayjs-stagegl/lib/materials/passes/MaterialPassMode":410}],413:[function(require,module,exports){
module.exports=require(230)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/utils/DefaultMaterialManager.js":230,"awayjs-core/lib/base/BitmapData":437,"awayjs-core/lib/library/AssetType":452,"awayjs-core/lib/textures/BitmapTexture":454,"awayjs-stagegl/lib/materials/LineBasicMaterial":383,"awayjs-stagegl/lib/materials/TriangleBasicMaterial":385}],414:[function(require,module,exports){
module.exports=require(231)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/lib/materials/utils/ShaderCompilerHelper.js":231,"awayjs-stagegl/lib/base/ContextGLTextureFormat":359}],415:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var RenderableBase = require("awayjs-stagegl/lib/pool/RenderableBase");
/**
 * @class away.pool.RenderableListItem
 */
var BillboardRenderable = (function (_super) {
    __extends(BillboardRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param billboard
     */
    function BillboardRenderable(pool, billboard) {
        _super.call(this, pool, billboard, billboard);
        this._billboard = billboard;
    }
    /**
     * //TODO
     *
     * @returns {away.base.TriangleSubGeometry}
     */
    BillboardRenderable.prototype._pGetSubGeometry = function () {
        var material = this._billboard.material;
        var geometry = BillboardRenderable._materialGeometry[material.id];
        if (!geometry) {
            geometry = BillboardRenderable._materialGeometry[material.id] = new TriangleSubGeometry(true);
            geometry.autoDeriveNormals = false;
            geometry.autoDeriveTangents = false;
            geometry.updateIndices(Array(0, 1, 2, 0, 2, 3));
            geometry.updatePositions(Array(0, material.height, 0, material.width, material.height, 0, material.width, 0, 0, 0, 0, 0));
            geometry.updateVertexNormals(Array(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0));
            geometry.updateVertexTangents(Array(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1));
            geometry.updateUVs(Array(0, 0, 1, 0, 1, 1, 0, 1));
        }
        else {
            geometry.updatePositions(Array(0, material.height, 0, material.width, material.height, 0, material.width, 0, 0, 0, 0, 0));
        }
        this._pVertexDataDirty[TriangleSubGeometry.POSITION_DATA] = true;
        this._pVertexDataDirty[TriangleSubGeometry.NORMAL_DATA] = true;
        this._pVertexDataDirty[TriangleSubGeometry.TANGENT_DATA] = true;
        this._pVertexDataDirty[TriangleSubGeometry.UV_DATA] = true;
        return geometry;
    };
    BillboardRenderable._materialGeometry = new Object();
    /**
     *
     */
    BillboardRenderable.id = "billboard";
    return BillboardRenderable;
})(RenderableBase);
module.exports = BillboardRenderable;


},{"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-stagegl/lib/pool/RenderableBase":425}],416:[function(require,module,exports){
/**
 *
 */
var IndexData = (function () {
    function IndexData(level) {
        this._dataDirty = true;
        this.invalid = new Array(8);
        this.contexts = new Array(8);
        this.buffers = new Array(8);
        this.level = level;
    }
    IndexData.prototype.updateData = function (offset, indices, numVertices) {
        if (this._dataDirty) {
            this._dataDirty = false;
            if (indices.length < IndexData.LIMIT_INDICES && numVertices < IndexData.LIMIT_VERTS) {
                //shortcut for those buffers that fit into the maximum buffer sizes
                this.indexMappings = null;
                this.originalIndices = null;
                this.setData(indices);
                this.offset = indices.length;
            }
            else {
                var i;
                var len;
                var outIndex;
                var j;
                var k;
                var splitIndices = new Array();
                this.indexMappings = new Array(indices.length);
                this.originalIndices = new Array();
                i = this.indexMappings.length;
                while (i--)
                    this.indexMappings[i] = -1;
                var originalIndex;
                var splitIndex;
                // Loop over all triangles
                outIndex = 0;
                len = indices.length;
                i = offset;
                k = 0;
                while (i < len && outIndex + 3 < IndexData.LIMIT_INDICES && k + 3 < IndexData.LIMIT_VERTS) {
                    for (j = 0; j < 3; j++) {
                        originalIndex = indices[i + j];
                        if (this.indexMappings[originalIndex] >= 0) {
                            splitIndex = this.indexMappings[originalIndex];
                        }
                        else {
                            // This vertex does not yet exist in the split list and
                            // needs to be copied from the long list.
                            splitIndex = k++;
                            this.indexMappings[originalIndex] = splitIndex;
                            this.originalIndices.push(originalIndex);
                        }
                        // Store new index, which may have come from the mapping look-up,
                        // or from copying a new set of vertex data from the original vector
                        splitIndices[outIndex + j] = splitIndex;
                    }
                    outIndex += 3;
                    i += 3;
                }
                this.setData(splitIndices);
                this.offset = i;
            }
        }
    };
    IndexData.prototype.invalidateData = function () {
        this._dataDirty = true;
    };
    IndexData.prototype.dispose = function () {
        for (var i = 0; i < 8; ++i) {
            if (this.contexts[i]) {
                this.contexts[i].disposeIndexData(this);
                this.contexts[i] = null;
            }
        }
    };
    /**
     * @private
     */
    IndexData.prototype.disposeBuffers = function () {
        for (var i = 0; i < 8; ++i) {
            if (this.buffers[i]) {
                this.buffers[i].dispose();
                this.buffers[i] = null;
            }
        }
    };
    /**
     * @private
     */
    IndexData.prototype.invalidateBuffers = function () {
        for (var i = 0; i < 8; ++i)
            this.invalid[i] = true;
    };
    /**
     *
     * @param data
     * @private
     */
    IndexData.prototype.setData = function (data) {
        if (this.data && this.data.length != data.length)
            this.disposeBuffers();
        else
            this.invalidateBuffers();
        this.data = data;
    };
    IndexData.LIMIT_VERTS = 0xffff;
    IndexData.LIMIT_INDICES = 0xffffff;
    return IndexData;
})();
module.exports = IndexData;


},{}],417:[function(require,module,exports){
var IndexData = require("awayjs-stagegl/lib/pool/IndexData");
/**
 *
 */
var IndexDataPool = (function () {
    function IndexDataPool() {
    }
    IndexDataPool.getItem = function (subGeometry, level, indexOffset) {
        var subGeometryData = (IndexDataPool._pool[subGeometry.id] || (IndexDataPool._pool[subGeometry.id] = new Array()));
        var indexData = subGeometryData[level] || (subGeometryData[level] = new IndexData(level));
        indexData.updateData(indexOffset, subGeometry.indices, subGeometry.numVertices);
        return indexData;
    };
    IndexDataPool.disposeItem = function (id, level) {
        var subGeometryData = this._pool[id];
        subGeometryData[level].dispose();
        subGeometryData[level] = null;
    };
    IndexDataPool.prototype.disposeData = function (id) {
        var subGeometryData = IndexDataPool._pool[id];
        var len = subGeometryData.length;
        for (var i = 0; i < len; i++) {
            subGeometryData[i].dispose();
            subGeometryData[i] = null;
        }
        IndexDataPool._pool[id] = null;
    };
    IndexDataPool._pool = new Object();
    return IndexDataPool;
})();
module.exports = IndexDataPool;


},{"awayjs-stagegl/lib/pool/IndexData":416}],418:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var LineSubGeometry = require("awayjs-display/lib/base/LineSubGeometry");
var RenderableBase = require("awayjs-stagegl/lib/pool/RenderableBase");
/**
 * @class away.pool.LineSubMeshRenderable
 */
var LineSubMeshRenderable = (function (_super) {
    __extends(LineSubMeshRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param subMesh
     * @param level
     * @param dataOffset
     */
    function LineSubMeshRenderable(pool, subMesh, level, indexOffset) {
        if (level === void 0) { level = 0; }
        if (indexOffset === void 0) { indexOffset = 0; }
        _super.call(this, pool, subMesh.parentMesh, subMesh, level, indexOffset);
        this.subMesh = subMesh;
    }
    /**
     * //TODO
     *
     * @returns {base.LineSubGeometry}
     * @protected
     */
    LineSubMeshRenderable.prototype._pGetSubGeometry = function () {
        var subGeometry = this.subMesh.subGeometry;
        this._pVertexDataDirty[LineSubGeometry.START_POSITION_DATA] = true;
        this._pVertexDataDirty[LineSubGeometry.END_POSITION_DATA] = true;
        if (subGeometry.thickness)
            this._pVertexDataDirty[LineSubGeometry.THICKNESS_DATA] = true;
        if (subGeometry.startColors)
            this._pVertexDataDirty[LineSubGeometry.COLOR_DATA] = true;
        return subGeometry;
    };
    /**
     * //TODO
     *
     * @param pool
     * @param materialOwner
     * @param level
     * @param indexOffset
     * @returns {away.pool.LineSubMeshRenderable}
     * @private
     */
    LineSubMeshRenderable.prototype._pGetOverflowRenderable = function (pool, materialOwner, level, indexOffset) {
        return new LineSubMeshRenderable(pool, materialOwner, level, indexOffset);
    };
    /**
     *
     */
    LineSubMeshRenderable.id = "linesubmesh";
    return LineSubMeshRenderable;
})(RenderableBase);
module.exports = LineSubMeshRenderable;


},{"awayjs-display/lib/base/LineSubGeometry":468,"awayjs-stagegl/lib/pool/RenderableBase":425}],419:[function(require,module,exports){
var MaterialPassDataPool = require("awayjs-stagegl/lib/pool/MaterialPassDataPool");
/**
 *
 * @class away.pool.MaterialData
 */
var MaterialData = (function () {
    function MaterialData(pool, context, material) {
        this.invalidAnimation = true;
        this._pool = pool;
        this.context = context;
        this.material = material;
        this._materialPassDataPool = new MaterialPassDataPool(material);
    }
    MaterialData.prototype.getMaterialPass = function (materialPass, profile) {
        var materialPassData = this._materialPassDataPool.getItem(materialPass);
        if (!materialPassData.shaderObject) {
            materialPassData.shaderObject = materialPass.createShaderObject(profile);
            materialPassData.invalid = true;
        }
        if (materialPassData.invalid) {
            materialPassData.invalid = false;
            var compiler = materialPassData.shaderObject.createCompiler(this.material, materialPass);
            compiler.compile();
            materialPassData.shadedTarget = compiler.shadedTarget;
            materialPassData.vertexCode = compiler.vertexCode;
            materialPassData.fragmentCode = compiler.fragmentCode;
            materialPassData.postAnimationFragmentCode = compiler.postAnimationFragmentCode;
            materialPassData.key = "";
        }
        return materialPassData;
    };
    MaterialData.prototype.getMaterialPasses = function (profile) {
        if (this._passes == null) {
            var passes = this.material._iScreenPasses;
            var numPasses = passes.length;
            //reset the material passes in MaterialData
            this._passes = new Array(numPasses);
            for (var i = 0; i < numPasses; i++)
                this._passes[i] = this.getMaterialPass(passes[i], profile);
        }
        return this._passes;
    };
    /**
     *
     */
    MaterialData.prototype.dispose = function () {
        this._materialPassDataPool.disposePool();
        this._materialPassDataPool = null;
        this._pool.disposeItem(this.material);
        this._passes = null;
    };
    /**
     *
     */
    MaterialData.prototype.invalidateMaterial = function () {
        this._passes = null;
        this.invalidateAnimation();
    };
    /**
     *
     */
    MaterialData.prototype.invalidateAnimation = function () {
        this.invalidAnimation = true;
    };
    return MaterialData;
})();
module.exports = MaterialData;


},{"awayjs-stagegl/lib/pool/MaterialPassDataPool":422}],420:[function(require,module,exports){
var MaterialData = require("awayjs-stagegl/lib/pool/MaterialData");
/**
 * @class away.pool.MaterialDataPool
 */
var MaterialDataPool = (function () {
    /**
     * //TODO
     *
     * @param textureDataClass
     */
    function MaterialDataPool(context) {
        this._pool = new Object();
        this._context = context;
    }
    /**
     * //TODO
     *
     * @param materialOwner
     * @returns ITexture
     */
    MaterialDataPool.prototype.getItem = function (material) {
        return (this._pool[material.id] || (this._pool[material.id] = material._iAddMaterialData(new MaterialData(this, this._context, material))));
    };
    /**
     * //TODO
     *
     * @param materialOwner
     */
    MaterialDataPool.prototype.disposeItem = function (material) {
        material._iRemoveMaterialData(this._pool[material.id]);
        this._pool[material.id] = null;
    };
    return MaterialDataPool;
})();
module.exports = MaterialDataPool;


},{"awayjs-stagegl/lib/pool/MaterialData":419}],421:[function(require,module,exports){
/**
 *
 * @class away.pool.MaterialPassData
 */
var MaterialPassData = (function () {
    function MaterialPassData(pool, material, materialPass) {
        this.animationVertexCode = "";
        this.animationFragmentCode = "";
        this._pool = pool;
        this.material = material;
        this.materialPass = materialPass;
    }
    /**
     *
     */
    MaterialPassData.prototype.dispose = function () {
        this._pool.disposeItem(this.materialPass);
        this.shaderObject.dispose();
        this.shaderObject = null;
        this.programData.dispose();
        this.programData = null;
    };
    /**
     *
     */
    MaterialPassData.prototype.invalidate = function () {
        this.invalid = true;
    };
    return MaterialPassData;
})();
module.exports = MaterialPassData;


},{}],422:[function(require,module,exports){
var MaterialPassData = require("awayjs-stagegl/lib/pool/MaterialPassData");
/**
 * @class away.pool.MaterialPassDataPool
 */
var MaterialPassDataPool = (function () {
    /**
     * //TODO
     *
     * @param textureDataClass
     */
    function MaterialPassDataPool(material) {
        this._pool = new Object();
        this._material = material;
    }
    /**
     * //TODO
     *
     * @param materialOwner
     * @returns ITexture
     */
    MaterialPassDataPool.prototype.getItem = function (materialPass) {
        return (this._pool[materialPass.id] || (this._pool[materialPass.id] = this._material._iAddMaterialPassData(materialPass._iAddMaterialPassData(new MaterialPassData(this, this._material, materialPass)))));
    };
    /**
     * //TODO
     *
     * @param materialOwner
     */
    MaterialPassDataPool.prototype.disposeItem = function (materialPass) {
        materialPass._iRemoveMaterialPassData(this._pool[materialPass.id]);
        delete this._pool[materialPass.id];
    };
    MaterialPassDataPool.prototype.disposePool = function () {
        for (var id in this._pool)
            this._pool[id].materialPass._iRemoveMaterialPassData(this._pool[id]);
        delete this._pool;
    };
    return MaterialPassDataPool;
})();
module.exports = MaterialPassDataPool;


},{"awayjs-stagegl/lib/pool/MaterialPassData":421}],423:[function(require,module,exports){
/**
 *
 * @class away.pool.ProgramDataBase
 */
var ProgramData = (function () {
    function ProgramData(pool, context, key) {
        this.usages = 0;
        this._pool = pool;
        this.context = context;
        this._key = key;
        this.context.registerProgram(this);
    }
    /**
     *
     */
    ProgramData.prototype.dispose = function () {
        this.usages--;
        if (!this.usages) {
            this._pool.disposeItem(this._key);
            this.context.unRegisterProgram(this);
            if (this.program)
                this.program.dispose();
        }
        this.program = null;
    };
    ProgramData.PROGRAMDATA_ID_COUNT = 0;
    return ProgramData;
})();
module.exports = ProgramData;


},{}],424:[function(require,module,exports){
var ProgramData = require("awayjs-stagegl/lib/pool/ProgramData");
/**
 * @class away.pool.ProgramDataPool
 */
var ProgramDataPool = (function () {
    /**
     * //TODO
     *
     * @param textureDataClass
     */
    function ProgramDataPool(context) {
        this._pool = new Object();
        this._context = context;
    }
    /**
     * //TODO
     *
     * @param materialOwner
     * @returns ITexture
     */
    ProgramDataPool.prototype.getItem = function (key) {
        return this._pool[key] || (this._pool[key] = new ProgramData(this, this._context, key));
    };
    /**
     * //TODO
     *
     * @param materialOwner
     */
    ProgramDataPool.prototype.disposeItem = function (key) {
        this._pool[key] = null;
    };
    return ProgramDataPool;
})();
module.exports = ProgramDataPool;


},{"awayjs-stagegl/lib/pool/ProgramData":423}],425:[function(require,module,exports){
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var SubGeometryBase = require("awayjs-display/lib/base/SubGeometryBase");
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var SubGeometryEvent = require("awayjs-display/lib/events/SubGeometryEvent");
var IndexDataPool = require("awayjs-stagegl/lib/pool/IndexDataPool");
var VertexDataPool = require("awayjs-stagegl/lib/pool/VertexDataPool");
/**
 * @class RenderableListItem
 */
var RenderableBase = (function () {
    /**
     *
     * @param sourceEntity
     * @param materialOwner
     * @param subGeometry
     * @param animationSubGeometry
     */
    function RenderableBase(pool, sourceEntity, materialOwner, level, indexOffset) {
        var _this = this;
        if (level === void 0) { level = 0; }
        if (indexOffset === void 0) { indexOffset = 0; }
        this._geometryDirty = true;
        this._indexDataDirty = true;
        this._vertexData = new Object();
        this._pVertexDataDirty = new Object();
        this._vertexOffset = new Object();
        this._onIndicesUpdatedDelegate = function (event) { return _this._onIndicesUpdated(event); };
        this._onVerticesUpdatedDelegate = function (event) { return _this._onVerticesUpdated(event); };
        //store a reference to the pool for later disposal
        this._pool = pool;
        //reference to level of overflow
        this._level = level;
        //reference to the offset on indices (if this is an overflow renderable)
        this._indexOffset = indexOffset;
        this.sourceEntity = sourceEntity;
        this.materialOwner = materialOwner;
    }
    Object.defineProperty(RenderableBase.prototype, "overflow", {
        /**
         *
         */
        get: function () {
            if (this._indexDataDirty)
                this._updateIndexData();
            return this._overflow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderableBase.prototype, "numTriangles", {
        /**
         *
         */
        get: function () {
            return this._numTriangles;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    RenderableBase.prototype.getIndexData = function () {
        if (this._indexDataDirty)
            this._updateIndexData();
        return this._indexData;
    };
    /**
     *
     */
    RenderableBase.prototype.getVertexData = function (dataType) {
        if (this._indexDataDirty)
            this._updateIndexData();
        if (this._pVertexDataDirty[dataType])
            this._updateVertexData(dataType);
        return this._vertexData[this._concatenateArrays ? TriangleSubGeometry.VERTEX_DATA : dataType];
    };
    /**
     *
     */
    RenderableBase.prototype.getVertexOffset = function (dataType) {
        if (this._indexDataDirty)
            this._updateIndexData();
        if (this._pVertexDataDirty[dataType])
            this._updateVertexData(dataType);
        return this._vertexOffset[dataType];
    };
    RenderableBase.prototype.dispose = function () {
        this._pool.disposeItem(this.materialOwner);
        this._indexData.dispose();
        this._indexData = null;
        for (var dataType in this._vertexData) {
            this._vertexData[dataType].dispose();
            this._vertexData[dataType] = null;
        }
        if (this._overflow) {
            this._overflow.dispose();
            this._overflow = null;
        }
    };
    RenderableBase.prototype.invalidateGeometry = function () {
        this._geometryDirty = true;
        //invalidate indices
        if (this._level == 0)
            this._indexDataDirty = true;
        if (this._overflow)
            this._overflow.invalidateGeometry();
    };
    /**
     *
     */
    RenderableBase.prototype.invalidateIndexData = function () {
        this._indexDataDirty = true;
    };
    /**
     * //TODO
     *
     * @param dataType
     */
    RenderableBase.prototype.invalidateVertexData = function (dataType) {
        this._pVertexDataDirty[dataType] = true;
    };
    RenderableBase.prototype._pGetSubGeometry = function () {
        throw new AbstractMethodError();
    };
    /**
     * //TODO
     *
     * @param subGeometry
     * @param offset
     * @internal
     */
    RenderableBase.prototype._iFillIndexData = function (indexOffset) {
        if (this._geometryDirty)
            this._updateGeometry();
        this._indexData = IndexDataPool.getItem(this._subGeometry, this._level, indexOffset);
        this._numTriangles = this._indexData.data.length / 3;
        indexOffset = this._indexData.offset;
        //check if there is more to split
        if (indexOffset < this._subGeometry.indices.length) {
            if (!this._overflow)
                this._overflow = this._pGetOverflowRenderable(this._pool, this.materialOwner, indexOffset, this._level + 1);
            this._overflow._iFillIndexData(indexOffset);
        }
        else if (this._overflow) {
            this._overflow.dispose();
            this._overflow = null;
        }
    };
    RenderableBase.prototype._pGetOverflowRenderable = function (pool, materialOwner, level, indexOffset) {
        throw new AbstractMethodError();
    };
    /**
     * //TODO
     *
     * @private
     */
    RenderableBase.prototype._updateGeometry = function () {
        if (this._subGeometry) {
            if (this._level == 0)
                this._subGeometry.removeEventListener(SubGeometryEvent.INDICES_UPDATED, this._onIndicesUpdatedDelegate);
            this._subGeometry.removeEventListener(SubGeometryEvent.VERTICES_UPDATED, this._onVerticesUpdatedDelegate);
        }
        this._subGeometry = this._pGetSubGeometry();
        this._concatenateArrays = this._subGeometry.concatenateArrays;
        if (this._subGeometry) {
            if (this._level == 0)
                this._subGeometry.addEventListener(SubGeometryEvent.INDICES_UPDATED, this._onIndicesUpdatedDelegate);
            this._subGeometry.addEventListener(SubGeometryEvent.VERTICES_UPDATED, this._onVerticesUpdatedDelegate);
        }
        //dispose
        //			if (this._indexData) {
        //				this._indexData.dispose(); //TODO where is a good place to dispose?
        //				this._indexData = null;
        //			}
        //			for (var dataType in this._vertexData) {
        //				(<VertexData> this._vertexData[dataType]).dispose(); //TODO where is a good place to dispose?
        //				this._vertexData[dataType] = null;
        //			}
        this._geometryDirty = false;
        //specific vertex data types have to be invalidated in the specific renderable
    };
    /**
     * //TODO
     *
     * @private
     */
    RenderableBase.prototype._updateIndexData = function () {
        this._iFillIndexData(this._indexOffset);
        this._indexDataDirty = false;
    };
    /**
     * //TODO
     *
     * @param dataType
     * @private
     */
    RenderableBase.prototype._updateVertexData = function (dataType) {
        this._vertexOffset[dataType] = this._subGeometry.getOffset(dataType);
        if (this._subGeometry.concatenateArrays)
            dataType = SubGeometryBase.VERTEX_DATA;
        this._vertexData[dataType] = VertexDataPool.getItem(this._subGeometry, this.getIndexData(), dataType);
        this._pVertexDataDirty[dataType] = false;
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    RenderableBase.prototype._onIndicesUpdated = function (event) {
        this.invalidateIndexData();
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    RenderableBase.prototype._onVerticesUpdated = function (event) {
        this._concatenateArrays = event.target.concatenateArrays;
        this.invalidateVertexData(event.dataType);
    };
    return RenderableBase;
})();
module.exports = RenderableBase;


},{"awayjs-core/lib/errors/AbstractMethodError":438,"awayjs-display/lib/base/SubGeometryBase":471,"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-display/lib/events/SubGeometryEvent":489,"awayjs-stagegl/lib/pool/IndexDataPool":417,"awayjs-stagegl/lib/pool/VertexDataPool":431}],426:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var RenderableBase = require("awayjs-stagegl/lib/pool/RenderableBase");
/**
 * @class away.pool.SkyboxRenderable
 */
var SkyboxRenderable = (function (_super) {
    __extends(SkyboxRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param skybox
     */
    function SkyboxRenderable(pool, skybox) {
        _super.call(this, pool, skybox, skybox);
    }
    /**
     * //TODO
     *
     * @returns {away.base.TriangleSubGeometry}
     * @private
     */
    SkyboxRenderable.prototype._pGetSubGeometry = function () {
        var geometry = SkyboxRenderable._geometry;
        if (!geometry) {
            geometry = SkyboxRenderable._geometry = new TriangleSubGeometry(true);
            geometry.autoDeriveNormals = false;
            geometry.autoDeriveTangents = false;
            geometry.updateIndices(Array(0, 1, 2, 2, 3, 0, 6, 5, 4, 4, 7, 6, 2, 6, 7, 7, 3, 2, 4, 5, 1, 1, 0, 4, 4, 0, 3, 3, 7, 4, 2, 1, 5, 5, 6, 2));
            geometry.updatePositions(Array(-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1));
        }
        this._pVertexDataDirty[TriangleSubGeometry.POSITION_DATA] = true;
        return geometry;
    };
    /**
     *
     */
    SkyboxRenderable.id = "skybox";
    return SkyboxRenderable;
})(RenderableBase);
module.exports = SkyboxRenderable;


},{"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-stagegl/lib/pool/RenderableBase":425}],427:[function(require,module,exports){
/**
 *
 * @class away.pool.TextureDataBase
 */
var TextureData = (function () {
    function TextureData(pool, context, textureProxy) {
        this._pool = pool;
        this.context = context;
        this.textureProxy = textureProxy;
    }
    /**
     *
     */
    TextureData.prototype.dispose = function () {
        this._pool.disposeItem(this.textureProxy);
        this.texture.dispose();
        this.texture = null;
    };
    /**
     *
     */
    TextureData.prototype.invalidate = function () {
        this.invalid = true;
    };
    return TextureData;
})();
module.exports = TextureData;


},{}],428:[function(require,module,exports){
var TextureData = require("awayjs-stagegl/lib/pool/TextureData");
/**
 * @class away.pool.TextureDataPool
 */
var TextureDataPool = (function () {
    /**
     * //TODO
     *
     * @param textureDataClass
     */
    function TextureDataPool(context) {
        this._pool = new Object();
        this._context = context;
    }
    /**
     * //TODO
     *
     * @param materialOwner
     * @returns ITexture
     */
    TextureDataPool.prototype.getItem = function (textureProxy) {
        return (this._pool[textureProxy.id] || (this._pool[textureProxy.id] = textureProxy._iAddTextureData(new TextureData(this, this._context, textureProxy))));
    };
    /**
     * //TODO
     *
     * @param materialOwner
     */
    TextureDataPool.prototype.disposeItem = function (textureProxy) {
        textureProxy._iRemoveTextureData(this._pool[textureProxy.id]);
        this._pool[textureProxy.id] = null;
    };
    return TextureDataPool;
})();
module.exports = TextureDataPool;


},{"awayjs-stagegl/lib/pool/TextureData":427}],429:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TriangleSubGeometry = require("awayjs-display/lib/base/TriangleSubGeometry");
var RenderableBase = require("awayjs-stagegl/lib/pool/RenderableBase");
var ContextGLVertexBufferFormat = require("awayjs-stagegl/lib/base/ContextGLVertexBufferFormat");
/**
 * @class away.pool.TriangleSubMeshRenderable
 */
var TriangleSubMeshRenderable = (function (_super) {
    __extends(TriangleSubMeshRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param subMesh
     * @param level
     * @param indexOffset
     */
    function TriangleSubMeshRenderable(pool, subMesh, level, indexOffset) {
        if (level === void 0) { level = 0; }
        if (indexOffset === void 0) { indexOffset = 0; }
        _super.call(this, pool, subMesh.parentMesh, subMesh, level, indexOffset);
        this.subMesh = subMesh;
    }
    /**
     *
     * @returns {SubGeometryBase}
     * @protected
     */
    TriangleSubMeshRenderable.prototype._pGetSubGeometry = function () {
        var subGeometry;
        if (this.subMesh.animator)
            subGeometry = this.subMesh.animator.getRenderableSubGeometry(this, this.subMesh.subGeometry);
        else
            subGeometry = this.subMesh.subGeometry;
        this._pVertexDataDirty[TriangleSubGeometry.POSITION_DATA] = true;
        if (subGeometry.vertexNormals)
            this._pVertexDataDirty[TriangleSubGeometry.NORMAL_DATA] = true;
        if (subGeometry.vertexTangents)
            this._pVertexDataDirty[TriangleSubGeometry.TANGENT_DATA] = true;
        if (subGeometry.uvs)
            this._pVertexDataDirty[TriangleSubGeometry.UV_DATA] = true;
        if (subGeometry.secondaryUVs)
            this._pVertexDataDirty[TriangleSubGeometry.SECONDARY_UV_DATA] = true;
        if (subGeometry.jointIndices)
            this._pVertexDataDirty[TriangleSubGeometry.JOINT_INDEX_DATA] = true;
        if (subGeometry.jointWeights)
            this._pVertexDataDirty[TriangleSubGeometry.JOINT_WEIGHT_DATA] = true;
        switch (subGeometry.jointsPerVertex) {
            case 1:
                this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = ContextGLVertexBufferFormat.FLOAT_1;
                break;
            case 2:
                this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = ContextGLVertexBufferFormat.FLOAT_2;
                break;
            case 3:
                this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = ContextGLVertexBufferFormat.FLOAT_3;
                break;
            case 4:
                this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = ContextGLVertexBufferFormat.FLOAT_4;
                break;
            default:
        }
        return subGeometry;
    };
    /**
     * //TODO
     *
     * @param pool
     * @param materialOwner
     * @param level
     * @param indexOffset
     * @returns {away.pool.TriangleSubMeshRenderable}
     * @protected
     */
    TriangleSubMeshRenderable.prototype._pGetOverflowRenderable = function (pool, materialOwner, level, indexOffset) {
        return new TriangleSubMeshRenderable(pool, materialOwner, level, indexOffset);
    };
    /**
     *
     */
    TriangleSubMeshRenderable.id = "trianglesubmesh";
    return TriangleSubMeshRenderable;
})(RenderableBase);
module.exports = TriangleSubMeshRenderable;


},{"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-stagegl/lib/base/ContextGLVertexBufferFormat":361,"awayjs-stagegl/lib/pool/RenderableBase":425}],430:[function(require,module,exports){
var SubGeometryBase = require("awayjs-display/lib/base/SubGeometryBase");
var SubGeometryEvent = require("awayjs-display/lib/events/SubGeometryEvent");
/**
 *
 */
var VertexData = (function () {
    function VertexData(subGeometry, dataType) {
        var _this = this;
        this._dataDirty = true;
        this.invalid = new Array(8);
        this.buffers = new Array(8);
        this.contexts = new Array(8);
        this._subGeometry = subGeometry;
        this._dataType = dataType;
        this._onVerticesUpdatedDelegate = function (event) { return _this._onVerticesUpdated(event); };
        this._subGeometry.addEventListener(SubGeometryEvent.VERTICES_UPDATED, this._onVerticesUpdatedDelegate);
    }
    VertexData.prototype.updateData = function (originalIndices, indexMappings) {
        if (originalIndices === void 0) { originalIndices = null; }
        if (indexMappings === void 0) { indexMappings = null; }
        if (this._dataDirty) {
            this._dataDirty = false;
            this.dataPerVertex = this._subGeometry.getStride(this._dataType);
            var vertices = this._subGeometry[this._dataType];
            if (indexMappings == null) {
                this.setData(vertices);
            }
            else {
                var splitVerts = new Array(originalIndices.length * this.dataPerVertex);
                var originalIndex;
                var splitIndex;
                var i = 0;
                var j = 0;
                while (i < originalIndices.length) {
                    originalIndex = originalIndices[i];
                    splitIndex = indexMappings[originalIndex] * this.dataPerVertex;
                    originalIndex *= this.dataPerVertex;
                    for (j = 0; j < this.dataPerVertex; j++)
                        splitVerts[splitIndex + j] = vertices[originalIndex + j];
                    i++;
                }
                this.setData(splitVerts);
            }
        }
    };
    VertexData.prototype.dispose = function () {
        for (var i = 0; i < 8; ++i) {
            if (this.contexts[i]) {
                this.contexts[i].disposeVertexData(this);
                this.contexts[i] = null;
            }
        }
    };
    /**
     * @private
     */
    VertexData.prototype.disposeBuffers = function () {
        for (var i = 0; i < 8; ++i) {
            if (this.buffers[i]) {
                this.buffers[i].dispose();
                this.buffers[i] = null;
            }
        }
    };
    /**
     * @private
     */
    VertexData.prototype.invalidateBuffers = function () {
        for (var i = 0; i < 8; ++i)
            this.invalid[i] = true;
    };
    /**
     *
     * @param data
     * @param dataPerVertex
     * @private
     */
    VertexData.prototype.setData = function (data) {
        if (this.data && this.data.length != data.length)
            this.disposeBuffers();
        else
            this.invalidateBuffers();
        this.data = data;
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    VertexData.prototype._onVerticesUpdated = function (event) {
        var dataType = this._subGeometry.concatenateArrays ? SubGeometryBase.VERTEX_DATA : event.dataType;
        if (dataType == this._dataType)
            this._dataDirty = true;
    };
    return VertexData;
})();
module.exports = VertexData;


},{"awayjs-display/lib/base/SubGeometryBase":471,"awayjs-display/lib/events/SubGeometryEvent":489}],431:[function(require,module,exports){
var SubGeometryBase = require("awayjs-display/lib/base/SubGeometryBase");
var VertexData = require("awayjs-stagegl/lib/pool/VertexData");
/**
 *
 */
var VertexDataPool = (function () {
    function VertexDataPool() {
    }
    VertexDataPool.getItem = function (subGeometry, indexData, dataType) {
        if (subGeometry.concatenateArrays)
            dataType = SubGeometryBase.VERTEX_DATA;
        var subGeometryDictionary = (VertexDataPool._pool[subGeometry.id] || (VertexDataPool._pool[subGeometry.id] = new Object()));
        var subGeometryData = (subGeometryDictionary[dataType] || (subGeometryDictionary[dataType] = new Array()));
        var vertexData = subGeometryData[indexData.level] || (subGeometryData[indexData.level] = new VertexData(subGeometry, dataType));
        vertexData.updateData(indexData.originalIndices, indexData.indexMappings);
        return vertexData;
    };
    VertexDataPool.disposeItem = function (subGeometry, level, dataType) {
        var subGeometryDictionary = VertexDataPool._pool[subGeometry.id];
        var subGeometryData = subGeometryDictionary[dataType];
        subGeometryData[level].dispose();
        subGeometryData[level] = null;
    };
    VertexDataPool.prototype.disposeData = function (subGeometry) {
        var subGeometryDictionary = VertexDataPool._pool[subGeometry.id];
        for (var key in subGeometryDictionary) {
            var subGeometryData = subGeometryDictionary[key];
            var len = subGeometryData.length;
            for (var i = 0; i < len; i++) {
                subGeometryData[i].dispose();
                subGeometryData[i] = null;
            }
        }
        VertexDataPool._pool[subGeometry.id] = null;
    };
    VertexDataPool._pool = new Object();
    return VertexDataPool;
})();
module.exports = VertexDataPool;


},{"awayjs-display/lib/base/SubGeometryBase":471,"awayjs-stagegl/lib/pool/VertexData":430}],432:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var RenderTexture = require("awayjs-core/lib/textures/RenderTexture");
var RenderablePool = require("awayjs-display/lib/pool/RenderablePool");
var SkyboxRenderable = require("awayjs-stagegl/lib/pool/SkyboxRenderable");
var DepthRenderer = require("awayjs-stagegl/lib/render/DepthRenderer");
var Filter3DRenderer = require("awayjs-stagegl/lib/render/Filter3DRenderer");
var RendererBase = require("awayjs-stagegl/lib/render/RendererBase");
var ContextGLBlendFactor = require("awayjs-stagegl/lib/base/ContextGLBlendFactor");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
var ContextGLClearMask = require("awayjs-stagegl/lib/base/ContextGLClearMask");
var RTTBufferManager = require("awayjs-stagegl/lib/managers/RTTBufferManager");
var StageManager = require("awayjs-stagegl/lib/managers/StageManager");
var DepthMapPass = require("awayjs-stagegl/lib/materials/passes/DepthMapPass");
var DistanceMapPass = require("awayjs-stagegl/lib/materials/passes/DistanceMapPass");
/**
 * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
 * materials assigned to them.
 *
 * @class away.render.DefaultRenderer
 */
var DefaultRenderer = (function (_super) {
    __extends(DefaultRenderer, _super);
    /**
     * Creates a new DefaultRenderer object.
     *
     * @param antiAlias The amount of anti-aliasing to use.
     * @param renderMode The render mode to use.
     */
    function DefaultRenderer(forceSoftware, profile, mode) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = "baseline"; }
        if (mode === void 0) { mode = "auto"; }
        _super.call(this);
        this._skyboxProjection = new Matrix3D();
        this._skyboxRenderablePool = RenderablePool.getPool(SkyboxRenderable);
        this._pDepthRenderer = new DepthRenderer(new DepthMapPass());
        this._pDistanceRenderer = new DepthRenderer(new DistanceMapPass());
        if (this._pStage == null)
            this.stage = StageManager.getInstance().getFreeStage(forceSoftware, profile, mode);
        this._pRttBufferManager = RTTBufferManager.getInstance(this._pStage);
        if (this._width == 0)
            this.width = window.innerWidth;
        else
            this._pRttBufferManager.viewWidth = this._width;
        if (this._height == 0)
            this.height = window.innerHeight;
        else
            this._pRttBufferManager.viewHeight = this._height;
    }
    Object.defineProperty(DefaultRenderer.prototype, "antiAlias", {
        get: function () {
            return this._antiAlias;
        },
        set: function (value) {
            if (this._antiAlias == value)
                return;
            this._antiAlias = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderer.prototype, "depthPrepass", {
        /**
         *
         */
        get: function () {
            return this._depthPrepass;
        },
        set: function (value) {
            this._depthPrepass = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderer.prototype, "filters3d", {
        /**
         *
         * @returns {*}
         */
        get: function () {
            return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
        },
        set: function (value) {
            if (value && value.length == 0)
                value = null;
            if (this._pFilter3DRenderer && !value) {
                this._pFilter3DRenderer.dispose();
                this._pFilter3DRenderer = null;
            }
            else if (!this._pFilter3DRenderer && value) {
                this._pFilter3DRenderer = new Filter3DRenderer(this._pStage);
                this._pFilter3DRenderer.filters = value;
            }
            if (this._pFilter3DRenderer) {
                this._pFilter3DRenderer.filters = value;
                this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
            }
            else {
                this._pRequireDepthRender = false;
                if (this._pDepthRender) {
                    this._pDepthRender.dispose();
                    this._pDepthRender = null;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    DefaultRenderer.prototype.render = function (entityCollector) {
        _super.prototype.render.call(this, entityCollector);
        if (!this._pStage.recoverFromDisposal()) {
            this._pBackBufferInvalid = true;
            return;
        }
        if (this._pBackBufferInvalid)
            this.pUpdateBackBuffer();
        if (this._shareContext && this._pContext)
            this._pContext.clear(0, 0, 0, 1, 1, 0, ContextGLClearMask.DEPTH);
        if (this._pFilter3DRenderer) {
            this.textureRatioX = this._pRttBufferManager.textureRatioX;
            this.textureRatioY = this._pRttBufferManager.textureRatioY;
        }
        else {
            this.textureRatioX = 1;
            this.textureRatioY = 1;
        }
        if (this._pRequireDepthRender)
            this.pRenderSceneDepthToTexture(entityCollector);
        if (this._depthPrepass)
            this.pRenderDepthPrepass(entityCollector);
        if (this._pFilter3DRenderer && this._pContext) {
        }
        else {
            if (this._shareContext)
                this._iRender(entityCollector, null, this._pScissorRect);
            else
                this._iRender(entityCollector);
        }
        _super.prototype.render.call(this, entityCollector);
        if (!this._shareContext && this._pContext)
            this._pContext.present();
        // register that a view has been rendered
        this._pStage.bufferClear = false;
    };
    DefaultRenderer.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
        if (target === void 0) { target = null; }
        if (scissorRect === void 0) { scissorRect = null; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        this.updateLights(entityCollector);
        // otherwise RTT will interfere with other RTTs
        if (target) {
            this.pCollectRenderables(entityCollector);
            this.drawRenderables(this._pOpaqueRenderableHead, entityCollector);
            this.drawRenderables(this._pBlendedRenderableHead, entityCollector);
        }
        _super.prototype.pExecuteRender.call(this, entityCollector, target, scissorRect, surfaceSelector);
    };
    DefaultRenderer.prototype.updateLights = function (entityCollector) {
        var dirLights = entityCollector.directionalLights;
        var pointLights = entityCollector.pointLights;
        var len, i;
        var light;
        var shadowMapper;
        len = dirLights.length;
        for (i = 0; i < len; ++i) {
            light = dirLights[i];
            shadowMapper = light.shadowMapper;
            if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                shadowMapper.iRenderDepthMap(entityCollector, this._pDepthRenderer);
        }
        len = pointLights.length;
        for (i = 0; i < len; ++i) {
            light = pointLights[i];
            shadowMapper = light.shadowMapper;
            if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                shadowMapper.iRenderDepthMap(entityCollector, this._pDistanceRenderer);
        }
    };
    /**
     * @inheritDoc
     */
    DefaultRenderer.prototype.pDraw = function (entityCollector, target) {
        if (!target)
            this.pCollectRenderables(entityCollector);
        this._pContext.setBlendFactors(ContextGLBlendFactor.ONE, ContextGLBlendFactor.ZERO);
        if (entityCollector.skyBox) {
            this._pContext.setDepthTest(false, ContextGLCompareMode.ALWAYS);
            this.drawSkybox(entityCollector);
        }
        this._pContext.setDepthTest(true, ContextGLCompareMode.LESS_EQUAL);
        this.drawRenderables(this._pOpaqueRenderableHead, entityCollector);
        this.drawRenderables(this._pBlendedRenderableHead, entityCollector);
    };
    /**
     * Draw the skybox if present.
     *
     * @param entityCollector The EntityCollector containing all potentially visible information.
     */
    DefaultRenderer.prototype.drawSkybox = function (entityCollector) {
        var skyBox = this._skyboxRenderablePool.getItem(entityCollector.skyBox);
        var material = entityCollector.skyBox.material;
        var camera = entityCollector.camera;
        this.updateSkyboxProjection(camera);
        var activePass = this._pStage.context.getMaterial(material, this._pStage.profile).getMaterialPass(material._iScreenPasses[0], this._pStage.profile);
        material._iActivatePass(activePass, this._pStage, camera);
        material._iRenderPass(activePass, skyBox, this._pStage, camera, this._skyboxProjection);
        material._iDeactivatePass(activePass, this._pStage);
    };
    DefaultRenderer.prototype.updateSkyboxProjection = function (camera) {
        var near = new Vector3D();
        this._skyboxProjection.copyFrom(this._pRttViewProjectionMatrix);
        this._skyboxProjection.copyRowTo(2, near);
        var camPos = camera.scenePosition;
        var cx = near.x;
        var cy = near.y;
        var cz = near.z;
        var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));
        var signX = cx >= 0 ? 1 : -1;
        var signY = cy >= 0 ? 1 : -1;
        var p = new Vector3D(signX, signY, 1, 1);
        var inverse = this._skyboxProjection.clone();
        inverse.invert();
        var q = inverse.transformVector(p);
        this._skyboxProjection.copyRowTo(3, p);
        var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
        this._skyboxProjection.copyRowFrom(2, new Vector3D(cx * a, cy * a, cz * a, cw * a));
    };
    /**
     * Draw a list of renderables.
     *
     * @param renderables The renderables to draw.
     * @param entityCollector The EntityCollector containing all potentially visible information.
     */
    DefaultRenderer.prototype.drawRenderables = function (renderable, entityCollector) {
        var i;
        var len;
        var passes;
        var activePass;
        var activeMaterial;
        var context = this._pStage.context;
        var camera = entityCollector.camera;
        var renderable2;
        while (renderable) {
            activeMaterial = context.getMaterial(renderable.material, this._pStage.profile);
            //iterate through each screen pass
            passes = renderable.material._iScreenPasses;
            len = renderable.material._iNumScreenPasses();
            for (i = 0; i < len; i++) {
                renderable2 = renderable;
                activePass = activeMaterial.getMaterialPass(passes[i], this._pStage.profile);
                renderable.material._iActivatePass(activePass, this._pStage, camera);
                do {
                    renderable.material._iRenderPass(activePass, renderable2, this._pStage, camera, this._pRttViewProjectionMatrix);
                    renderable2 = renderable2.next;
                } while (renderable2 && renderable2.material == renderable.material);
                activeMaterial.material._iDeactivatePass(activePass, this._pStage);
            }
            renderable = renderable2;
        }
    };
    DefaultRenderer.prototype.dispose = function () {
        if (!this._shareContext)
            this._pStage.dispose();
        this._pDepthRenderer.dispose();
        this._pDistanceRenderer.dispose();
        this._pDepthRenderer = null;
        this._pDistanceRenderer = null;
        this._pDepthRender = null;
        _super.prototype.dispose.call(this);
    };
    /**
     *
     */
    DefaultRenderer.prototype.pRenderDepthPrepass = function (entityCollector) {
        this._pDepthRenderer.disableColor = true;
        if (this._pFilter3DRenderer) {
        }
        else {
            this._pDepthRenderer.textureRatioX = 1;
            this._pDepthRenderer.textureRatioY = 1;
            this._pDepthRenderer._iRender(entityCollector);
        }
        this._pDepthRenderer.disableColor = false;
    };
    /**
     *
     */
    DefaultRenderer.prototype.pRenderSceneDepthToTexture = function (entityCollector) {
        if (this._pDepthTextureInvalid || !this._pDepthRender)
            this.initDepthTexture(this._pStage.context);
        this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
        this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
        this._pDepthRenderer._iRender(entityCollector, this._pDepthRender);
    };
    /**
     * Updates the backbuffer dimensions.
     */
    DefaultRenderer.prototype.pUpdateBackBuffer = function () {
        // No reason trying to configure back buffer if there is no context available.
        // Doing this anyway (and relying on _stage to cache width/height for
        // context does get available) means usesSoftwareRendering won't be reliable.
        if (this._pStage.context && !this._shareContext) {
            if (this._width && this._height) {
                this._pStage.configureBackBuffer(this._width, this._height, this._antiAlias, true);
                this._pBackBufferInvalid = false;
            }
        }
    };
    DefaultRenderer.prototype.iSetStage = function (value) {
        _super.prototype.iSetStage.call(this, value);
        this._pDistanceRenderer.iSetStage(value);
        this._pDepthRenderer.iSetStage(value);
    };
    /**
     *
     */
    DefaultRenderer.prototype.initDepthTexture = function (context) {
        this._pDepthTextureInvalid = false;
        if (this._pDepthRender)
            this._pDepthRender.dispose();
        this._pDepthRender = new RenderTexture(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight);
    };
    return DefaultRenderer;
})(RendererBase);
module.exports = DefaultRenderer;


},{"awayjs-core/lib/geom/Matrix3D":446,"awayjs-core/lib/geom/Vector3D":451,"awayjs-core/lib/textures/RenderTexture":456,"awayjs-display/lib/pool/RenderablePool":506,"awayjs-stagegl/lib/base/ContextGLBlendFactor":352,"awayjs-stagegl/lib/base/ContextGLClearMask":353,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/managers/RTTBufferManager":381,"awayjs-stagegl/lib/managers/StageManager":382,"awayjs-stagegl/lib/materials/passes/DepthMapPass":406,"awayjs-stagegl/lib/materials/passes/DistanceMapPass":407,"awayjs-stagegl/lib/pool/SkyboxRenderable":426,"awayjs-stagegl/lib/render/DepthRenderer":433,"awayjs-stagegl/lib/render/Filter3DRenderer":434,"awayjs-stagegl/lib/render/RendererBase":435}],433:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RendererBase = require("awayjs-stagegl/lib/render/RendererBase");
var ContextGLBlendFactor = require("awayjs-stagegl/lib/base/ContextGLBlendFactor");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
/**
 * The DepthRenderer class renders 32-bit depth information encoded as RGBA
 *
 * @class away.render.DepthRenderer
 */
var DepthRenderer = (function (_super) {
    __extends(DepthRenderer, _super);
    /**
     * Creates a new DepthRenderer object.
     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
     */
    function DepthRenderer(pass, renderBlended) {
        if (renderBlended === void 0) { renderBlended = false; }
        _super.call(this);
        this._pass = pass;
        this._renderBlended = renderBlended;
        this._iBackgroundR = 1;
        this._iBackgroundG = 1;
        this._iBackgroundB = 1;
    }
    Object.defineProperty(DepthRenderer.prototype, "disableColor", {
        get: function () {
            return this._disableColor;
        },
        set: function (value) {
            this._disableColor = value;
        },
        enumerable: true,
        configurable: true
    });
    DepthRenderer.prototype._iRenderCascades = function (entityCollector, target, numCascades, scissorRects, cameras) {
        this.pCollectRenderables(entityCollector);
        this._pContext.setRenderTarget(target, true, 0);
        this._pContext.clear(1, 1, 1, 1, 1, 0);
        this._pContext.setBlendFactors(ContextGLBlendFactor.ONE, ContextGLBlendFactor.ZERO);
        this._pContext.setDepthTest(true, ContextGLCompareMode.LESS);
        var head = this._pOpaqueRenderableHead;
        var first = true;
        for (var i = numCascades - 1; i >= 0; --i) {
            this._pStage.scissorRect = scissorRects[i];
            this.drawCascadeRenderables(head, cameras[i], first ? null : cameras[i].frustumPlanes);
            first = false;
        }
        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
        this._pContext.setDepthTest(false, ContextGLCompareMode.LESS_EQUAL);
        this._pStage.scissorRect = null;
    };
    DepthRenderer.prototype.drawCascadeRenderables = function (renderable, camera, cullPlanes) {
        var activePass;
        var activeMaterial;
        var context = this._pStage.context;
        var renderable2;
        while (renderable) {
            activeMaterial = context.getMaterial(renderable.material, this._pStage.profile);
            renderable2 = renderable;
            activePass = activeMaterial.getMaterialPass(this._pass, this._pStage.profile);
            //TODO: generalise this test
            if (activePass.key == "")
                this._pContext.calcAnimationCode(renderable.material, activePass);
            renderable.material._iActivatePass(activePass, this._pStage, camera);
            do {
                // if completely in front, it will fall in a different cascade
                // do not use near and far planes
                if (!cullPlanes || renderable2.sourceEntity.worldBounds.isInFrustum(cullPlanes, 4)) {
                    renderable2.material._iRenderPass(activePass, renderable2, this._pStage, camera, this._pRttViewProjectionMatrix);
                }
                else {
                    renderable2.cascaded = true;
                }
                renderable2 = renderable2.next;
            } while (renderable2 && renderable2.material == renderable.material && !renderable2.cascaded);
            renderable.material._iDeactivatePass(activePass, this._pStage);
            renderable = renderable2;
        }
    };
    /**
     * @inheritDoc
     */
    DepthRenderer.prototype.pDraw = function (entityCollector, target) {
        this.pCollectRenderables(entityCollector);
        this._pContext.setBlendFactors(ContextGLBlendFactor.ONE, ContextGLBlendFactor.ZERO);
        this._pContext.setDepthTest(true, ContextGLCompareMode.LESS);
        this.drawRenderables(this._pOpaqueRenderableHead, entityCollector);
        if (this._disableColor)
            this._pContext.setColorMask(false, false, false, false);
        if (this._renderBlended)
            this.drawRenderables(this._pBlendedRenderableHead, entityCollector);
        if (this._disableColor)
            this._pContext.setColorMask(true, true, true, true);
    };
    /**
     * Draw a list of renderables.
     * @param renderables The renderables to draw.
     * @param entityCollector The EntityCollector containing all potentially visible information.
     */
    DepthRenderer.prototype.drawRenderables = function (renderable, entityCollector) {
        var activePass;
        var activeMaterial;
        var context = this._pStage.context;
        var camera = entityCollector.camera;
        var renderable2;
        while (renderable) {
            activeMaterial = context.getMaterial(renderable.material, this._pStage.profile);
            // otherwise this would result in depth rendered anyway because fragment shader kil is ignored
            if (this._disableColor && renderable.material.alphaThreshold != 0) {
                renderable2 = renderable;
                do {
                    renderable2 = renderable2.next;
                } while (renderable2 && renderable2.material == renderable.material);
            }
            else {
                renderable2 = renderable;
                activePass = activeMaterial.getMaterialPass(this._pass, this._pStage.profile);
                //TODO: generalise this test
                if (activePass.key == "")
                    this._pContext.calcAnimationCode(renderable.material, activePass);
                renderable.material._iActivatePass(activePass, this._pStage, camera);
                do {
                    renderable2.material._iRenderPass(activePass, renderable2, this._pStage, camera, this._pRttViewProjectionMatrix);
                    renderable2 = renderable2.next;
                } while (renderable2 && renderable2.material == renderable.material);
                renderable.material._iDeactivatePass(activePass, this._pStage);
            }
            renderable = renderable2;
        }
    };
    return DepthRenderer;
})(RendererBase);
module.exports = DepthRenderer;


},{"awayjs-stagegl/lib/base/ContextGLBlendFactor":352,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/render/RendererBase":435}],434:[function(require,module,exports){
var Event = require("awayjs-core/lib/events/Event");
var ContextGLBlendFactor = require("awayjs-stagegl/lib/base/ContextGLBlendFactor");
var ContextGLVertexBufferFormat = require("awayjs-stagegl/lib/base/ContextGLVertexBufferFormat");
var RTTBufferManager = require("awayjs-stagegl/lib/managers/RTTBufferManager");
/**
 * @class away.render.Filter3DRenderer
 */
var Filter3DRenderer = (function () {
    function Filter3DRenderer(stage) {
        var _this = this;
        this._filterSizesInvalid = true;
        this._onRTTResizeDelegate = function (event) { return _this.onRTTResize(event); };
        this._stage = stage;
        this._rttManager = RTTBufferManager.getInstance(stage);
        this._rttManager.addEventListener(Event.RESIZE, this._onRTTResizeDelegate);
    }
    Filter3DRenderer.prototype.onRTTResize = function (event) {
        this._filterSizesInvalid = true;
    };
    Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
        get: function () {
            return this._requireDepthRender;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DRenderer.prototype.getMainInputTexture = function (stage) {
        if (this._filterTasksInvalid) {
            this.updateFilterTasks(stage);
        }
        return this._mainInputTexture;
    };
    Object.defineProperty(Filter3DRenderer.prototype, "filters", {
        get: function () {
            return this._filters;
        },
        set: function (value) {
            this._filters = value;
            this._filterTasksInvalid = true;
            this._requireDepthRender = false;
            if (!this._filters) {
                return;
            }
            for (var i = 0; i < this._filters.length; ++i) {
                // TODO: check logic:
                // this._requireDepthRender ||=  Boolean ( this._filters[i].requireDepthRender )
                var s = this._filters[i];
                var b = (s.requireDepthRender == null) ? false : s.requireDepthRender;
                this._requireDepthRender = this._requireDepthRender || b;
            }
            this._filterSizesInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DRenderer.prototype.updateFilterTasks = function (stage) {
        var len;
        if (this._filterSizesInvalid) {
            this.updateFilterSizes();
        }
        if (!this._filters) {
            this._tasks = null;
            return;
        }
        this._tasks = new Array();
        len = this._filters.length - 1;
        var filter;
        for (var i = 0; i <= len; ++i) {
            // make sure all internal tasks are linked together
            filter = this._filters[i];
            // TODO: check logic
            // filter.setRenderTargets(i == len? null : Filter3DBase(_filters[i + 1]).getMainInputTexture(stage), stage);
            filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stage), stage);
            this._tasks = this._tasks.concat(filter.tasks);
        }
        this._mainInputTexture = this._filters[0].getMainInputTexture(stage);
    };
    Filter3DRenderer.prototype.render = function (stage, camera, depthTexture) {
        var len;
        var i;
        var task;
        var context = stage.context;
        var indexBuffer = this._rttManager.indexBuffer;
        var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;
        if (!this._filters) {
            return;
        }
        if (this._filterSizesInvalid) {
            this.updateFilterSizes();
        }
        if (this._filterTasksInvalid) {
            this.updateFilterTasks(stage);
        }
        len = this._filters.length;
        for (i = 0; i < len; ++i) {
            this._filters[i].update(stage, camera);
        }
        len = this._tasks.length;
        if (len > 1) {
            context.setVertexBufferAt(0, vertexBuffer, 0, ContextGLVertexBufferFormat.FLOAT_2);
            context.setVertexBufferAt(1, vertexBuffer, 2, ContextGLVertexBufferFormat.FLOAT_2);
        }
        for (i = 0; i < len; ++i) {
            task = this._tasks[i];
            //stage.setRenderTarget(task.target); //TODO
            if (!task.target) {
                stage.scissorRect = null;
                vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
                context.setVertexBufferAt(0, vertexBuffer, 0, ContextGLVertexBufferFormat.FLOAT_2);
                context.setVertexBufferAt(1, vertexBuffer, 2, ContextGLVertexBufferFormat.FLOAT_2);
            }
            context.setTextureAt(0, task.getMainInputTexture(stage));
            context.setProgram(task.getProgram(stage));
            context.clear(0.0, 0.0, 0.0, 0.0);
            task.activate(stage, camera, depthTexture);
            context.setBlendFactors(ContextGLBlendFactor.ONE, ContextGLBlendFactor.ZERO);
            context.drawTriangles(indexBuffer, 0, 2);
            task.deactivate(stage);
        }
        context.setTextureAt(0, null);
        context.setVertexBufferAt(0, null);
        context.setVertexBufferAt(1, null);
    };
    Filter3DRenderer.prototype.updateFilterSizes = function () {
        for (var i = 0; i < this._filters.length; ++i) {
            this._filters[i].textureWidth = this._rttManager.textureWidth;
            this._filters[i].textureHeight = this._rttManager.textureHeight;
        }
        this._filterSizesInvalid = true;
    };
    Filter3DRenderer.prototype.dispose = function () {
        this._rttManager.removeEventListener(Event.RESIZE, this._onRTTResizeDelegate);
        this._rttManager = null;
        this._stage = null;
    };
    return Filter3DRenderer;
})();
module.exports = Filter3DRenderer;


},{"awayjs-core/lib/events/Event":442,"awayjs-stagegl/lib/base/ContextGLBlendFactor":352,"awayjs-stagegl/lib/base/ContextGLVertexBufferFormat":361,"awayjs-stagegl/lib/managers/RTTBufferManager":381}],435:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Matrix3D = require("awayjs-core/lib/geom/Matrix3D");
var Point = require("awayjs-core/lib/geom/Point");
var Rectangle = require("awayjs-core/lib/geom/Rectangle");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var EventDispatcher = require("awayjs-core/lib/events/EventDispatcher");
var RenderablePool = require("awayjs-display/lib/pool/RenderablePool");
var RenderableMergeSort = require("awayjs-display/lib/sort/RenderableMergeSort");
var RendererEvent = require("awayjs-display/lib/events/RendererEvent");
var StageEvent = require("awayjs-display/lib/events/StageEvent");
var EntityCollector = require("awayjs-display/lib/traverse/EntityCollector");
var BillboardRenderable = require("awayjs-stagegl/lib/pool/BillboardRenderable");
var LineSubMeshRenderable = require("awayjs-stagegl/lib/pool/LineSubMeshRenderable");
var TriangleSubMeshRenderable = require("awayjs-stagegl/lib/pool/TriangleSubMeshRenderable");
var ContextGLCompareMode = require("awayjs-stagegl/lib/base/ContextGLCompareMode");
var DefaultMaterialManager = require("awayjs-stagegl/lib/materials/utils/DefaultMaterialManager");
/**
 * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render the
 * contents of a partition
 *
 * @class away.render.RendererBase
 */
var RendererBase = (function (_super) {
    __extends(RendererBase, _super);
    /**
     * Creates a new RendererBase object.
     */
    function RendererBase() {
        var _this = this;
        _super.call(this);
        this._viewPort = new Rectangle();
        this._pBackBufferInvalid = true;
        this._pDepthTextureInvalid = true;
        this._depthPrepass = false;
        this._backgroundR = 0;
        this._backgroundG = 0;
        this._backgroundB = 0;
        this._backgroundAlpha = 1;
        this._shareContext = false;
        this.textureRatioX = 1;
        this.textureRatioY = 1;
        this._pRttViewProjectionMatrix = new Matrix3D();
        this._localPos = new Point();
        this._globalPos = new Point();
        this._pScissorRect = new Rectangle();
        this._pNumTriangles = 0;
        this._onViewportUpdatedDelegate = function (event) { return _this.onViewportUpdated(event); };
        this._billboardRenderablePool = RenderablePool.getPool(BillboardRenderable);
        this._triangleSubMeshRenderablePool = RenderablePool.getPool(TriangleSubMeshRenderable);
        this._lineSubMeshRenderablePool = RenderablePool.getPool(LineSubMeshRenderable);
        this._onContextUpdateDelegate = function (event) { return _this.onContextUpdate(event); };
        //default sorting algorithm
        this.renderableSorter = new RenderableMergeSort();
    }
    Object.defineProperty(RendererBase.prototype, "numTriangles", {
        /**
         *
         */
        get: function () {
            return this._pNumTriangles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "viewPort", {
        /**
         * A viewPort rectangle equivalent of the Stage size and position.
         */
        get: function () {
            return this._viewPort;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "scissorRect", {
        /**
         * A scissor rectangle equivalent of the view size and position.
         */
        get: function () {
            return this._pScissorRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "x", {
        /**
         *
         */
        get: function () {
            return this._localPos.x;
        },
        set: function (value) {
            if (this.x == value)
                return;
            this._globalPos.x = this._localPos.x = value;
            this.updateGlobalPos();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "y", {
        /**
         *
         */
        get: function () {
            return this._localPos.y;
        },
        set: function (value) {
            if (this.y == value)
                return;
            this._globalPos.y = this._localPos.y = value;
            this.updateGlobalPos();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "width", {
        /**
         *
         */
        get: function () {
            return this._width;
        },
        set: function (value) {
            if (this._width == value)
                return;
            this._width = value;
            this._pScissorRect.width = value;
            if (this._pRttBufferManager)
                this._pRttBufferManager.viewWidth = value;
            this._pBackBufferInvalid = true;
            this._pDepthTextureInvalid = true;
            this.notifyScissorUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "height", {
        /**
         *
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            if (this._height == value)
                return;
            this._height = value;
            this._pScissorRect.height = value;
            if (this._pRttBufferManager)
                this._pRttBufferManager.viewHeight = value;
            this._pBackBufferInvalid = true;
            this._pDepthTextureInvalid = true;
            this.notifyScissorUpdate();
        },
        enumerable: true,
        configurable: true
    });
    RendererBase.prototype._iCreateEntityCollector = function () {
        return new EntityCollector();
    };
    Object.defineProperty(RendererBase.prototype, "_iBackgroundR", {
        /**
         * The background color's red component, used when clearing.
         *
         * @private
         */
        get: function () {
            return this._backgroundR;
        },
        set: function (value) {
            if (this._backgroundR == value)
                return;
            this._backgroundR = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "_iBackgroundG", {
        /**
         * The background color's green component, used when clearing.
         *
         * @private
         */
        get: function () {
            return this._backgroundG;
        },
        set: function (value) {
            if (this._backgroundG == value)
                return;
            this._backgroundG = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "_iBackgroundB", {
        /**
         * The background color's blue component, used when clearing.
         *
         * @private
         */
        get: function () {
            return this._backgroundB;
        },
        set: function (value) {
            if (this._backgroundB == value)
                return;
            this._backgroundB = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "stage", {
        /**
         * The Stage that will provide the ContextGL used for rendering.
         */
        get: function () {
            return this._pStage;
        },
        set: function (value) {
            if (value == this._pStage)
                return;
            this.iSetStage(value);
        },
        enumerable: true,
        configurable: true
    });
    RendererBase.prototype.iSetStage = function (value) {
        if (this._pStage) {
            this._pStage.removeEventListener(StageEvent.CONTEXT_CREATED, this._onContextUpdateDelegate);
            this._pStage.removeEventListener(StageEvent.CONTEXT_RECREATED, this._onContextUpdateDelegate);
            this._pStage.removeEventListener(StageEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
        }
        if (!value) {
            this._pStage = null;
            this._pContext = null;
        }
        else {
            this._pStage = value;
            this._pStage.addEventListener(StageEvent.CONTEXT_CREATED, this._onContextUpdateDelegate);
            this._pStage.addEventListener(StageEvent.CONTEXT_RECREATED, this._onContextUpdateDelegate);
            this._pStage.addEventListener(StageEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
            /*
             if (_backgroundImageRenderer)
             _backgroundImageRenderer.stage = value;
             */
            if (this._pStage.context)
                this._pContext = this._pStage.context;
        }
        this._pBackBufferInvalid = true;
        this.updateGlobalPos();
    };
    Object.defineProperty(RendererBase.prototype, "shareContext", {
        /**
         * Defers control of ContextGL clear() and present() calls to Stage, enabling multiple Stage frameworks
         * to share the same ContextGL object.
         */
        get: function () {
            return this._shareContext;
        },
        set: function (value) {
            if (this._shareContext == value)
                return;
            this._shareContext = value;
            this.updateGlobalPos();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the resources used by the RendererBase.
     */
    RendererBase.prototype.dispose = function () {
        if (this._pRttBufferManager)
            this._pRttBufferManager.dispose();
        this._pRttBufferManager = null;
        this._pStage.removeEventListener(StageEvent.CONTEXT_CREATED, this._onContextUpdateDelegate);
        this._pStage.removeEventListener(StageEvent.CONTEXT_RECREATED, this._onContextUpdateDelegate);
        this._pStage.removeEventListener(StageEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
        this._pStage = null;
        /*
         if (_backgroundImageRenderer) {
         _backgroundImageRenderer.dispose();
         _backgroundImageRenderer = null;
         }
         */
    };
    RendererBase.prototype.render = function (entityCollector) {
        this._viewportDirty = false;
        this._scissorDirty = false;
    };
    /**
     * Renders the potentially visible geometry to the back buffer or texture.
     * @param entityCollector The EntityCollector object containing the potentially visible geometry.
     * @param target An option target texture to render to.
     * @param surfaceSelector The index of a CubeTexture's face to render to.
     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
     */
    RendererBase.prototype._iRender = function (entityCollector, target, scissorRect, surfaceSelector) {
        if (target === void 0) { target = null; }
        if (scissorRect === void 0) { scissorRect = null; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        //TODO refactor setTarget so that rendertextures are created before this check
        if (!this._pStage || !this._pContext)
            return;
        this._pRttViewProjectionMatrix.copyFrom(entityCollector.camera.viewProjection);
        this._pRttViewProjectionMatrix.appendScale(this.textureRatioX, this.textureRatioY, 1);
        this.pExecuteRender(entityCollector, target, scissorRect, surfaceSelector);
        for (var i = 0; i < 8; ++i) {
            this._pContext.setVertexBufferAt(i, null);
            this._pContext.setTextureAt(i, null);
        }
    };
    RendererBase.prototype._iRenderCascades = function (entityCollector, target, numCascades, scissorRects, cameras) {
    };
    RendererBase.prototype.pCollectRenderables = function (entityCollector) {
        //reset head values
        this._pBlendedRenderableHead = null;
        this._pOpaqueRenderableHead = null;
        this._pNumTriangles = 0;
        //grab entity head
        var item = entityCollector.entityHead;
        //set temp values for entry point and camera forward vector
        this._pCamera = entityCollector.camera;
        this._iEntryPoint = this._pCamera.scenePosition;
        this._pCameraForward = this._pCamera.transform.forwardVector;
        while (item) {
            item.entity._iCollectRenderables(this);
            item = item.next;
        }
        //sort the resulting renderables
        this._pOpaqueRenderableHead = this.renderableSorter.sortOpaqueRenderables(this._pOpaqueRenderableHead);
        this._pBlendedRenderableHead = this.renderableSorter.sortBlendedRenderables(this._pBlendedRenderableHead);
    };
    /**
     * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
     *
     * @param entityCollector The EntityCollector object containing the potentially visible geometry.
     * @param target An option target texture to render to.
     * @param surfaceSelector The index of a CubeTexture's face to render to.
     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
     */
    RendererBase.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
        if (target === void 0) { target = null; }
        if (scissorRect === void 0) { scissorRect = null; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        this._pContext.setRenderTarget(target, true, surfaceSelector);
        if ((target || !this._shareContext) && !this._depthPrepass)
            this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
        this._pContext.setDepthTest(false, ContextGLCompareMode.ALWAYS);
        this._pStage.scissorRect = scissorRect;
        /*
         if (_backgroundImageRenderer)
         _backgroundImageRenderer.render();
         */
        this.pDraw(entityCollector, target);
        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
        //this._pContext.setDepthTest(false, ContextGLCompareMode.LESS_EQUAL); //oopsie
        if (!this._shareContext) {
            if (this._snapshotRequired && this._snapshotBitmapData) {
                this._pContext.drawToBitmapData(this._snapshotBitmapData);
                this._snapshotRequired = false;
            }
        }
        this._pStage.scissorRect = null;
    };
    /*
     * Will draw the renderer's output on next render to the provided bitmap data.
     * */
    RendererBase.prototype.queueSnapshot = function (bmd) {
        this._snapshotRequired = true;
        this._snapshotBitmapData = bmd;
    };
    /**
     * Performs the actual drawing of geometry to the target.
     * @param entityCollector The EntityCollector object containing the potentially visible geometry.
     */
    RendererBase.prototype.pDraw = function (entityCollector, target) {
        throw new AbstractMethodError();
    };
    /**
     * Assign the context once retrieved
     */
    RendererBase.prototype.onContextUpdate = function (event) {
        this._pContext = this._pStage.context;
    };
    Object.defineProperty(RendererBase.prototype, "_iBackgroundAlpha", {
        get: function () {
            return this._backgroundAlpha;
        },
        set: function (value) {
            if (this._backgroundAlpha == value)
                return;
            this._backgroundAlpha = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    /*
     public get iBackground():Texture2DBase
     {
     return this._background;
     }
     */
    /*
     public set iBackground(value:Texture2DBase)
     {
     if (this._backgroundImageRenderer && !value) {
     this._backgroundImageRenderer.dispose();
     this._backgroundImageRenderer = null;
     }

     if (!this._backgroundImageRenderer && value)
     {

     this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStage);

     }


     this._background = value;

     if (this._backgroundImageRenderer)
     this._backgroundImageRenderer.texture = value;
     }
     */
    /*
     public get backgroundImageRenderer():BackgroundImageRenderer
     {
     return _backgroundImageRenderer;
     }
     */
    /**
     * @private
     */
    RendererBase.prototype.notifyScissorUpdate = function () {
        if (this._scissorDirty)
            return;
        this._scissorDirty = true;
        if (!this._scissorUpdated)
            this._scissorUpdated = new RendererEvent(RendererEvent.SCISSOR_UPDATED);
        this.dispatchEvent(this._scissorUpdated);
    };
    /**
     * @private
     */
    RendererBase.prototype.notifyViewportUpdate = function () {
        if (this._viewportDirty)
            return;
        this._viewportDirty = true;
        if (!this._viewPortUpdated)
            this._viewPortUpdated = new RendererEvent(RendererEvent.VIEWPORT_UPDATED);
        this.dispatchEvent(this._viewPortUpdated);
    };
    /**
     *
     */
    RendererBase.prototype.onViewportUpdated = function (event) {
        this._viewPort = this._pStage.viewPort;
        //TODO stop firing viewport updated for every stagegl viewport change
        if (this._shareContext) {
            this._pScissorRect.x = this._globalPos.x - this._pStage.x;
            this._pScissorRect.y = this._globalPos.y - this._pStage.y;
            this.notifyScissorUpdate();
        }
        this.notifyViewportUpdate();
    };
    /**
     *
     */
    RendererBase.prototype.updateGlobalPos = function () {
        if (this._shareContext) {
            this._pScissorRect.x = this._globalPos.x - this._viewPort.x;
            this._pScissorRect.y = this._globalPos.y - this._viewPort.y;
        }
        else {
            this._pScissorRect.x = 0;
            this._pScissorRect.y = 0;
            this._viewPort.x = this._globalPos.x;
            this._viewPort.y = this._globalPos.y;
        }
        this.notifyScissorUpdate();
    };
    /**
     *
     * @param billboard
     * @protected
     */
    RendererBase.prototype.applyBillboard = function (billboard) {
        this._applyRenderable(this._billboardRenderablePool.getItem(billboard));
    };
    /**
     *
     * @param triangleSubMesh
     */
    RendererBase.prototype.applyTriangleSubMesh = function (triangleSubMesh) {
        this._applyRenderable(this._triangleSubMeshRenderablePool.getItem(triangleSubMesh));
    };
    /**
     *
     * @param lineSubMesh
     */
    RendererBase.prototype.applyLineSubMesh = function (lineSubMesh) {
        this._applyRenderable(this._lineSubMeshRenderablePool.getItem(lineSubMesh));
    };
    /**
     *
     * @param renderable
     * @protected
     */
    RendererBase.prototype._applyRenderable = function (renderable) {
        var material = renderable.materialOwner.material;
        var entity = renderable.sourceEntity;
        var position = entity.scenePosition;
        if (!material)
            material = DefaultMaterialManager.getDefaultMaterial(renderable.materialOwner);
        //update material if invalidated
        material._iUpdateMaterial();
        //set ids for faster referencing
        renderable.material = material;
        renderable.materialId = material._iMaterialId;
        renderable.renderOrderId = this._pContext.getMaterial(material, this._pStage.profile).renderOrderId;
        renderable.cascaded = false;
        // project onto camera's z-axis
        position = this._iEntryPoint.subtract(position);
        renderable.zIndex = entity.zOffset + position.dotProduct(this._pCameraForward);
        //store reference to scene transform
        renderable.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this._pCamera);
        if (material.requiresBlending) {
            renderable.next = this._pBlendedRenderableHead;
            this._pBlendedRenderableHead = renderable;
        }
        else {
            renderable.next = this._pOpaqueRenderableHead;
            this._pOpaqueRenderableHead = renderable;
        }
        this._pNumTriangles += renderable.numTriangles;
        //handle any overflow for renderables with data that exceeds GPU limitations
        if (renderable.overflow)
            this._applyRenderable(renderable.overflow);
    };
    return RendererBase;
})(EventDispatcher);
module.exports = RendererBase;


},{"awayjs-core/lib/errors/AbstractMethodError":438,"awayjs-core/lib/events/EventDispatcher":443,"awayjs-core/lib/geom/Matrix3D":446,"awayjs-core/lib/geom/Point":449,"awayjs-core/lib/geom/Rectangle":450,"awayjs-display/lib/events/RendererEvent":486,"awayjs-display/lib/events/StageEvent":488,"awayjs-display/lib/pool/RenderablePool":506,"awayjs-display/lib/sort/RenderableMergeSort":507,"awayjs-display/lib/traverse/EntityCollector":509,"awayjs-stagegl/lib/base/ContextGLCompareMode":354,"awayjs-stagegl/lib/materials/utils/DefaultMaterialManager":413,"awayjs-stagegl/lib/pool/BillboardRenderable":415,"awayjs-stagegl/lib/pool/LineSubMeshRenderable":418,"awayjs-stagegl/lib/pool/TriangleSubMeshRenderable":429}],436:[function(require,module,exports){
/*!	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/

var swfobject = function() {
	
	var UNDEF = "undefined",
		OBJECT = "object",
		SHOCKWAVE_FLASH = "Shockwave Flash",
		SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
		FLASH_MIME_TYPE = "application/x-shockwave-flash",
		EXPRESS_INSTALL_ID = "SWFObjectExprInst",
		ON_READY_STATE_CHANGE = "onreadystatechange",
		
		win = window,
		doc = document,
		nav = navigator,
		
		plugin = false,
		domLoadFnArr = [main],
		regObjArr = [],
		objIdArr = [],
		listenersArr = [],
		storedAltContent,
		storedAltContentId,
		storedCallbackFn,
		storedCallbackObj,
		isDomLoaded = false,
		isExpressInstallActive = false,
		dynamicStylesheet,
		dynamicStylesheetMedia,
		autoHideShow = true,
	
	/* Centralized function for browser feature detection
		- User agent string detection is only used when no good alternative is possible
		- Is executed directly for optimal performance
	*/	
	ua = function() {
		var w3cdom = typeof doc.getElementById != UNDEF && typeof doc.getElementsByTagName != UNDEF && typeof doc.createElement != UNDEF,
			u = nav.userAgent.toLowerCase(),
			p = nav.platform.toLowerCase(),
			windows = p ? /win/.test(p) : /win/.test(u),
			mac = p ? /mac/.test(p) : /mac/.test(u),
			webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, // returns either the webkit version or false if not webkit
			ie = !+"\v1", // feature detection based on Andrea Giammarchi's solution: http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
			playerVersion = [0,0,0],
			d = null;
		if (typeof nav.plugins != UNDEF && typeof nav.plugins[SHOCKWAVE_FLASH] == OBJECT) {
			d = nav.plugins[SHOCKWAVE_FLASH].description;
			if (d && !(typeof nav.mimeTypes != UNDEF && nav.mimeTypes[FLASH_MIME_TYPE] && !nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) { // navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
				plugin = true;
				ie = false; // cascaded feature detection for Internet Explorer
				d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
				playerVersion[0] = parseInt(d.replace(/^(.*)\..*$/, "$1"), 10);
				playerVersion[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
				playerVersion[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0;
			}
		}
		else if (typeof win.ActiveXObject != UNDEF) {
			try {
				var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
				if (a) { // a will return null when ActiveX is disabled
					d = a.GetVariable("$version");
					if (d) {
						ie = true; // cascaded feature detection for Internet Explorer
						d = d.split(" ")[1].split(",");
						playerVersion = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
					}
				}
			}
			catch(e) {}
		}
		return { w3:w3cdom, pv:playerVersion, wk:webkit, ie:ie, win:windows, mac:mac };
	}(),
	
	/* Cross-browser onDomLoad
		- Will fire an event as soon as the DOM of a web page is loaded
		- Internet Explorer workaround based on Diego Perini's solution: http://javascript.nwbox.com/IEContentLoaded/
		- Regular onload serves as fallback
	*/ 
	onDomLoad = function() {
		if (!ua.w3) { return; }
		if ((typeof doc.readyState != UNDEF && doc.readyState == "complete") || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body))) { // function is fired after onload, e.g. when script is inserted dynamically 
			callDomLoadFunctions();
		}
		if (!isDomLoaded) {
			if (typeof doc.addEventListener != UNDEF) {
				doc.addEventListener("DOMContentLoaded", callDomLoadFunctions, false);
			}		
			if (ua.ie && ua.win) {
				doc.attachEvent(ON_READY_STATE_CHANGE, function() {
					if (doc.readyState == "complete") {
						doc.detachEvent(ON_READY_STATE_CHANGE, arguments.callee);
						callDomLoadFunctions();
					}
				});
				if (win == top) { // if not inside an iframe
					(function(){
						if (isDomLoaded) { return; }
						try {
							doc.documentElement.doScroll("left");
						}
						catch(e) {
							setTimeout(arguments.callee, 0);
							return;
						}
						callDomLoadFunctions();
					})();
				}
			}
			if (ua.wk) {
				(function(){
					if (isDomLoaded) { return; }
					if (!/loaded|complete/.test(doc.readyState)) {
						setTimeout(arguments.callee, 0);
						return;
					}
					callDomLoadFunctions();
				})();
			}
			addLoadEvent(callDomLoadFunctions);
		}
	}();
	
	function callDomLoadFunctions() {
		if (isDomLoaded) { return; }
		try { // test if we can really add/remove elements to/from the DOM; we don't want to fire it too early
			var t = doc.getElementsByTagName("body")[0].appendChild(createElement("span"));
			t.parentNode.removeChild(t);
		}
		catch (e) { return; }
		isDomLoaded = true;
		var dl = domLoadFnArr.length;
		for (var i = 0; i < dl; i++) {
			domLoadFnArr[i]();
		}
	}
	
	function addDomLoadEvent(fn) {
		if (isDomLoaded) {
			fn();
		}
		else { 
			domLoadFnArr[domLoadFnArr.length] = fn; // Array.push() is only available in IE5.5+
		}
	}
	
	/* Cross-browser onload
		- Based on James Edwards' solution: http://brothercake.com/site/resources/scripts/onload/
		- Will fire an event as soon as a web page including all of its assets are loaded 
	 */
	function addLoadEvent(fn) {
		if (typeof win.addEventListener != UNDEF) {
			win.addEventListener("load", fn, false);
		}
		else if (typeof doc.addEventListener != UNDEF) {
			doc.addEventListener("load", fn, false);
		}
		else if (typeof win.attachEvent != UNDEF) {
			addListener(win, "onload", fn);
		}
		else if (typeof win.onload == "function") {
			var fnOld = win.onload;
			win.onload = function() {
				fnOld();
				fn();
			};
		}
		else {
			win.onload = fn;
		}
	}
	
	/* Main function
		- Will preferably execute onDomLoad, otherwise onload (as a fallback)
	*/
	function main() { 
		if (plugin) {
			testPlayerVersion();
		}
		else {
			matchVersions();
		}
	}
	
	/* Detect the Flash Player version for non-Internet Explorer browsers
		- Detecting the plug-in version via the object element is more precise than using the plugins collection item's description:
		  a. Both release and build numbers can be detected
		  b. Avoid wrong descriptions by corrupt installers provided by Adobe
		  c. Avoid wrong descriptions by multiple Flash Player entries in the plugin Array, caused by incorrect browser imports
		- Disadvantage of this method is that it depends on the availability of the DOM, while the plugins collection is immediately available
	*/
	function testPlayerVersion() {
		var b = doc.getElementsByTagName("body")[0];
		var o = createElement(OBJECT);
		o.setAttribute("type", FLASH_MIME_TYPE);
		var t = b.appendChild(o);
		if (t) {
			var counter = 0;
			(function(){
				if (typeof t.GetVariable != UNDEF) {
					var d = t.GetVariable("$version");
					if (d) {
						d = d.split(" ")[1].split(",");
						ua.pv = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
					}
				}
				else if (counter < 10) {
					counter++;
					setTimeout(arguments.callee, 10);
					return;
				}
				b.removeChild(o);
				t = null;
				matchVersions();
			})();
		}
		else {
			matchVersions();
		}
	}
	
	/* Perform Flash Player and SWF version matching; static publishing only
	*/
	function matchVersions() {
		var rl = regObjArr.length;
		if (rl > 0) {
			for (var i = 0; i < rl; i++) { // for each registered object element
				var id = regObjArr[i].id;
				var cb = regObjArr[i].callbackFn;
				var cbObj = {success:false, id:id};
				if (ua.pv[0] > 0) {
					var obj = getElementById(id);
					if (obj) {
						if (hasPlayerVersion(regObjArr[i].swfVersion) && !(ua.wk && ua.wk < 312)) { // Flash Player version >= published SWF version: Houston, we have a match!
							setVisibility(id, true);
							if (cb) {
								cbObj.success = true;
								cbObj.ref = getObjectById(id);
								cb(cbObj);
							}
						}
						else if (regObjArr[i].expressInstall && canExpressInstall()) { // show the Adobe Express Install dialog if set by the web page author and if supported
							var att = {};
							att.data = regObjArr[i].expressInstall;
							att.width = obj.getAttribute("width") || "0";
							att.height = obj.getAttribute("height") || "0";
							if (obj.getAttribute("class")) { att.styleclass = obj.getAttribute("class"); }
							if (obj.getAttribute("align")) { att.align = obj.getAttribute("align"); }
							// parse HTML object param element's name-value pairs
							var par = {};
							var p = obj.getElementsByTagName("param");
							var pl = p.length;
							for (var j = 0; j < pl; j++) {
								if (p[j].getAttribute("name").toLowerCase() != "movie") {
									par[p[j].getAttribute("name")] = p[j].getAttribute("value");
								}
							}
							showExpressInstall(att, par, id, cb);
						}
						else { // Flash Player and SWF version mismatch or an older Webkit engine that ignores the HTML object element's nested param elements: display alternative content instead of SWF
							displayAltContent(obj);
							if (cb) { cb(cbObj); }
						}
					}
				}
				else {	// if no Flash Player is installed or the fp version cannot be detected we let the HTML object element do its job (either show a SWF or alternative content)
					setVisibility(id, true);
					if (cb) {
						var o = getObjectById(id); // test whether there is an HTML object element or not
						if (o && typeof o.SetVariable != UNDEF) { 
							cbObj.success = true;
							cbObj.ref = o;
						}
						cb(cbObj);
					}
				}
			}
		}
	}
	
	function getObjectById(objectIdStr) {
		var r = null;
		var o = getElementById(objectIdStr);
		if (o && o.nodeName == "OBJECT") {
			if (typeof o.SetVariable != UNDEF) {
				r = o;
			}
			else {
				var n = o.getElementsByTagName(OBJECT)[0];
				if (n) {
					r = n;
				}
			}
		}
		return r;
	}
	
	/* Requirements for Adobe Express Install
		- only one instance can be active at a time
		- fp 6.0.65 or higher
		- Win/Mac OS only
		- no Webkit engines older than version 312
	*/
	function canExpressInstall() {
		return !isExpressInstallActive && hasPlayerVersion("6.0.65") && (ua.win || ua.mac) && !(ua.wk && ua.wk < 312);
	}
	
	/* Show the Adobe Express Install dialog
		- Reference: http://www.adobe.com/cfusion/knowledgebase/index.cfm?id=6a253b75
	*/
	function showExpressInstall(att, par, replaceElemIdStr, callbackFn) {
		isExpressInstallActive = true;
		storedCallbackFn = callbackFn || null;
		storedCallbackObj = {success:false, id:replaceElemIdStr};
		var obj = getElementById(replaceElemIdStr);
		if (obj) {
			if (obj.nodeName == "OBJECT") { // static publishing
				storedAltContent = abstractAltContent(obj);
				storedAltContentId = null;
			}
			else { // dynamic publishing
				storedAltContent = obj;
				storedAltContentId = replaceElemIdStr;
			}
			att.id = EXPRESS_INSTALL_ID;
			if (typeof att.width == UNDEF || (!/%$/.test(att.width) && parseInt(att.width, 10) < 310)) { att.width = "310"; }
			if (typeof att.height == UNDEF || (!/%$/.test(att.height) && parseInt(att.height, 10) < 137)) { att.height = "137"; }
			doc.title = doc.title.slice(0, 47) + " - Flash Player Installation";
			var pt = ua.ie && ua.win ? "ActiveX" : "PlugIn",
				fv = "MMredirectURL=" + encodeURI(window.location).toString().replace(/&/g,"%26") + "&MMplayerType=" + pt + "&MMdoctitle=" + doc.title;
			if (typeof par.flashvars != UNDEF) {
				par.flashvars += "&" + fv;
			}
			else {
				par.flashvars = fv;
			}
			// IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
			// because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
			if (ua.ie && ua.win && obj.readyState != 4) {
				var newObj = createElement("div");
				replaceElemIdStr += "SWFObjectNew";
				newObj.setAttribute("id", replaceElemIdStr);
				obj.parentNode.insertBefore(newObj, obj); // insert placeholder div that will be replaced by the object element that loads expressinstall.swf
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						obj.parentNode.removeChild(obj);
					}
					else {
						setTimeout(arguments.callee, 10);
					}
				})();
			}
			createSWF(att, par, replaceElemIdStr);
		}
	}
	
	/* Functions to abstract and display alternative content
	*/
	function displayAltContent(obj) {
		if (ua.ie && ua.win && obj.readyState != 4) {
			// IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
			// because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
			var el = createElement("div");
			obj.parentNode.insertBefore(el, obj); // insert placeholder div that will be replaced by the alternative content
			el.parentNode.replaceChild(abstractAltContent(obj), el);
			obj.style.display = "none";
			(function(){
				if (obj.readyState == 4) {
					obj.parentNode.removeChild(obj);
				}
				else {
					setTimeout(arguments.callee, 10);
				}
			})();
		}
		else {
			obj.parentNode.replaceChild(abstractAltContent(obj), obj);
		}
	} 

	function abstractAltContent(obj) {
		var ac = createElement("div");
		if (ua.win && ua.ie) {
			ac.innerHTML = obj.innerHTML;
		}
		else {
			var nestedObj = obj.getElementsByTagName(OBJECT)[0];
			if (nestedObj) {
				var c = nestedObj.childNodes;
				if (c) {
					var cl = c.length;
					for (var i = 0; i < cl; i++) {
						if (!(c[i].nodeType == 1 && c[i].nodeName == "PARAM") && !(c[i].nodeType == 8)) {
							ac.appendChild(c[i].cloneNode(true));
						}
					}
				}
			}
		}
		return ac;
	}
	
	/* Cross-browser dynamic SWF creation
	*/
	function createSWF(attObj, parObj, id) {
		var r, el = getElementById(id);
		if (ua.wk && ua.wk < 312) { return r; }
		if (el) {
			if (typeof attObj.id == UNDEF) { // if no 'id' is defined for the object element, it will inherit the 'id' from the alternative content
				attObj.id = id;
			}
			if (ua.ie && ua.win) { // Internet Explorer + the HTML object element + W3C DOM methods do not combine: fall back to outerHTML
				var att = "";
				for (var i in attObj) {
					if (attObj[i] != Object.prototype[i]) { // filter out prototype additions from other potential libraries
						if (i.toLowerCase() == "data") {
							parObj.movie = attObj[i];
						}
						else if (i.toLowerCase() == "styleclass") { // 'class' is an ECMA4 reserved keyword
							att += ' class="' + attObj[i] + '"';
						}
						else if (i.toLowerCase() != "classid") {
							att += ' ' + i + '="' + attObj[i] + '"';
						}
					}
				}
				var par = "";
				for (var j in parObj) {
					if (parObj[j] != Object.prototype[j]) { // filter out prototype additions from other potential libraries
						par += '<param name="' + j + '" value="' + parObj[j] + '" />';
					}
				}
				el.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + att + '>' + par + '</object>';
				objIdArr[objIdArr.length] = attObj.id; // stored to fix object 'leaks' on unload (dynamic publishing only)
				r = getElementById(attObj.id);	
			}
			else { // well-behaving browsers
				var o = createElement(OBJECT);
				o.setAttribute("type", FLASH_MIME_TYPE);
				for (var m in attObj) {
					if (attObj[m] != Object.prototype[m]) { // filter out prototype additions from other potential libraries
						if (m.toLowerCase() == "styleclass") { // 'class' is an ECMA4 reserved keyword
							o.setAttribute("class", attObj[m]);
						}
						else if (m.toLowerCase() != "classid") { // filter out IE specific attribute
							o.setAttribute(m, attObj[m]);
						}
					}
				}
				for (var n in parObj) {
					if (parObj[n] != Object.prototype[n] && n.toLowerCase() != "movie") { // filter out prototype additions from other potential libraries and IE specific param element
						createObjParam(o, n, parObj[n]);
					}
				}
				el.parentNode.replaceChild(o, el);
				r = o;
			}
		}
		return r;
	}
	
	function createObjParam(el, pName, pValue) {
		var p = createElement("param");
		p.setAttribute("name", pName);	
		p.setAttribute("value", pValue);
		el.appendChild(p);
	}
	
	/* Cross-browser SWF removal
		- Especially needed to safely and completely remove a SWF in Internet Explorer
	*/
	function removeSWF(id) {
		var obj = getElementById(id);
		if (obj && obj.nodeName == "OBJECT") {
			if (ua.ie && ua.win) {
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						removeObjectInIE(id);
					}
					else {
						setTimeout(arguments.callee, 10);
					}
				})();
			}
			else {
				obj.parentNode.removeChild(obj);
			}
		}
	}
	
	function removeObjectInIE(id) {
		var obj = getElementById(id);
		if (obj) {
			for (var i in obj) {
				if (typeof obj[i] == "function") {
					obj[i] = null;
				}
			}
			obj.parentNode.removeChild(obj);
		}
	}
	
	/* Functions to optimize JavaScript compression
	*/
	function getElementById(id) {
		var el = null;
		try {
			el = doc.getElementById(id);
		}
		catch (e) {}
		return el;
	}
	
	function createElement(el) {
		return doc.createElement(el);
	}
	
	/* Updated attachEvent function for Internet Explorer
		- Stores attachEvent information in an Array, so on unload the detachEvent functions can be called to avoid memory leaks
	*/	
	function addListener(target, eventType, fn) {
		target.attachEvent(eventType, fn);
		listenersArr[listenersArr.length] = [target, eventType, fn];
	}
	
	/* Flash Player and SWF content version matching
	*/
	function hasPlayerVersion(rv) {
		var pv = ua.pv, v = rv.split(".");
		v[0] = parseInt(v[0], 10);
		v[1] = parseInt(v[1], 10) || 0; // supports short notation, e.g. "9" instead of "9.0.0"
		v[2] = parseInt(v[2], 10) || 0;
		return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
	}
	
	/* Cross-browser dynamic CSS creation
		- Based on Bobby van der Sluis' solution: http://www.bobbyvandersluis.com/articles/dynamicCSS.php
	*/	
	function createCSS(sel, decl, media, newStyle) {
		if (ua.ie && ua.mac) { return; }
		var h = doc.getElementsByTagName("head")[0];
		if (!h) { return; } // to also support badly authored HTML pages that lack a head element
		var m = (media && typeof media == "string") ? media : "screen";
		if (newStyle) {
			dynamicStylesheet = null;
			dynamicStylesheetMedia = null;
		}
		if (!dynamicStylesheet || dynamicStylesheetMedia != m) { 
			// create dynamic stylesheet + get a global reference to it
			var s = createElement("style");
			s.setAttribute("type", "text/css");
			s.setAttribute("media", m);
			dynamicStylesheet = h.appendChild(s);
			if (ua.ie && ua.win && typeof doc.styleSheets != UNDEF && doc.styleSheets.length > 0) {
				dynamicStylesheet = doc.styleSheets[doc.styleSheets.length - 1];
			}
			dynamicStylesheetMedia = m;
		}
		// add style rule
		if (ua.ie && ua.win) {
			if (dynamicStylesheet && typeof dynamicStylesheet.addRule == OBJECT) {
				dynamicStylesheet.addRule(sel, decl);
			}
		}
		else {
			if (dynamicStylesheet && typeof doc.createTextNode != UNDEF) {
				dynamicStylesheet.appendChild(doc.createTextNode(sel + " {" + decl + "}"));
			}
		}
	}
	
	function setVisibility(id, isVisible) {
		if (!autoHideShow) { return; }
		var v = isVisible ? "visible" : "hidden";
		if (isDomLoaded && getElementById(id)) {
			getElementById(id).style.visibility = v;
		}
		else {
			createCSS("#" + id, "visibility:" + v);
		}
	}

	/* Filter to avoid XSS attacks
	*/
	function urlEncodeIfNecessary(s) {
		var regex = /[\\\"<>\.;]/;
		var hasBadChars = regex.exec(s) != null;
		return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;
	}
	
	/* Release memory to avoid memory leaks caused by closures, fix hanging audio/video threads and force open sockets/NetConnections to disconnect (Internet Explorer only)
	*/
	var cleanup = function() {
		if (ua.ie && ua.win) {
			window.attachEvent("onunload", function() {
				// remove listeners to avoid memory leaks
				var ll = listenersArr.length;
				for (var i = 0; i < ll; i++) {
					listenersArr[i][0].detachEvent(listenersArr[i][1], listenersArr[i][2]);
				}
				// cleanup dynamically embedded objects to fix audio/video threads and force open sockets and NetConnections to disconnect
				var il = objIdArr.length;
				for (var j = 0; j < il; j++) {
					removeSWF(objIdArr[j]);
				}
				// cleanup library's main closures to avoid memory leaks
				for (var k in ua) {
					ua[k] = null;
				}
				ua = null;
				for (var l in swfobject) {
					swfobject[l] = null;
				}
				swfobject = null;
			});
		}
	}();
	
	return {
		/* Public API
			- Reference: http://code.google.com/p/swfobject/wiki/documentation
		*/ 
		registerObject: function(objectIdStr, swfVersionStr, xiSwfUrlStr, callbackFn) {
			if (ua.w3 && objectIdStr && swfVersionStr) {
				var regObj = {};
				regObj.id = objectIdStr;
				regObj.swfVersion = swfVersionStr;
				regObj.expressInstall = xiSwfUrlStr;
				regObj.callbackFn = callbackFn;
				regObjArr[regObjArr.length] = regObj;
				setVisibility(objectIdStr, false);
			}
			else if (callbackFn) {
				callbackFn({success:false, id:objectIdStr});
			}
		},
		
		getObjectById: function(objectIdStr) {
			if (ua.w3) {
				return getObjectById(objectIdStr);
			}
		},
		
		embedSWF: function(swfUrlStr, replaceElemIdStr, widthStr, heightStr, swfVersionStr, xiSwfUrlStr, flashvarsObj, parObj, attObj, callbackFn) {
			var callbackObj = {success:false, id:replaceElemIdStr};
			if (ua.w3 && !(ua.wk && ua.wk < 312) && swfUrlStr && replaceElemIdStr && widthStr && heightStr && swfVersionStr) {
				setVisibility(replaceElemIdStr, false);
				addDomLoadEvent(function() {
					widthStr += ""; // auto-convert to string
					heightStr += "";
					var att = {};
					if (attObj && typeof attObj === OBJECT) {
						for (var i in attObj) { // copy object to avoid the use of references, because web authors often reuse attObj for multiple SWFs
							att[i] = attObj[i];
						}
					}
					att.data = swfUrlStr;
					att.width = widthStr;
					att.height = heightStr;
					var par = {}; 
					if (parObj && typeof parObj === OBJECT) {
						for (var j in parObj) { // copy object to avoid the use of references, because web authors often reuse parObj for multiple SWFs
							par[j] = parObj[j];
						}
					}
					if (flashvarsObj && typeof flashvarsObj === OBJECT) {
						for (var k in flashvarsObj) { // copy object to avoid the use of references, because web authors often reuse flashvarsObj for multiple SWFs
							if (typeof par.flashvars != UNDEF) {
								par.flashvars += "&" + k + "=" + flashvarsObj[k];
							}
							else {
								par.flashvars = k + "=" + flashvarsObj[k];
							}
						}
					}
					if (hasPlayerVersion(swfVersionStr)) { // create SWF
						var obj = createSWF(att, par, replaceElemIdStr);
						if (att.id == replaceElemIdStr) {
							setVisibility(replaceElemIdStr, true);
						}
						callbackObj.success = true;
						callbackObj.ref = obj;
					}
					else if (xiSwfUrlStr && canExpressInstall()) { // show Adobe Express Install
						att.data = xiSwfUrlStr;
						showExpressInstall(att, par, replaceElemIdStr, callbackFn);
						return;
					}
					else { // show alternative content
						setVisibility(replaceElemIdStr, true);
					}
					if (callbackFn) { callbackFn(callbackObj); }
				});
			}
			else if (callbackFn) { callbackFn(callbackObj);	}
		},
		
		switchOffAutoHideShow: function() {
			autoHideShow = false;
		},
		
		ua: ua,
		
		getFlashPlayerVersion: function() {
			return { major:ua.pv[0], minor:ua.pv[1], release:ua.pv[2] };
		},
		
		hasFlashPlayerVersion: hasPlayerVersion,
		
		createSWF: function(attObj, parObj, replaceElemIdStr) {
			if (ua.w3) {
				return createSWF(attObj, parObj, replaceElemIdStr);
			}
			else {
				return undefined;
			}
		},
		
		showExpressInstall: function(att, par, replaceElemIdStr, callbackFn) {
			if (ua.w3 && canExpressInstall()) {
				showExpressInstall(att, par, replaceElemIdStr, callbackFn);
			}
		},
		
		removeSWF: function(objElemIdStr) {
			if (ua.w3) {
				removeSWF(objElemIdStr);
			}
		},
		
		createCSS: function(selStr, declStr, mediaStr, newStyleBoolean) {
			if (ua.w3) {
				createCSS(selStr, declStr, mediaStr, newStyleBoolean);
			}
		},
		
		addDomLoadEvent: addDomLoadEvent,
		
		addLoadEvent: addLoadEvent,
		
		getQueryParamValue: function(param) {
			var q = doc.location.search || doc.location.hash;
			if (q) {
				if (/\?/.test(q)) { q = q.split("?")[1]; } // strip question mark
				if (param == null) {
					return urlEncodeIfNecessary(q);
				}
				var pairs = q.split("&");
				for (var i = 0; i < pairs.length; i++) {
					if (pairs[i].substring(0, pairs[i].indexOf("=")) == param) {
						return urlEncodeIfNecessary(pairs[i].substring((pairs[i].indexOf("=") + 1)));
					}
				}
			}
			return "";
		},
		
		// For internal usage only
		expressInstallCallback: function() {
			if (isExpressInstallActive) {
				var obj = getElementById(EXPRESS_INSTALL_ID);
				if (obj && storedAltContent) {
					obj.parentNode.replaceChild(storedAltContent, obj);
					if (storedAltContentId) {
						setVisibility(storedAltContentId, true);
						if (ua.ie && ua.win) { storedAltContent.style.display = "block"; }
					}
					if (storedCallbackFn) { storedCallbackFn(storedCallbackObj); }
				}
				isExpressInstallActive = false;
			} 
		}
	};
}();

module.exports = swfobject;
},{}],437:[function(require,module,exports){
module.exports=require(2)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/base/BitmapData.js":2,"awayjs-core/lib/geom/Rectangle":450,"awayjs-core/lib/utils/ColorUtils":462}],438:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":440}],439:[function(require,module,exports){
module.exports=require(4)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/ArgumentError.js":4,"awayjs-core/lib/errors/Error":440}],440:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],441:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":442}],442:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],443:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],444:[function(require,module,exports){
module.exports=require(239)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-core/lib/geom/ColorTransform.js":239,"awayjs-core/lib/utils/ColorUtils":462}],445:[function(require,module,exports){
module.exports=require(16)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Matrix.js":16,"awayjs-core/lib/errors/ArgumentError":439,"awayjs-core/lib/geom/Point":449}],446:[function(require,module,exports){
module.exports=require(113)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3D.js":113,"awayjs-core/lib/errors/ArgumentError":439,"awayjs-core/lib/geom/Orientation3D":448,"awayjs-core/lib/geom/Vector3D":451}],447:[function(require,module,exports){
module.exports=require(114)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3DUtils.js":114,"awayjs-core/lib/geom/Matrix3D":446,"awayjs-core/lib/geom/Vector3D":451}],448:[function(require,module,exports){
module.exports=require(115)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Orientation3D.js":115}],449:[function(require,module,exports){
module.exports=require(17)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Point.js":17}],450:[function(require,module,exports){
module.exports=require(18)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Rectangle.js":18,"awayjs-core/lib/geom/Point":449}],451:[function(require,module,exports){
module.exports=require(19)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Vector3D.js":19}],452:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],453:[function(require,module,exports){
module.exports=require(31)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/NamedAssetBase.js":31,"awayjs-core/lib/errors/AbstractMethodError":438,"awayjs-core/lib/events/AssetEvent":441,"awayjs-core/lib/events/EventDispatcher":443}],454:[function(require,module,exports){
module.exports=require(249)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-core/lib/textures/BitmapTexture.js":249,"awayjs-core/lib/errors/Error":440,"awayjs-core/lib/textures/Texture2DBase":457,"awayjs-core/lib/utils/TextureUtils":463}],455:[function(require,module,exports){
module.exports=require(46)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/MipmapGenerator.js":46,"awayjs-core/lib/base/BitmapData":437,"awayjs-core/lib/geom/Matrix":445,"awayjs-core/lib/geom/Rectangle":450}],456:[function(require,module,exports){
module.exports=require(128)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/textures/RenderTexture.js":128,"awayjs-core/lib/errors/Error":440,"awayjs-core/lib/textures/Texture2DBase":457,"awayjs-core/lib/utils/TextureUtils":463}],457:[function(require,module,exports){
module.exports=require(47)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/Texture2DBase.js":47,"awayjs-core/lib/errors/AbstractMethodError":438,"awayjs-core/lib/textures/MipmapGenerator":455,"awayjs-core/lib/textures/TextureProxyBase":458}],458:[function(require,module,exports){
module.exports=require(48)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/TextureProxyBase.js":48,"awayjs-core/lib/library/AssetType":452,"awayjs-core/lib/library/NamedAssetBase":453}],459:[function(require,module,exports){
module.exports=require(49)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ByteArray.js":49,"awayjs-core/lib/utils/ByteArrayBase":460}],460:[function(require,module,exports){
module.exports=require(50)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ByteArrayBase.js":50,"awayjs-core/lib/errors/AbstractMethodError":438}],461:[function(require,module,exports){
var CSS = (function () {
    function CSS() {
    }
    CSS.setElementSize = function (element, width, height) {
        element.style.width = width + "px";
        element.style.height = height + "px";
        element["width"] = width;
        element["height"] = height;
    };
    CSS.setElementWidth = function (element, width) {
        element.style.width = width + "px";
        element["width"] = width;
    };
    CSS.setElementHeight = function (element, height) {
        element.style.height = height + "px";
        element["height"] = height;
    };
    CSS.setElementX = function (element, x) {
        element.style.position = 'absolute';
        element.style.left = x + "px";
    };
    CSS.setElementY = function (element, y) {
        element.style.position = 'absolute';
        element.style.top = y + "px";
    };
    CSS.getElementVisibility = function (element) {
        return element.style.visibility == 'visible';
    };
    CSS.setElementVisibility = function (element, visible) {
        if (visible) {
            element.style.visibility = 'visible';
        }
        else {
            element.style.visibility = 'hidden';
        }
    };
    CSS.setElementAlpha = function (element, alpha) {
        if (element instanceof HTMLCanvasElement) {
            var context = element.getContext("2d");
            context.globalAlpha = alpha;
        }
    };
    CSS.setElementPosition = function (element, x, y, absolute) {
        if (absolute === void 0) { absolute = false; }
        if (absolute) {
            element.style.position = "absolute";
        }
        else {
            element.style.position = "relative";
        }
        element.style.left = x + "px";
        element.style.top = y + "px";
    };
    return CSS;
})();
module.exports = CSS;


},{}],462:[function(require,module,exports){
module.exports=require(51)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ColorUtils.js":51}],463:[function(require,module,exports){
module.exports=require(54)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/TextureUtils.js":54}],464:[function(require,module,exports){
module.exports=require(57)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/AlignmentMode.js":57}],465:[function(require,module,exports){
module.exports=require(256)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-display/lib/base/BlendMode.js":256}],466:[function(require,module,exports){
module.exports=require(58)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/DisplayObject.js":58,"awayjs-core/lib/bounds/AxisAlignedBoundingBox":512,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/geom/MathConsts":526,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Matrix3DUtils":529,"awayjs-core/lib/geom/Point":533,"awayjs-core/lib/geom/Vector3D":535,"awayjs-core/lib/library/NamedAssetBase":537,"awayjs-display/lib/base/AlignmentMode":464,"awayjs-display/lib/base/OrientationMode":470,"awayjs-display/lib/base/Transform":473,"awayjs-display/lib/events/DisplayObjectEvent":483,"awayjs-display/lib/events/SceneEvent":487,"awayjs-display/lib/pick/PickingCollisionVO":503}],467:[function(require,module,exports){
module.exports=require(59)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/LightBase.js":59,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/library/AssetType":536,"awayjs-display/lib/containers/DisplayObjectContainer":476,"awayjs-display/lib/events/LightEvent":484}],468:[function(require,module,exports){
module.exports=require(259)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-display/lib/base/LineSubGeometry.js":259,"awayjs-display/lib/base/LineSubMesh":469,"awayjs-display/lib/base/SubGeometryBase":471,"awayjs-display/lib/base/TriangleSubGeometry":474,"awayjs-display/lib/events/SubGeometryEvent":489}],469:[function(require,module,exports){
module.exports=require(260)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-display/lib/base/LineSubMesh.js":260,"awayjs-core/lib/library/AssetType":536,"awayjs-display/lib/base/SubMeshBase":472}],470:[function(require,module,exports){
module.exports=require(60)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/OrientationMode.js":60}],471:[function(require,module,exports){
module.exports=require(158)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/SubGeometryBase.js":158,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/library/NamedAssetBase":537,"awayjs-display/lib/events/SubGeometryEvent":489}],472:[function(require,module,exports){
module.exports=require(159)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/SubMeshBase.js":159,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/library/NamedAssetBase":537}],473:[function(require,module,exports){
module.exports=require(61)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/base/Transform.js":61,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Matrix3DUtils":529,"awayjs-core/lib/geom/Vector3D":535}],474:[function(require,module,exports){
module.exports=require(161)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/TriangleSubGeometry.js":161,"awayjs-core/lib/geom/Vector3D":535,"awayjs-display/lib/base/SubGeometryBase":471,"awayjs-display/lib/base/TriangleSubMesh":475,"awayjs-display/lib/events/SubGeometryEvent":489}],475:[function(require,module,exports){
module.exports=require(162)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/base/TriangleSubMesh.js":162,"awayjs-core/lib/library/AssetType":536,"awayjs-display/lib/base/SubMeshBase":472}],476:[function(require,module,exports){
module.exports=require(62)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/containers/DisplayObjectContainer.js":62,"awayjs-core/lib/errors/ArgumentError":517,"awayjs-core/lib/errors/Error":518,"awayjs-core/lib/errors/RangeError":520,"awayjs-core/lib/library/AssetType":536,"awayjs-display/lib/base/DisplayObject":466}],477:[function(require,module,exports){
var ContextMode = (function () {
    function ContextMode() {
    }
    ContextMode.AUTO = "auto";
    ContextMode.WEBGL = "webgl";
    ContextMode.FLASH = "flash";
    ContextMode.NATIVE = "native";
    return ContextMode;
})();
module.exports = ContextMode;


},{}],478:[function(require,module,exports){
module.exports=require(65)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/Camera.js":65,"awayjs-core/lib/bounds/NullBounds":515,"awayjs-core/lib/events/ProjectionEvent":524,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Plane3D":531,"awayjs-core/lib/library/AssetType":536,"awayjs-core/lib/projections/PerspectiveProjection":540,"awayjs-display/lib/containers/DisplayObjectContainer":476,"awayjs-display/lib/events/CameraEvent":482,"awayjs-display/lib/partition/CameraNode":497}],479:[function(require,module,exports){
module.exports=require(66)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/DirectionalLight.js":66,"awayjs-core/lib/bounds/NullBounds":515,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Vector3D":535,"awayjs-display/lib/base/LightBase":467,"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper":495,"awayjs-display/lib/partition/DirectionalLightNode":498}],480:[function(require,module,exports){
module.exports=require(67)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/LightProbe.js":67,"awayjs-core/lib/bounds/NullBounds":515,"awayjs-core/lib/errors/Error":518,"awayjs-display/lib/base/LightBase":467,"awayjs-display/lib/partition/LightProbeNode":500}],481:[function(require,module,exports){
module.exports=require(68)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/entities/PointLight.js":68,"awayjs-core/lib/bounds/BoundingSphere":513,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Vector3D":535,"awayjs-display/lib/base/LightBase":467,"awayjs-display/lib/materials/shadowmappers/CubeMapShadowMapper":494,"awayjs-display/lib/partition/PointLightNode":502}],482:[function(require,module,exports){
module.exports=require(69)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/CameraEvent.js":69,"awayjs-core/lib/events/Event":522}],483:[function(require,module,exports){
module.exports=require(70)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/DisplayObjectEvent.js":70,"awayjs-core/lib/events/Event":522}],484:[function(require,module,exports){
module.exports=require(71)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/LightEvent.js":71,"awayjs-core/lib/events/Event":522}],485:[function(require,module,exports){
module.exports=require(275)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-display/lib/events/MaterialEvent.js":275,"awayjs-core/lib/events/Event":522}],486:[function(require,module,exports){
module.exports=require(73)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/RendererEvent.js":73,"awayjs-core/lib/events/Event":522}],487:[function(require,module,exports){
module.exports=require(74)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/events/SceneEvent.js":74,"awayjs-core/lib/events/Event":522}],488:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Event = require("awayjs-core/lib/events/Event");
var StageEvent = (function (_super) {
    __extends(StageEvent, _super);
    function StageEvent(type) {
        _super.call(this, type);
    }
    StageEvent.CONTEXT_CREATED = "contextCreated";
    StageEvent.CONTEXT_DISPOSED = "contextDisposed";
    StageEvent.CONTEXT_RECREATED = "contextRecreated";
    StageEvent.VIEWPORT_UPDATED = "viewportUpdated";
    return StageEvent;
})(Event);
module.exports = StageEvent;


},{"awayjs-core/lib/events/Event":522}],489:[function(require,module,exports){
module.exports=require(168)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-display/lib/events/SubGeometryEvent.js":168,"awayjs-core/lib/events/Event":522}],490:[function(require,module,exports){
module.exports=require(278)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-display/lib/materials/LightSources.js":278}],491:[function(require,module,exports){
module.exports=require(279)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-renderergl/node_modules/awayjs-stagegl/node_modules/awayjs-display/lib/materials/MaterialBase.js":279,"awayjs-core/lib/events/Event":522,"awayjs-core/lib/library/AssetType":536,"awayjs-core/lib/library/NamedAssetBase":537,"awayjs-display/lib/base/BlendMode":465,"awayjs-display/lib/events/MaterialEvent":485}],492:[function(require,module,exports){
module.exports=require(76)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/lightpickers/LightPickerBase.js":76,"awayjs-core/lib/library/AssetType":536,"awayjs-core/lib/library/NamedAssetBase":537}],493:[function(require,module,exports){
module.exports=require(77)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/lightpickers/StaticLightPicker.js":77,"awayjs-core/lib/events/Event":522,"awayjs-display/lib/entities/DirectionalLight":479,"awayjs-display/lib/entities/LightProbe":480,"awayjs-display/lib/entities/PointLight":481,"awayjs-display/lib/events/LightEvent":484,"awayjs-display/lib/materials/lightpickers/LightPickerBase":492}],494:[function(require,module,exports){
module.exports=require(78)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/shadowmappers/CubeMapShadowMapper.js":78,"awayjs-core/lib/errors/PartialImplementationError":519,"awayjs-display/lib/entities/Camera":478,"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase":496}],495:[function(require,module,exports){
module.exports=require(79)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper.js":79,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/projections/FreeMatrixProjection":539,"awayjs-display/lib/entities/Camera":478,"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase":496}],496:[function(require,module,exports){
module.exports=require(80)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/materials/shadowmappers/ShadowMapperBase.js":80,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/textures/RenderTexture":543,"awayjs-display/lib/traverse/ShadowCasterCollector":510}],497:[function(require,module,exports){
module.exports=require(81)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/CameraNode.js":81,"awayjs-display/lib/partition/EntityNode":499}],498:[function(require,module,exports){
module.exports=require(82)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/DirectionalLightNode.js":82,"awayjs-display/lib/partition/EntityNode":499}],499:[function(require,module,exports){
module.exports=require(83)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/EntityNode.js":83,"awayjs-core/lib/errors/PartialImplementationError":519,"awayjs-display/lib/partition/NodeBase":501}],500:[function(require,module,exports){
module.exports=require(84)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/LightProbeNode.js":84,"awayjs-display/lib/partition/EntityNode":499}],501:[function(require,module,exports){
module.exports=require(85)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/NodeBase.js":85}],502:[function(require,module,exports){
module.exports=require(88)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/partition/PointLightNode.js":88,"awayjs-display/lib/partition/EntityNode":499}],503:[function(require,module,exports){
module.exports=require(89)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pick/PickingCollisionVO.js":89}],504:[function(require,module,exports){
module.exports=require(91)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pool/EntityListItem.js":91}],505:[function(require,module,exports){
module.exports=require(92)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/pool/EntityListItemPool.js":92,"awayjs-display/lib/pool/EntityListItem":504}],506:[function(require,module,exports){
/**
 * @class away.pool.RenderablePool
 */
var RenderablePool = (function () {
    /**
     * //TODO
     *
     * @param renderableClass
     */
    function RenderablePool(renderableClass) {
        this._pool = new Object();
        this._renderableClass = renderableClass;
    }
    /**
     * //TODO
     *
     * @param materialOwner
     * @returns IRenderable
     */
    RenderablePool.prototype.getItem = function (materialOwner) {
        return (this._pool[materialOwner.id] || (this._pool[materialOwner.id] = materialOwner._iAddRenderable(new this._renderableClass(this, materialOwner))));
    };
    /**
     * //TODO
     *
     * @param materialOwner
     */
    RenderablePool.prototype.disposeItem = function (materialOwner) {
        materialOwner._iRemoveRenderable(this._pool[materialOwner.id]);
        this._pool[materialOwner.id] = null;
    };
    /**
     * //TODO
     *
     * @param renderableClass
     * @returns RenderablePool
     */
    RenderablePool.getPool = function (renderableClass) {
        var pool = RenderablePool._pools[renderableClass.id];
        if (pool != undefined)
            return pool;
        return (RenderablePool._pools[renderableClass.id] = new RenderablePool(renderableClass));
    };
    /**
     * //TODO
     *
     * @param renderableClass
     */
    RenderablePool.disposePool = function (renderableClass) {
        if (RenderablePool._pools[renderableClass.id])
            RenderablePool._pools[renderableClass.id] = undefined;
    };
    RenderablePool._pools = new Object();
    return RenderablePool;
})();
module.exports = RenderablePool;


},{}],507:[function(require,module,exports){
/**
 * @class away.sort.RenderableMergeSort
 */
var RenderableMergeSort = (function () {
    function RenderableMergeSort() {
    }
    RenderableMergeSort.prototype.sortBlendedRenderables = function (head) {
        var headB;
        var fast;
        var slow;
        if (!head || !head.next) {
            return head;
        }
        // split in two sublists
        slow = head;
        fast = head.next;
        while (fast) {
            fast = fast.next;
            if (fast) {
                slow = slow.next;
                fast = fast.next;
            }
        }
        headB = slow.next;
        slow.next = null;
        // recurse
        head = this.sortBlendedRenderables(head);
        headB = this.sortBlendedRenderables(headB);
        // merge sublists while respecting order
        var result;
        var curr;
        var l;
        if (!head)
            return headB;
        if (!headB)
            return head;
        while (head && headB) {
            if (head.zIndex < headB.zIndex) {
                l = head;
                head = head.next;
            }
            else {
                l = headB;
                headB = headB.next;
            }
            if (!result)
                result = l;
            else
                curr.next = l;
            curr = l;
        }
        if (head)
            curr.next = head;
        else if (headB)
            curr.next = headB;
        return result;
    };
    RenderableMergeSort.prototype.sortOpaqueRenderables = function (head) {
        var headB;
        var fast, slow;
        if (!head || !head.next) {
            return head;
        }
        // split in two sublists
        slow = head;
        fast = head.next;
        while (fast) {
            fast = fast.next;
            if (fast) {
                slow = slow.next;
                fast = fast.next;
            }
        }
        headB = slow.next;
        slow.next = null;
        // recurse
        head = this.sortOpaqueRenderables(head);
        headB = this.sortOpaqueRenderables(headB);
        // merge sublists while respecting order
        var result;
        var curr;
        var l;
        var cmp = 0;
        if (!head)
            return headB;
        if (!headB)
            return head;
        while (head && headB && head != null && headB != null) {
            // first sort per render order id (reduces program3D switches),
            // then on material id (reduces setting props),
            // then on zIndex (reduces overdraw)
            var aid = head.renderOrderId;
            var bid = headB.renderOrderId;
            if (aid == bid) {
                var ma = head.materialId;
                var mb = headB.materialId;
                if (ma == mb) {
                    if (head.zIndex < headB.zIndex)
                        cmp = 1;
                    else
                        cmp = -1;
                }
                else if (ma > mb) {
                    cmp = 1;
                }
                else {
                    cmp = -1;
                }
            }
            else if (aid > bid) {
                cmp = 1;
            }
            else {
                cmp = -1;
            }
            if (cmp < 0) {
                l = head;
                head = head.next;
            }
            else {
                l = headB;
                headB = headB.next;
            }
            if (!result) {
                result = l;
                curr = l;
            }
            else {
                curr.next = l;
                curr = l;
            }
        }
        if (head)
            curr.next = head;
        else if (headB)
            curr.next = headB;
        return result;
    };
    return RenderableMergeSort;
})();
module.exports = RenderableMergeSort;


},{}],508:[function(require,module,exports){
module.exports=require(93)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/traverse/CollectorBase.js":93,"awayjs-display/lib/pool/EntityListItemPool":505}],509:[function(require,module,exports){
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var CollectorBase = require("awayjs-display/lib/traverse/CollectorBase");
/**
 * @class away.traverse.EntityCollector
 */
var EntityCollector = (function (_super) {
    __extends(EntityCollector, _super);
    function EntityCollector() {
        _super.call(this);
        this._pNumLights = 0;
        this._numDirectionalLights = 0;
        this._numPointLights = 0;
        this._numLightProbes = 0;
        this._pLights = new Array();
        this._directionalLights = new Array();
        this._pointLights = new Array();
        this._lightProbes = new Array();
    }
    Object.defineProperty(EntityCollector.prototype, "directionalLights", {
        /**
         *
         */
        get: function () {
            return this._directionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityCollector.prototype, "lightProbes", {
        /**
         *
         */
        get: function () {
            return this._lightProbes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityCollector.prototype, "lights", {
        /**
         *
         */
        get: function () {
            return this._pLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityCollector.prototype, "pointLights", {
        /**
         *
         */
        get: function () {
            return this._pointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityCollector.prototype, "skyBox", {
        /**
         *
         */
        get: function () {
            return this._pSkybox;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param entity
     */
    EntityCollector.prototype.applyDirectionalLight = function (entity) {
        this._directionalLights[this._numDirectionalLights++] = entity;
    };
    /**
     *
     * @param entity
     */
    EntityCollector.prototype.applyLightProbe = function (entity) {
        this._lightProbes[this._numLightProbes++] = entity;
    };
    /**
     *
     * @param entity
     */
    EntityCollector.prototype.applyPointLight = function (entity) {
        this._pointLights[this._numPointLights++] = entity;
    };
    /**
     *
     * @param entity
     */
    EntityCollector.prototype.applySkybox = function (entity) {
        this._pSkybox = entity;
    };
    /**
     *
     */
    EntityCollector.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._pSkybox = null;
        if (this._pNumLights > 0)
            this._pLights.length = this._pNumLights = 0;
        if (this._numDirectionalLights > 0)
            this._directionalLights.length = this._numDirectionalLights = 0;
        if (this._numPointLights > 0)
            this._pointLights.length = this._numPointLights = 0;
        if (this._numLightProbes > 0)
            this._lightProbes.length = this._numLightProbes = 0;
    };
    return EntityCollector;
})(CollectorBase);
module.exports = EntityCollector;


},{"awayjs-display/lib/traverse/CollectorBase":508}],510:[function(require,module,exports){
module.exports=require(95)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/lib/traverse/ShadowCasterCollector.js":95,"awayjs-display/lib/traverse/CollectorBase":508}],511:[function(require,module,exports){
module.exports=require(2)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/base/BitmapData.js":2,"awayjs-core/lib/geom/Rectangle":534,"awayjs-core/lib/utils/ColorUtils":546}],512:[function(require,module,exports){
module.exports=require(97)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/AxisAlignedBoundingBox.js":97,"awayjs-core/lib/bounds/BoundingVolumeBase":514,"awayjs-core/lib/geom/Matrix3DUtils":529,"awayjs-core/lib/geom/PlaneClassification":532,"awayjs-core/lib/geom/Vector3D":535}],513:[function(require,module,exports){
module.exports=require(98)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/BoundingSphere.js":98,"awayjs-core/lib/bounds/BoundingVolumeBase":514,"awayjs-core/lib/geom/PlaneClassification":532,"awayjs-core/lib/geom/Vector3D":535}],514:[function(require,module,exports){
module.exports=require(99)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/BoundingVolumeBase.js":99,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/geom/Box":525}],515:[function(require,module,exports){
module.exports=require(100)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/bounds/NullBounds.js":100,"awayjs-core/lib/bounds/BoundingVolumeBase":514,"awayjs-core/lib/geom/PlaneClassification":532}],516:[function(require,module,exports){
module.exports=require(3)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/AbstractMethodError.js":3,"awayjs-core/lib/errors/Error":518}],517:[function(require,module,exports){
module.exports=require(4)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/ArgumentError.js":4,"awayjs-core/lib/errors/Error":518}],518:[function(require,module,exports){
module.exports=require(5)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/Error.js":5}],519:[function(require,module,exports){
module.exports=require(6)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/errors/PartialImplementationError.js":6,"awayjs-core/lib/errors/Error":518}],520:[function(require,module,exports){
module.exports=require(105)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/errors/RangeError.js":105,"awayjs-core/lib/errors/Error":518}],521:[function(require,module,exports){
module.exports=require(7)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/AssetEvent.js":7,"awayjs-core/lib/events/Event":522}],522:[function(require,module,exports){
module.exports=require(8)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/Event.js":8}],523:[function(require,module,exports){
module.exports=require(9)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/events/EventDispatcher.js":9}],524:[function(require,module,exports){
module.exports=require(109)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/events/ProjectionEvent.js":109,"awayjs-core/lib/events/Event":522}],525:[function(require,module,exports){
module.exports=require(110)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Box.js":110,"awayjs-core/lib/geom/Vector3D":535}],526:[function(require,module,exports){
module.exports=require(111)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/MathConsts.js":111}],527:[function(require,module,exports){
module.exports=require(16)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Matrix.js":16,"awayjs-core/lib/errors/ArgumentError":517,"awayjs-core/lib/geom/Point":533}],528:[function(require,module,exports){
module.exports=require(113)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3D.js":113,"awayjs-core/lib/errors/ArgumentError":517,"awayjs-core/lib/geom/Orientation3D":530,"awayjs-core/lib/geom/Vector3D":535}],529:[function(require,module,exports){
module.exports=require(114)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Matrix3DUtils.js":114,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Vector3D":535}],530:[function(require,module,exports){
module.exports=require(115)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Orientation3D.js":115}],531:[function(require,module,exports){
module.exports=require(116)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/Plane3D.js":116,"awayjs-core/lib/geom/PlaneClassification":532}],532:[function(require,module,exports){
module.exports=require(117)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/geom/PlaneClassification.js":117}],533:[function(require,module,exports){
module.exports=require(17)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Point.js":17}],534:[function(require,module,exports){
module.exports=require(18)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Rectangle.js":18,"awayjs-core/lib/geom/Point":533}],535:[function(require,module,exports){
module.exports=require(19)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/geom/Vector3D.js":19}],536:[function(require,module,exports){
module.exports=require(25)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/AssetType.js":25}],537:[function(require,module,exports){
module.exports=require(31)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/library/NamedAssetBase.js":31,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/events/AssetEvent":521,"awayjs-core/lib/events/EventDispatcher":523}],538:[function(require,module,exports){
module.exports=require(123)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/CoordinateSystem.js":123}],539:[function(require,module,exports){
module.exports=require(124)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/FreeMatrixProjection.js":124,"awayjs-core/lib/projections/PerspectiveProjection":540,"awayjs-core/lib/projections/ProjectionBase":541}],540:[function(require,module,exports){
module.exports=require(125)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/PerspectiveProjection.js":125,"awayjs-core/lib/geom/Vector3D":535,"awayjs-core/lib/projections/CoordinateSystem":538,"awayjs-core/lib/projections/ProjectionBase":541}],541:[function(require,module,exports){
module.exports=require(126)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/projections/ProjectionBase.js":126,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/events/EventDispatcher":523,"awayjs-core/lib/events/ProjectionEvent":524,"awayjs-core/lib/geom/Matrix3D":528,"awayjs-core/lib/geom/Rectangle":534}],542:[function(require,module,exports){
module.exports=require(46)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/MipmapGenerator.js":46,"awayjs-core/lib/base/BitmapData":511,"awayjs-core/lib/geom/Matrix":527,"awayjs-core/lib/geom/Rectangle":534}],543:[function(require,module,exports){
module.exports=require(128)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-display/node_modules/awayjs-core/lib/textures/RenderTexture.js":128,"awayjs-core/lib/errors/Error":518,"awayjs-core/lib/textures/Texture2DBase":544,"awayjs-core/lib/utils/TextureUtils":547}],544:[function(require,module,exports){
module.exports=require(47)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/Texture2DBase.js":47,"awayjs-core/lib/errors/AbstractMethodError":516,"awayjs-core/lib/textures/MipmapGenerator":542,"awayjs-core/lib/textures/TextureProxyBase":545}],545:[function(require,module,exports){
module.exports=require(48)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/textures/TextureProxyBase.js":48,"awayjs-core/lib/library/AssetType":536,"awayjs-core/lib/library/NamedAssetBase":537}],546:[function(require,module,exports){
module.exports=require(51)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/ColorUtils.js":51}],547:[function(require,module,exports){
module.exports=require(54)
},{"/Users/robbateman/WebstormProjects/awayjs-examples/node_modules/awayjs-core/lib/utils/TextureUtils.js":54}]},{},[1])


//# sourceMappingURL=ObjLoaderMasterChief.js.map